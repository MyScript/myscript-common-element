<!--
Copyright Â© MyScript.
LICENSE: [Apache License 2.0](http://www.apache.org/licenses/LICENSE-2.0)
-->
<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../iron-resizable-behavior/iron-resizable-behavior.html">
<link rel="import" href="../iron-icons/iron-icons.html">
<link rel="import" href="../paper-fab/paper-fab.html">
<link rel="import" href="../paper-toast/paper-toast.html">
<!--
The `myscript-common-element` is a web component wrapper around MyScriptJS InkPaper.

    <myscript-common-element
        applicationkey="XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX"
        hmackey="XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX"
        timeout="2000"
        typeset="true"
        shapeparameters="{
            doBeautification: true
        }">
    </myscript-common-element>

@demo demo/index.html
-->
<dom-module id="myscript-common-element">
    <style>

        :host {
            display: block;
            position: relative;
            min-height: 100px;
            min-width: 200px;
            --paper-fab-background: #1A9FFF;
            --paper-fab-keyboard-focus-background: #1A9FFF;
            --paper-fab-disabled-background: #D7DADC;
            --paper-fab-disabled-text: #dcdee0;
        }
        .buttons {
            position: inherit;
            float: left;
            display: flex;
            display: -webkit-flex;
            z-index: 2;
            background-color: transparent;
            padding: 6px;
        }
        paper-fab {
            z-index: 3;
            background: #1A9FFF;
            margin: 6px;
        }
    </style>
    <template>
        <style>
            @import url("../myscript/dist/myscript.min.css");

            :host {
                display: block;
                position: relative;
                min-height: 200px;
                min-width: 200px;
                height: 100%;
                width: 100%;
                --paper-fab-background: #1A9FFF;
                --paper-fab-keyboard-focus-background: #1A9FFF;
                --paper-fab-disabled-background: #F5F6F7;
                --paper-fab-disabled-text: #dcdee0;
            }

            [hidden] {
                display: none !important;
            }

            .buttons {
                position: inherit;
                float: left;
                display: flex;
                display: -webkit-flex;
                z-index: 2;
                background-color: transparent;
                padding: 6px;
            }

            paper-fab {
                z-index: 3;
                margin: 6px;
            }

            #myscript-input-area {
                position: absolute;
                left: 0;
                top: 0;
                height: 100%;
                width: 100%;
            }

        </style>
        <div class="buttons" hidden="[[ hidebuttons ]]">
            <paper-fab mini src="undo.svg" title="undo" on-tap="undo" disabled="[[ !canundo ]]"
                       hidden="[[ _disableUndoRedo ]]"></paper-fab>
            <paper-fab mini src="redo.svg" title="redo" on-tap="redo" disabled="[[ !canredo ]]"
                       hidden="[[ _disableUndoRedo ]]"></paper-fab>
            <paper-fab mini src="trash.svg" title="clear" on-tap="clear" disabled="[[ !canclear ]]"
                       hidden="[[ _disableClear ]]"></paper-fab>
            <paper-fab mini src="send.svg" title="recognize" on-tap="recognize" disabled="[[ !canclear ]]"
                       hidden="[[ _disableRecognize ]]"></paper-fab>
        </div>
        <div id="myscript-input-area"></div>
        <paper-toast class="fit-bottom"></paper-toast>
    </template>
    <script src="../myscript/dist/myscript.min.js"></script>
    <script>
        function qsWrapper(domElement) {
            if (domElement.shadowRoot) {
                return domElement.shadowRoot;
            } else {
                return domElement;
            }
        }
        function updateUndoRedoClearState(commonElement, eventDetail) {
            commonElement.canclear = eventDetail.canClear;
            commonElement.canundo = eventDetail.canUndo;
            commonElement.canredo = eventDetail.canRedo;
        }

        function manageError(commonElement, eventDetail) {
            console.log("Error detected");
            if (e.detail && e.detail.message) {
                const paperToast = commonElement.shadowRoot.querySelector('paper-toast');
                paperToast.text = e.detail.message;
                paperToast.fitIn = paperToast.show();
            }
        }
        Polymer({
                    is: 'myscript-common-element',

                    properties: {
                        /**
                         * TODO
                         */
                        open: {
                            type: Boolean,
                            value: true,
                            notify: true,
                            observer: '_openChanged'
                        },

                        /**
                         * TODO
                         */
                        options: {
                            type: Object,

                        },
                        /**
                         * The current recognition type (e.g. TEXT, SHAPE, MATH, MUSIC or ANALYZER)
                         * @default 'TEXT'
                         */
                        type: {
                            type: String,
                            value: 'TEXT',
                        },
                        /**
                         * The current recognition protocol (WebSocket or REST). We strongly recommend using WebSocket.
                         * @type String
                         * @default 'REST'
                         */
                        protocol: {
                            type: String,
                            value: 'REST',
                        },
                        /**
                         * Recogntion API version to use
                         * @type String
                         * @default 'V3'
                         */
                        apiversion: {
                            type: String,
                            value: 'V3',
                        },
                        /**
                         * Scheme to use to connect to MyScript Cloud or Server. (https or http)
                         * @private
                         * @type Boolean
                         * @default true
                         */
                        scheme: {
                            type: String,
                            value: 'https',
                        },
                        /**
                         * The current recognition service host.
                         * @type String
                         * @default 'cloud.myscript.com'
                         */
                        host: {
                            type: String,
                            value: 'cloud.myscript.com',
                        },
                        /**
                         * <b>not mutable</b><br />
                         * Application key to use for recognition on MyScript handwriting recognition server.<br />
                         * You have to create your own MyScript Developer account at http://dev.myscript.com and then generate your application key at http://cloud.myscript.com. See the Developer Guide to learn how to register.<br /><br />
                         * <b>Warning</b>: This parameter is <b>mandatory</b> and its value should be a string.
                         * @type String
                         */
                        applicationkey: {
                            type: String,
                        },
                        /**
                         * <b>not mutable</b><br />
                         * HMAC key to use for recognition on MyScript handwriting recognition server.<br />
                         * You have to create your own HMAC key corresponding to your own application key in your account at http://cloud.myscript.com.<br /><br />
                         * <b>Warning</b>: This parameter may be <b>mandatory</b> if HMAC signature security is enabled for your application. The value should be a string.
                         * @type String
                         */
                        hmackey: {
                            type: String,
                        },
                        /**
                         * Set the stroke color
                         * @type String
                         */
                        strokecolor: {
                            type: String,
                            value: '#1580CD',
                            observer: '_strokecolorChanged'
                        },
                        /**
                         * Set the stroke width
                         * @type String
                         */
                        strokewidth: {
                            type: Number,
                            value: 4,
                            observer: '_strokewidthChanged'
                        },
                        /**
                         * True if undo is available
                         * @private
                         * @type Boolean
                         * @default false
                         */
                        canundo: {
                            type: Boolean,
                            value: false
                        },
                        /**
                         * True if redo is available
                         * @private
                         * @type Boolean
                         * @default false
                         */
                        canredo: {
                            type: Boolean,
                            value: false
                        },
                        /**
                         * True if there is something to clear
                         * @private
                         * @type Boolean
                         * @default false
                         */
                        canclear: {
                            type: Boolean,
                            value: false
                        },
                        /**
                         * If set to true, hide the buttons (Trash, Undo, Redo).
                         * @type Boolean
                         * @default false
                         */
                        hidebuttons: {
                            type: Boolean,
                            value: false
                        },

                        /**
                         * True if the undo/redo feature is disabled, false otherwise
                         */
                        _disableUndoRedo: {
                            type: Boolean,
                            value: false
                        },
                        /**
                         * True if the clear feature is disabled, false otherwise
                         */
                        _disableClear: {
                            type: Boolean,
                            value: false
                        },
                        /**
                         * True if the recognize feature is disabled, false otherwise
                         */
                        _disableRecognize: {
                            type: Boolean,
                            value: true
                        }
                    },
                    behaviors: [
                        Polymer.IronResizableBehavior
                    ],
                    listeners: {
                        'iron-resize': '_onResize'
                    },
                    _openChanged: function (oldValue, newValue, uncatched) {
                        console.log('open changed', oldValue, newValue, uncatched);
                    }
                    ,
                    //Will be renamed connected with pure custom element support
                    attached: function () {
                        const self = this;
                        console.log('connectedCallback');
                        const rootNode = qsWrapper(this);
                        //const shadowRoot = this.attachShadow({mode: 'open'});
                        console.log(qsWrapper(this));
                        if (!this.inkPaper) {
                            this.myScriptInkPaperDomElement = rootNode.querySelector('#myscript-input-area');

                            const options = {
                                renderingParams: { renderer: 'canvas' },
                                recognitionParams: { type: 'MATH' }
                            };
                            this.inkPaper = MyScript.register(this.myScriptInkPaperDomElement, options);

                            // Manage change events
                            this.myScriptInkPaperDomElement.addEventListener('change', function (event) {
                                console.log("change intercepted", event);
                                updateUndoRedoClearState(self, event.detail);
                            })
                            ;

                            // Manage error events
                            this.myScriptInkPaperDomElement.addEventListener('error', function (event) {
                                console.log("error intercepted", event);
                                manageError(self, event.detail);
                            })
                            ;
                        }
                    },
                    disconnectedCallback: function () {
                        console.log('disconnectedCallback fire');
                    }
                    ,
                    /*attributeChangedCallback(attributeName, oldValue, newValue, namespace) {
                     console.log('attributeChangedCallback', attributeName, oldValue, newValue, namespace);
                     this[attributeName] = newValue;
                     }*/
                    _attributeModifiedCallback: function (oldValue, newValue) {
                        console.log('_attributeModifiedCallback', att1, att2);
                    }
                    ,
                    _selectedChanged: function (selected, oldSelected) {
                        console.log('selected change');
                    }
                    ,
                    /**
                     * Clear all context
                     */
                    clear: function () {
                        if (this.inkPaper) {
                            this.inkPaper.clear();
                        }
                    },
                    /**
                     * Undo action, and launch recognition if timeout is set
                     */
                    undo: function () {
                        if (this.inkPaper) {
                            this.inkPaper.undo();
                        }
                    },
                    /**
                     * Redo action, and launch recognition if timeout is set
                     */
                    redo: function () {
                        if (this.inkPaper) {
                            this.inkPaper.redo();
                        }
                    },
                    /**
                     * Launch recognition
                     */
                    recognize: function () {
                        if (this.inkPaper) {
                            this.inkPaper.recognize();
                        }
                    },
                    /**
                     * Get available languages
                     * @param {String} inputMode Optional recognition input mode
                     */
                    getAvailableLanguages: function (inputMode) {
                        if (this.inkPaper) {
                            this.inkPaper.getAvailableLanguages(inputMode);
                        }
                    },
                    /**
                     * Return the stats allowing to monitor what ink size is send to the server.
                     * Stats objects format {strokesCount : 0, pointsCount : 0, byteSize : 0, humanSize : 0, humanUnit : 'BYTE'} humanUnit could have the values BYTE, BYTES, KiB, MiB
                     */
                    getStats: function () {
                        if (this.inkPaper) {
                            return this.inkPaper.getStats();
                        }
                    },
                    _onResize: function () {
                        if (this._inkPaper) {

                            if (this.offsetWidth && (this.offsetWidth > 0)) {
                                this._inkPaper.setWidth(this.offsetWidth);
                            }

                            if (this.offsetHeight && (this.offsetHeight > 0)) {
                                this._inkPaper.setHeight(this.offsetHeight);
                            }
                        }
                    },
                    // FIXME No need of a class method there
                    onSuccess: function (e) {
                        console.log("Sucess detected");
                        this.fire(e.type, e.detail);
                        this.fire('myscript-common-element-result', e.detail);
                    },
                    _strokecolorChanged: function (newStrokecolor) {
                        // TODO
                    },
                    _strokewidthChanged: function (newStrokewidth) {

                    },
                    _onResize: function(event){
                      console.log('Resizing', event);
                      if(this.inkPaper){
                        this.inkPaper.resize();
                      }
                    }
                }
        )
        ;
    </script>
</dom-module>

{"version":3,"sources":["myscript.js","MyScript.js","point.js","rectangle.js","penParameters.js","mathUtils.js","abstractWSMessage.js","abstractComponent.js","strokeComponent.js","characterInputComponent.js","characterInputComponentAlternate.js","abstractParameter.js","abstractRecognitionInput.js","abstractRecognitionData.js","recognitionLanguagesData.js","abstractStartRequestWSMessage.js","abstractContinueRequestWSMessage.js","challengeRequestWSMessage.js","initRequestWSMessage.js","resetRequestWSMessage.js","abstractTextInputComponent.js","charInputComponent.js","stringInputComponent.js","textInputUnit.js","textParameter.js","textProperties.js","textRecognitionInput.js","textRecognitionData.js","textStartRequestWSMessage.js","textContinueRequestWSMessage.js","shapeParameter.js","shapeRecognitionInput.js","shapeRecognitionData.js","mathParameter.js","mathRecognitionInput.js","mathRecognitionData.js","mathStartRequestWSMessage.js","mathContinueRequestWSMessage.js","abstractMusicInputComponent.js","musicAccidentalInputComponent.js","musicArpeggiateInputComponent.js","musicBarInputComponent.js","musicBeamInputComponent.js","musicClefInputComponent.js","musicDecorationInputComponent.js","musicDotsInputComponent.js","musicHeadInputComponent.js","musicLedgerLineInputComponent.js","musicRestInputComponent.js","musicStemInputComponent.js","musicTieOrSlurInputComponent.js","musicTimeSignatureInputComponent.js","musicStaff.js","musicParameter.js","musicRecognitionInput.js","musicRecognitionData.js","analyzerParameter.js","analyzerRecognitionInput.js","analyzerRecognitionData.js","abstractResult.js","abstractRecoResponseWSMessage.js","challengeResponseWSMessage.js","errorResponseWSMessage.js","initResponseWSMessage.js","resetResponseWSMessage.js","textInkRange.js","textCandidate.js","textDocument.js","textResult.js","textSegment.js","textTagItem.js","textResponseWSMessage.js","abstractShapePrimitive.js","shapeCandidate.js","shapeDocument.js","shapeEllipse.js","shapeErased.js","shapeInkRange.js","shapeLine.js","shapeNotRecognized.js","shapeRecognized.js","shapeResult.js","shapeScratchOut.js","shapeSegment.js","mathNode.js","mathNonTerminalNode.js","mathResultElement.js","mathRuleNode.js","mathDocument.js","mathInkRange.js","mathOfficeOpenXmlMathResultElement.js","mathLaTexResultElement.js","mathMathMLResultElement.js","mathResult.js","mathScratchOut.js","mathSymbolTreeResultElement.js","mathTerminalNode.js","mathTerminalNodeCandidate.js","mathBorderData.js","mathBorderNonTerminalNode.js","mathCellData.js","mathCellNonTerminalNode.js","mathTableData.js","mathTableRuleNode.js","mathResponseWSMessage.js","musicElement.js","musicResultElement.js","musicAccidental.js","musicAnnotation.js","musicArpeggiate.js","musicBar.js","musicBeam.js","musicChord.js","musicClef.js","musicDecoration.js","musicDocument.js","musicDots.js","musicHead.js","musicInputRange.js","musicKeySignature.js","musicKeySignatureData.js","musicLedgerLine.js","musicNote.js","musicPart.js","musicPitchData.js","musicRest.js","musicResult.js","musicScore.js","musicScoreTreeResultElement.js","musicScratchOut.js","musicSlur.js","musicStem.js","musicTie.js","musicTimeModificationData.js","musicTimeSignature.js","musicTupletBracket.js","musicTuplet.js","musicXMLResultElement.js","analyzerElement.js","analyzerCell.js","analyzerCellData.js","analyzerDocument.js","analyzerElementReference.js","analyzerGroup.js","analyzerInkRange.js","analyzerLine.js","analyzerLineData.js","analyzerRecognizedStroke.js","analyzerResult.js","analyzerStrokeType.js","analyzerTable.js","analyzerTableData.js","analyzerTextLine.js","analyzerTextLineData.js","analyzerUnderline.js","analyzerUnderlineData.js","networkInterface.js","networkWSInterface.js","abstractRecognizer.js","abstractWSRecognizer.js","textRecognizer.js","textWSRecognizer.js","shapeRecognizer.js","mathRecognizer.js","mathWSRecognizer.js","musicRecognizer.js","analyzerRecognizer.js","abstractRenderer.js","textRenderer.js","shapeRenderer.js","mathRenderer.js","musicRenderer.js","analyzerRenderer.js","imageRenderer.js","inkGrabber.js","inkPaper.js"],"names":["CustomEvent","event","params","bubbles","cancelable","detail","undefined","evt","document","createEvent","initCustomEvent","prototype","window","Event","Function","bind","oThis","this","TypeError","aArgs","Array","slice","call","arguments","fToBind","fNOP","fBound","apply","concat","MyScript","RecognitionType","TEXT","MATH","SHAPE","MUSIC","ANALYZER","InputMode","CURSIVE","ISOLATED","SUPERIMPOSED","VERTICAL","InputType","CHAR","WORD","SINGLE_LINE_TEXT","MULTI_LINE_TEXT","ResultDetail","CHARACTER","ResultType","Math","LATEX","MATHML","SYMBOLTREE","OFFICEOPENXMLMATH","Music","MUSICXML","SCORETREE","Protocol","WS","REST","scope","Point","obj","x","y","getX","setX","getY","setY","Rectangle","width","height","getTopLeftPoint","point","setTopLeftPoint","topLeftPoint","getWidth","setWidth","getHeight","setHeight","PenParameters","color","rectColor","font","decoration","pressureType","alpha","getColor","setColor","getRectColor","setRectColor","getFont","setFont","getDecoration","setDecoration","MathUtils","getEllipseArcRect","center","maxRadius","minRadius","orientation","startAngle","sweepAngle","angle","z1","z2","z3","z4","cosAlpha","sinAlpha","n","xList","yList","i","xMin","xMax","yMin","yMax","angleStep","sortFloat","a","b","cos","sin","abs","atan2","push","sort","length","getLineRect","firstPoint","lastPoint","xFirst","xLast","min","max","yFirst","yLast","getBoundingRect","boundingBoxes","rectangle","AbstractWSMessage","type","getType","AbstractComponent","setType","getBoundingBox","Error","setBoundingBox","boundingBox","StrokeComponent","t","p","d","l","_computeDistance","xArray","yArray","lastIndexPoint","distance","sqrt","pow","isNaN","_computeLength","lArray","_computePressure","ratio","pressure","parseFloat","_filterPointByAcquisitionDelta","delta","ret","constructor","toJSON","addX","addY","getT","setT","addT","getLength","toFixed","precision","getP","setP","addP","getD","setD","addD","getL","setL","addL","addPoint","getLastIndexPoint","getPointByIndex","index","CharacterInputComponent","alternates","CharacterInputComponentAlternate","getAlternates","setAlternates","addAlternate","alternate","probability","getAlternate","setAlternate","getProbability","setProbability","AbstractParameter","AbstractRecognitionInput","AbstractRecognitionData","getApplicationKey","applicationKey","setApplicationKey","getInstanceId","instanceId","setInstanceId","getHmac","hmac","setHmac","getRecognitionInput","setRecognitionInput","input","RecognitionLanguagesData","getInputMode","inputMode","setInputMode","AbstractStartRequestWSMessage","AbstractContinueRequestWSMessage","ChallengeRequestWSMessage","getChallenge","challenge","setChallenge","getHmacSignature","setHmacSignature","InitRequestWSMessage","ResetRequestWSMessage","AbstractTextInputComponent","CharInputComponent","character","getLabel","setLabel","label","StringInputComponent","string","TextInputUnit","textInputType","components","getInputType","setInputType","inputType","getComponents","inkRange","TextInkRange","getStartComponent","getEndComponent","setComponents","TextParameter","textProperties","TextProperties","language","textInputMode","contentTypes","subsetKnowledges","userResources","userLkWords","resultDetail","getLanguage","setLanguage","getContentTypes","setContentTypes","getSubsetKnowledges","setSubsetKnowledges","getUserResources","setUserResources","getUserLkWords","setUserLkWords","getResultDetail","setResultDetail","getTextProperties","setTextProperties","textCandidateListSize","wordCandidateListSize","wordPredictionListSize","wordCompletionListSize","characterCandidateListSize","discardCaseVariations","discardAccentuationVariations","disableSpatialOrdering","glyphDistortion","enableOutOfLexicon","spellingDistortion","getTextCandidateListSize","setTextCandidateListSize","getWordCandidateListSize","setWordCandidateListSize","getWordPredictionListSize","setWordPredictionListSize","getWordCompletionListSize","setWordCompletionListSize","getCharacterCandidateListSize","setCharacterCandidateListSize","getDiscardCaseVariations","setDiscardCaseVariations","getDiscardAccentuationVariations","setDiscardAccentuationVariations","getDisableSpatialOrdering","setDisableSpatialOrdering","getGlyphDistortion","setGlyphDistortion","getEnableOutOfLexicon","setEnableOutOfLexicon","getSpellingDistortion","setSpellingDistortion","TextRecognitionInput","getParameters","textParameter","setParameters","parameters","getInputUnits","inputUnits","getStartUnit","getEndUnit","setInputUnits","TextRecognitionData","textInput","JSON","stringify","TextStartRequestWSMessage","TextContinueRequestWSMessage","ShapeParameter","rejectDetectionSensitivity","doBeautification","getRejectDetectionSensitivity","setRejectDetectionSensitivity","hasBeautification","setBeautification","ShapeRecognitionInput","ShapeRecognitionData","shapeInput","MathParameter","resultTypes","columnarOperation","scratchOutDetectionSensitivity","getResultTypes","setResultTypes","isColumnar","setColumnar","columnar","getScratchOutDetectionSensitivity","setScratchOutDetectionSensitivity","MathRecognitionInput","MathRecognitionData","mathInput","MathStartRequestWSMessage","MathContinueRequestWSMessage","AbstractMusicInputComponent","MusicAccidentalInputComponent","value","getValue","setValue","MusicArpeggiateInputComponent","MusicBarInputComponent","MusicBar","MusicBeamInputComponent","MusicBeam","MusicClefInputComponent","MusicClef","MusicDecorationInputComponent","MusicDecoration","MusicDotsInputComponent","MusicHeadInputComponent","MusicLedgerLineInputComponent","MusicRestInputComponent","MusicStemInputComponent","MusicTieOrSlurInputComponent","MusicTimeSignatureInputComponent","MusicStaff","count","gap","top","getCount","setCount","getTop","setTop","getGap","setGap","MusicParameter","divisions","staff","getStaff","setStaff","getDivisions","setDivisions","MusicRecognitionInput","MusicRecognitionData","musicInput","AnalyzerParameter","coordinateResolution","getTextParameters","setTextParameters","getCoordinateResolution","setCoordinateResolution","AnalyzerRecognitionInput","parameter","AnalyzerRecognitionData","analyzerInput","AbstractResult","getDocument","result","AbstractRecoResponseWSMessage","ChallengeResponseWSMessage","ErrorResponseWSMessage","error","getError","InitResponseWSMessage","ResetResponseWSMessage","cpt","split","startUnit","Number","startComponent","startPoint","endUnit","endComponent","endPoint","getStartPoint","getEndPoint","TextCandidate","flags","children","normalizedScore","spellingDistortionRatio","j","TextSegment","getNormalizedScore","getResemblanceScore","resemblanceScore","getSpellingDistortionRatio","getFlags","getChildren","TextDocument","tagItems","wordSegments","charSegments","textSegmentResult","TextTagItem","k","wordCandidates","m","charCandidates","getTagItems","getWordSegments","getWordSegment","inkRanges","getInkRanges","getCharSegments","getCharSegment","getTextSegment","hasScratchOutResults","TextResult","candidates","selectedCandidateIdx","ranges","isArray","getCandidates","getSelectedCandidateIdx","getSelectedCandidate","tagType","getTagType","TextResponseWSMessage","AbstractShapePrimitive","beginDecoration","beginTangentAngle","endDecoration","endTangentAngle","isLine","isEllipse","hasBeginDecoration","hasEndDecoration","getBeginDecoration","getEndDecoration","getBeginTangentAngle","getEndTangentAngle","ShapeCandidate","isErased","isScratchOut","isNotRecognized","isRecognized","ShapeDocument","segments","ShapeSegment","getSegments","currentSeg","currentCandidate","ShapeScratchOut","ShapeEllipse","getCenter","getMinRadius","getMaxRadius","getOrientation","getStartAngle","getSweepAngle","ShapeErased","ShapeInkRange","firstStroke","lastStroke","getFirstStroke","getLastStroke","getFirstPoint","getLastPoint","ShapeLine","ShapeNotRecognized","ShapeRecognized","primitives","normalizedRecognitionScore","getPrimitives","getNormalizedRecognitionScore","ShapeResult","elementType","uniqueID","selectedCandidateIndex","getElementType","getUniqueId","MathNode","name","getName","MathNonTerminalNode","selectedCandidate","MathTerminalNode","MathRuleNode","MathCellNonTerminalNode","MathBorderNonTerminalNode","MathTableRuleNode","MathResultElement","isLaTex","isMathMl","isSymbolTree","childInkRanges","MathDocument","results","scratchOutResults","MathMathMLResultElement","MathLaTexResultElement","MathSymbolTreeResultElement","MathOfficeOpenXmlMathResultElement","MathScratchOut","getResultElements","getScratchOutResults","MathInkRange","component","firstItem","lastItem","getComponent","getFirstItem","getLastItem","MathResult","erasedInkRanges","getErasedInkRanges","root","getRoot","MathTerminalNodeCandidate","MathBorderData","position","start","stop","getPosition","getStart","getStop","data","getData","MathCellData","columnStart","columnStop","rowStart","rowStop","getColumnStart","getColumnStop","getRowStart","getRowStop","MathTableData","columnCount","rowCount","getColumnCount","getRowCount","MathResponseWSMessage","MusicElement","inputRanges","getInputRanges","MusicResultElement","isMusicXML","isScoreTree","MusicAccidental","MusicAnnotation","MusicArpeggiate","decorations","repeatDirection","style","getRepeatDirection","setRepeatDirection","getStyle","setStyle","getDecorations","setDecorations","slope","placement","leftCount","rightCount","getSlope","setSlope","getPlacement","setPlacement","getLeftCount","setLeftCount","getRightCount","setRightCount","MusicChord","notes","beamTypes","ledgerLines","startSlurs","stopSlurs","duration","arpeggiate","startBeam","stopBeam","stem","MusicStem","MusicNote","MusicLedgerLine","MusicSlur","getDuration","getArpeggiate","getStartBeam","getStopBeam","getStem","getNotes","getBeamTypes","getLedgerLines","getStartSlurs","getStopSlurs","symbol","octave","line","yAnchor","getYAnchor","setYAnchor","getLine","setLine","getOctave","setOctave","getSymbol","setSymbol","MusicDocument","MusicXMLResultElement","MusicScoreTreeResultElement","MusicScratchOut","MusicDots","MusicHead","MusicInputRange","MusicKeySignature","accidentals","signature","MusicKeySignatureData","getSignature","getAccidentals","fifths","cancel","getFifths","getCancel","accidental","dots","head","pitch","MusicPitchData","startTie","MusicTie","stopTie","startTuplet","MusicTuplet","stopTuplet","timeModification","MusicTimeModificationData","getAccidental","getDots","getHead","getPitch","getStartTie","getStopTie","getStartTuplet","getStopTuplet","getTimeModification","MusicPart","elements","MusicRest","MusicTimeSignature","MusicTupletBracket","getElements","alteration","step","getAlteration","getStep","MusicResult","MusicScore","parts","getParts","score","getScore","erasedInputRanges","getErasedInputRanges","actual","normal","getActual","getNormal","bottom","getBottom","brackets","number","getNumber","getBrackets","AnalyzerElement","AnalyzerCell","AnalyzerCellData","firstColumn","lastColumn","firstRow","lastRow","topBorder","bottomBorder","leftBorder","rightBorder","getFirstColumn","getLastColumn","getFirstRow","getLastRow","hasTopBorder","hasBottomBorder","hasLeftBorder","hasRightBorder","AnalyzerDocument","textLines","shapes","tables","groups","AnalyzerTextLine","AnalyzerTable","AnalyzerGroup","getTextLines","getShapes","getTables","getGroups","AnalyzerElementReference","elementReferences","getElementReferences","AnalyzerInkRange","stroke","AnalyzerRecognizedStroke","getStroke","AnalyzerLine","AnalyzerLineData","p1","p2","getP1","getP2","AnalyzerResult","AnalyzerStrokeType","getInkRange","lines","cells","AnalyzerTableData","getLines","getCells","underlineList","AnalyzerTextLineData","AnalyzerUnderline","getTextDocument","getUnderlineList","baselinePos","toMidline","textHeight","justificationType","getBaselinePos","getToMidline","getTextHeight","getJustificationType","AnalyzerUnderlineData","firstCharacter","lastCharacter","getFirstCharacter","getLastCharacter","Q","NetworkInterface","parseURL","url","queries","parser","createElement","searchObject","href","search","replace","protocol","host","hostname","port","pathname","hash","parse","req","responseText","e","transformRequest","str","encodeURIComponent","join","xhr","Promise","resolve","reject","notify","onStateChange","request","readyState","status","onLoad","onError","onProgress","loaded","total","XMLHttpRequest","open","withCredentials","setRequestHeader","onerror","onprogress","onload","onreadystatechange","send","get","src","put","post","NetworkWSInterface","setUrl","_url","close","getUrl","setCallback","callback","_callback","getCallback","getState","_getWebSocketState","_socket","isClosed","isClosing","isOpen","isConnecting","_openWebSocket","code","reason","_closeWebSocket","state","_sendMessage","onOpen","onClose","onMessage","socket","WebSocket","onopen","onclose","onmessage","message","CryptoJS","AbstractRecognizer","getProtocol","setSSL","_ssl","getSSL","ssl","getHost","setHost","getPrecision","setPrecision","getAvailableLanguageList","then","response","doRestRecognition","hmacKey","_filterStrokes","_doTextRecognition","_doShapeRecognition","_doMathRecognition","_doMusicRecognition","_doAnalyzerRecognition","clearRestRecognition","instanceSessionId","_clearShapeRecognition","_fillData","_computeHmac","jsonInput","HmacSHA512","toString","enc","Hex","forEach","currentValue","AbstractWSRecognizer","_wsInterface","sendMessage","initWSRecognition","takeUpHmacChallenge","resetWSRecognition","TextRecognizer","doSimpleRecognition","unit","TextWSRecognizer","startWSRecognition","continueWSRecognition","ShapeRecognizer","clearShapeRecognitionSession","MathRecognizer","MathWSRecognizer","MusicRecognizer","AnalyzerRecognizer","AbstractRenderer","context","penParameters","showBoundingBoxes","typeset","_computeLinksPoints","radius","_computeMiddlePoint","point1","point2","_computeAxeAngle","begin","end","_fill","fillStyle","fill","_renderStroke","beginPath","arc","PI","_renderLine","nbquadratics","_renderQuadratic","_renderFinal","closePath","ARCSPLIT","linkPoints","moveTo","newAngle","lineTo","linkPoints1","linkPoints2","ctrl","linkPoints3","quadraticCurveTo","getContext","getShowBoundingBoxes","setShowBoundingBoxes","isTypesetting","setTypeset","clear","clearRect","canvas","drawRecognitionResult","recognitionResult","drawComponents","drawComponent","_drawStroke","_drawCharacter","TextRenderer","_drawTextComponent","_drawChar","_drawString","char","ShapeRenderer","drawShapes","lastComponents","processedComponents","_extractComponents","indexOf","_drawShapePrimitive","drawShapeSegment","segment","candidate","_drawShapeRecognized","drawShapeNotRecognized","drawShapePrimitive","primitive","shapeRecognized","_drawShapeEllipse","_drawShapeLine","shapeLine","_drawLine","_drawArrowHead","shapeEllipse","points","_drawEllipseArc","centerPoint","floor","boundariesPoints","save","strokeStyle","lineWidth","restore","_phi","headPoint","beta","firstPointIndex","lastPointIndex","ceil","strokeIndex","currentStroke","currentStrokePointCount","newStroke","pointIndex","MathRenderer","notScratchOutComponents","_filterScratchOut","scratchedStroke","MusicRenderer","_removeMusicScratchOut","drawStaff","_drawStaff","_drawMusicNode","staffHeight","staves","offset","clientWidth","_drawAccidental","_drawArpeggiate","_drawBar","_drawBeam","_drawClef","_drawDecoration","_drawDots","_drawHead","_drawLedgerLine","_drawRest","_drawStem","_drawTieOrSlur","_drawTimeSignature","bar","beam","clef","imageObj","Image","drawImage","ledgerLine","rest","tieOrSlur","timeSignature","cloneComponents","componentsToRemove","z","splice","AnalyzerRenderer","shapeRenderer","getShapeRenderer","setShapeRenderer","_drawTables","_drawTextLines","textLine","text","_drawText","underlines","_drawUnderline","baseline","textAlign","fillText","underline","topLeft","textMetrics","measureText","substring","x1","x2","ImageRenderer","console","log","InkGrabber","writing","isWriting","startCapture","continueCapture","endCapture","InkPaper","element","options","_element","_instanceId","_timerId","_initialized","_lastSentComponentIndex","_components","_redoComponents","isStarted","resultCallback","changeCallback","tempCanvas","_createCanvas","canvasRatio","_getCanvasRatio","removeChild","_captureCanvas","_inkGrabber","_renderingCanvas","_textRenderer","_mathRenderer","_shapeRenderer","_musicRenderer","_analyzerRenderer","_textRecognizer","_mathRecognizer","_shapeRecognizer","_musicRecognizer","_analyzerRecognizer","_textWSRecognizer","_handleMessage","_mathWSRecognizer","_attachListeners","timeout","textParameters","mathParameters","shapeParameters","musicParameters","analyzerParameters","idx","setMathParameters","setShapeParameters","setMusicParameters","setAnalyzerParameters","setProtocol","setTimeout","setHmacKey","setPenParameters","parent","id","querySelectorAll","appendChild","devicePixelRatio","backingStoreRatio","webkitBackingStorePixelRatio","mozBackingStorePixelRatio","msBackingStorePixelRatio","oBackingStorePixelRatio","backingStorePixelRatio","_getCoordinates","container","changedTouches","rect","getBoundingClientRect","clientX","left","clientLeft","clientY","clientTop","timeStamp","scale","_initRenderingCanvas","_selectedRecognizer","_selectedRESTRecognizer","_selectedWSRecognizer","_selectedRenderer","getTimeout","getHmacKey","getMathParameters","getShapeParameters","getMusicParameters","getAnalyzerParameters","getPenParameters","getAvailableLanguages","_onResult","getRenderer","getInkGrabber","getRecognizer","setChangeCallback","setResultCallback","recognize","lastInput","_renderResult","_continueRESTRecognition","_startRESTRecognition","_clearRESTRecognition","canUndo","undo","updatedModel","pop","_onChange","clearTimeout","canRedo","redo","addDomListener","useCapture","myfunction","addEventListener","_down","sizeChanged","clientHeight","_move","_up","err","dispatchEvent","undoLength","redoLength","pointerId","self","preventDefault","stopPropagation","coord","replayNeeded","getStats","stats","strokesCount","pointsCount","byteSize","humanSize","humanUnit","strokeNb","getInkAsImageData","marginX","marginY","componentCopy","minX","maxX","minY","maxY","pointCount","pointNb","currentX","currentY","nonDisplayCanvas","ctx","imageRendered","getImageData","getInkAsPng","imageRenderingCanvas","display","imageDataToRender","putImageData","toDataURL"],"mappings":"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","file":"myscript.min.js","sourcesContent":["/**\n * Polyfills\n */\n(function () {\n    /**\n     * CustomEvent\n     */\n    function CustomEvent ( event, params ) {    // jshint ignore:line\n        params = params || { bubbles: false, cancelable: false, detail: undefined };\n        var evt = document.createEvent( 'CustomEvent' );\n        evt.initCustomEvent( event, params.bubbles, params.cancelable, params.detail );\n        return evt;\n    }\n\n    CustomEvent.prototype = window.Event.prototype;\n\n    window.CustomEvent = CustomEvent;\n\n    /**\n     * bind()\n     */\n    if (!Function.prototype.bind) {\n        Function.prototype.bind = function(oThis) {\n            if (typeof this !== 'function') {\n                // closest thing possible to the ECMAScript 5\n                // internal IsCallable function\n                throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable');\n            }\n\n            var aArgs   = Array.prototype.slice.call(arguments, 1),\n                fToBind = this,\n                fNOP    = function() {},\n                fBound  = function() {\n                    return fToBind.apply(this instanceof fNOP ? this : oThis,\n                        aArgs.concat(Array.prototype.slice.call(arguments)));\n                };\n\n            fNOP.prototype = this.prototype;\n            fBound.prototype = new fNOP(); // jshint ignore:line\n\n            return fBound;\n        };\n    }\n})();\n\n/**\n * MyScript javascript library\n *\n * @module MyScript\n * @requires Q\n * @requires CryptoJS\n */\n/*global MyScript:true */\nMyScript = {\n    RecognitionType: {\n        TEXT: 'TEXT',\n        MATH: 'MATH',\n        SHAPE: 'SHAPE',\n        MUSIC: 'MUSIC',\n        ANALYZER: 'ANALYZER'\n    },\n    InputMode: {\n        CURSIVE: 'CURSIVE',\n        ISOLATED: 'ISOLATED',\n        SUPERIMPOSED: 'SUPERIMPOSED',\n        VERTICAL: 'VERTICAL'\n    },\n    InputType: {\n        CHAR: 'CHAR',\n        WORD: 'WORD',\n        SINGLE_LINE_TEXT: 'SINGLE_LINE_TEXT',\n        MULTI_LINE_TEXT: 'MULTI_LINE_TEXT'\n    },\n    ResultDetail: {\n        TEXT: 'TEXT',\n        WORD: 'WORD',\n        CHARACTER: 'CHARACTER'\n    },\n    ResultType: {\n        Math: {\n            LATEX: 'LATEX',\n            MATHML: 'MATHML',\n            SYMBOLTREE: 'SYMBOLTREE',\n            OFFICEOPENXMLMATH : 'OFFICEOPENXMLMATH'\n        },\n        Music: {\n            MUSICXML: 'MUSICXML',\n            SCORETREE: 'SCORETREE'\n        }\n    },\n    Protocol: {\n        WS: 'WebSocket',\n        REST: 'REST'\n    }\n};\n\n\n\n(function (scope) {\n    /**\n     * Point\n     *\n     * @class Point\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function Point(obj) {\n        if (obj) {\n            this.x = obj.x;\n            this.y = obj.y;\n        }\n    }\n\n    /**\n     * Get x\n     *\n     * @method getX\n     * @returns {Number}\n     */\n    Point.prototype.getX = function () {\n        return this.x;\n    };\n\n    /**\n     * Set x\n     *\n     * @method setX\n     * @param {Number} x\n     */\n    Point.prototype.setX = function (x) {\n        this.x = x;\n    };\n\n    /**\n     * Get y\n     *\n     * @method getY\n     * @returns {Number}\n     */\n    Point.prototype.getY = function () {\n        return this.y;\n    };\n\n    /**\n     * Set y\n     *\n     * @method setY\n     * @param {Number} y\n     */\n    Point.prototype.setY = function (y) {\n        this.y = y;\n    };\n\n    // Export\n    scope.Point = Point;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Rectangle\n     *\n     * @class Rectangle\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function Rectangle(obj) {\n        if (obj) {\n            this.x = obj.x;\n            this.y = obj.y;\n            this.width = obj.width;\n            this.height = obj.height;\n        }\n    }\n\n    /**\n     * Get top-left x\n     *\n     * @method getX\n     * @returns {Number}\n     */\n    Rectangle.prototype.getX = function () {\n        return this.x;\n    };\n\n    /**\n     * Set top-left x\n     *\n     * @method setX\n     * @param {Number} x\n     */\n    Rectangle.prototype.setX = function (x) {\n        this.x = x;\n    };\n\n    /**\n     * Get top-left y\n     *\n     * @method getY\n     * @returns {Number}\n     */\n    Rectangle.prototype.getY = function () {\n        return this.y;\n    };\n\n    /**\n     * Set top-left y\n     *\n     * @method setY\n     * @param {Number} y\n     */\n    Rectangle.prototype.setY = function (y) {\n        this.y = y;\n    };\n\n    /**\n     * Get top-left point\n     *\n     * @method getTopLeftPoint\n     * @returns {Point}\n     */\n    Rectangle.prototype.getTopLeftPoint = function () {\n        var point = new scope.Point();\n        point.setX(this.x);\n        point.setY(this.y);\n        return point;\n    };\n\n    /**\n     * Set top-left point\n     *\n     * @method setTopLeftPoint\n     * @param {Point} topLeftPoint\n     */\n    Rectangle.prototype.setTopLeftPoint = function (topLeftPoint) {\n        this.x = topLeftPoint.getX();\n        this.y = topLeftPoint.getY();\n    };\n\n    /**\n     * Get width\n     *\n     * @method getWidth\n     * @returns {Number}\n     */\n    Rectangle.prototype.getWidth = function () {\n        return this.width;\n    };\n\n    /**\n     * Set width\n     *\n     * @method setWidth\n     * @param {Number} width\n     */\n    Rectangle.prototype.setWidth = function (width) {\n        this.width = width;\n    };\n\n    /**\n     * Get height\n     *\n     * @method getHeight\n     * @returns {Number}\n     */\n    Rectangle.prototype.getHeight = function () {\n        return this.height;\n    };\n\n    /**\n     * Set height\n     *\n     * @method setHeight\n     * @param {Number} height\n     */\n    Rectangle.prototype.setHeight = function (height) {\n        this.height = height;\n    };\n\n    // Export\n    scope.Rectangle = Rectangle;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Parameters used for both input and output canvas draw.\n     *\n     * @class PenParameters\n     * @constructor\n     */\n    function PenParameters(obj) {\n        this.color = 'rgba(0, 0, 0, 0.9)';\n        this.rectColor = 'rgba(0, 0, 0, 0.2)';\n        this.font = 'Times New Roman';\n        this.decoration = 'normal';\n        this.width = 4;\n        this.pressureType = 'SIMULATED';\n        this.alpha = '1.0';\n        if (obj) {\n            this.color = obj.color;\n            this.rectColor = obj.rectColor;\n            this.font = obj.font;\n            this.decoration = obj.decoration;\n            this.width = obj.width;\n            this.pressureType = obj.pressureType;\n            this.alpha = obj.alpha;\n        }\n    }\n\n    /**\n     * Get the color renderer parameter\n     *\n     * @method getColor\n     * @returns {String} The color of the ink\n     */\n    PenParameters.prototype.getColor = function () {\n        return this.color;\n    };\n\n    /**\n     * Set the color renderer parameter\n     *\n     * @method setColor\n     * @param {String} color\n     */\n    PenParameters.prototype.setColor = function (color) {\n        this.color = color;\n    };\n\n    /**\n     * Get the rect renderer parameter\n     *\n     * @method getRectColor\n     * @returns {String} the rectangle color\n     */\n    PenParameters.prototype.getRectColor = function () {\n        return this.rectColor;\n    };\n\n    /**\n     * Set the rect renderer parameter\n     *\n     * @method setRectColor\n     * @param {String} rectColor\n     */\n    PenParameters.prototype.setRectColor = function (rectColor) {\n        this.rectColor = rectColor;\n    };\n\n    /**\n     * Get the font renderer parameter\n     *\n     * @method getFont\n     * @returns {String} The font\n     */\n    PenParameters.prototype.getFont = function () {\n        return this.font;\n    };\n\n    /**\n     * Set the font renderer parameter\n     *\n     * @method setFont\n     * @param {String} font\n     */\n    PenParameters.prototype.setFont = function (font) {\n        this.font = font;\n    };\n\n    /**\n     * Get the decoration renderer parameter\n     *\n     * @method getDecoration\n     * @returns {String} The decoration\n     */\n    PenParameters.prototype.getDecoration = function () {\n        return this.decoration;\n    };\n\n    /**\n     * Set the decoration renderer parameter\n     *\n     * @method setDecoration\n     * @param {String} decoration\n     */\n    PenParameters.prototype.setDecoration = function (decoration) {\n        this.decoration = decoration;\n    };\n\n    /**\n     * Get the width renderer parameter\n     *\n     * @method getWidth\n     * @returns {Number} The ink width\n     */\n    PenParameters.prototype.getWidth = function () {\n        return this.width;\n    };\n\n    /**\n     * Set the width renderer parameter\n     *\n     * @method setWidth\n     * @param {Number} width\n     */\n    PenParameters.prototype.setWidth = function (width) {\n        this.width = width;\n    };\n\n    // Export\n    scope.PenParameters = PenParameters;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * The mathUtil class is use to calculate lines\n     *\n     * @class MathUtil\n     * @constructor\n     */\n    function MathUtils() {\n    }\n\n    /**\n     * This method is use to calculate the size of the rectangle that contains an ellipse arc.\n     *\n     * @method getEllipseArcRect\n     * @param {Point} center\n     * @param {Number} maxRadius\n     * @param {Number} minRadius\n     * @param {Number} orientation\n     * @param {Number} startAngle\n     * @param {Number} sweepAngle\n     * @returns {Rectangle}\n     */\n    MathUtils.getEllipseArcRect = function (center, maxRadius, minRadius, orientation, startAngle, sweepAngle) {\n\n        var angleStep = 0.02, // angle delta between interpolated points on the arc, in radian\n            angle, // angle\n            alpha, // angle\n            z1,\n            z2,\n            z3,\n            z4,\n            cosAlpha,\n            sinAlpha,\n            n,\n            xList,\n            yList,\n            i,\n            x,\n            y,\n            xMin,\n            xMax,\n            yMin,\n            yMax,\n            sortFloat = function (a, b) {\n                return a - b;\n            };\n\n        z1 = z2 = Math.cos(orientation);\n        z3 = z4 = Math.sin(orientation);\n        z1 *= maxRadius;\n        z2 *= minRadius;\n        z3 *= maxRadius;\n        z4 *= minRadius;\n\n        n = Math.abs(sweepAngle) / angleStep;\n\n        xList = [];\n        yList = [];\n\n        for (i = 0; i <= n; i++) {\n\n            angle = startAngle + (i / n) * sweepAngle;\n            alpha = Math.atan2(Math.sin(angle) / minRadius, Math.cos(angle) / maxRadius);\n\n            cosAlpha = Math.cos(alpha);\n            sinAlpha = Math.sin(alpha);\n\n            // current point\n            x = center.x + z1 * cosAlpha - z4 * sinAlpha;\n            y = center.y + z2 * sinAlpha + z3 * cosAlpha;\n\n            xList.push(x);\n            yList.push(y);\n        }\n\n        xList.sort(sortFloat);\n        yList.sort(sortFloat);\n\n        xMin = xList[0];\n        xMax = xList[xList.length - 1];\n        yMin = yList[0];\n        yMax = yList[yList.length - 1];\n\n        return new scope.Rectangle({x: xMin, y: yMin, width: xMax - xMin, height: yMax - yMin});\n    };\n\n    /**\n     * This method is use to calculate the size of the rectangle that contains a line.\n     *\n     * @method getLineRect\n     * @param {Point} firstPoint\n     * @param {Point} lastPoint\n     * @returns {Rectangle}\n     */\n    MathUtils.getLineRect = function (firstPoint, lastPoint) {\n\n        var xFirst = firstPoint.x,\n            xLast = lastPoint.x,\n            xMin = Math.min(xFirst, xLast),\n            xMax = Math.max(xFirst, xLast),\n\n            yFirst = firstPoint.y,\n            yLast = lastPoint.y,\n            yMin = Math.min(yFirst, yLast),\n            yMax = Math.max(yFirst, yLast);\n\n        return new scope.Rectangle({x: xMin, y: yMin, width: xMax - xMin, height: yMax - yMin});\n    };\n\n    /**\n     * This method is use to calculate the size of the rectangle that contains bounding boxes.\n     *\n     * @method getBoundingRect\n     * @param {Rectangle[]} boundingBoxes List of bounding box\n     * @returns {Rectangle}\n     */\n    MathUtils.getBoundingRect = function (boundingBoxes) {\n\n        var xList = [],\n            yList = [];\n\n        for (var i in boundingBoxes) {\n            var rectangle = boundingBoxes[i];\n            xList.push(rectangle.getX());\n            xList.push(rectangle.getX() + rectangle.getWidth());\n            yList.push(rectangle.getY());\n            yList.push(rectangle.getY() + rectangle.getHeight());\n        }\n\n        var xMin = Math.min.apply(Math, xList);\n        var xMax = Math.max.apply(Math, xList);\n        var yMin = Math.min.apply(Math, yList);\n        var yMax = Math.max.apply(Math, yList);\n\n        return new scope.Rectangle({x: xMin, y: yMin, width: xMax - xMin, height: yMax - yMin});\n    };\n\n    // Export\n    scope.MathUtils = MathUtils;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * Abstract WebSocket recognition message\n     *\n     * @class AbstractWSMessage\n     * @param {Object} [obj] Recognition WebSocket message\n     * @constructor\n     */\n    function AbstractWSMessage(obj) {\n        if (obj) {\n            this.type = obj.type;\n        }\n    }\n\n    /**\n     * Get the message type\n     *\n     * @method getType\n     * @returns {String}\n     */\n    AbstractWSMessage.prototype.getType = function () {\n        return this.type;\n    };\n\n    // Export\n    scope.AbstractWSMessage = AbstractWSMessage;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Represent an abstract input component\n     *\n     * @class AbstractComponent\n     * @constructor\n     */\n    function AbstractComponent() {\n    }\n\n    /**\n     * Get the type of the input component\n     *\n     * @method getType\n     * @returns {String}\n     */\n    AbstractComponent.prototype.getType = function () {\n        return this.type;\n    };\n\n    /**\n     * Set the type of the input component\n     *\n     * @method setType\n     * @param {String} type\n     */\n    AbstractComponent.prototype.setType = function (type) {\n        this.type = type;\n    };\n\n    /**\n     * Get input component bounding-box\n     *\n     * @method getBoundingBox\n     * @returns {Rectangle}\n     */\n    AbstractComponent.prototype.getBoundingBox = function () {\n        throw new Error('not implemented');\n    };\n\n    /**\n     * Set input component bounding-box\n     *\n     * @method setBoundingBox\n     * @param {Rectangle} boundingBox\n     */\n    AbstractComponent.prototype.setBoundingBox = function (boundingBox) { // jshint ignore:line\n        throw new Error('not implemented');\n    };\n\n    // Export\n    scope.AbstractComponent = AbstractComponent;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Represent a simple StrokeComponent input component\n     *\n     * @class StrokeComponent\n     * @extends AbstractComponent\n     * @constructor\n     */\n    function StrokeComponent(obj) {\n        scope.AbstractComponent.call(this);\n        this.type = 'stroke';\n        this.x = [];\n        this.y = [];\n        this.t = [];\n        this.p = [];\n        this.d = [];\n        this.l = [];\n        this.color = undefined;\n        this.alpha = undefined;\n        this.width = 0;\n        if (obj) {\n            if (obj.x) {\n                this.x = obj.x;\n            }\n            if (obj.y) {\n                this.y = obj.y;\n            }\n            if (obj.t) {\n                this.t = obj.t;\n            }\n            if (obj.p) {\n                this.p = obj.p;\n            }\n            if (obj.d) {\n                this.d = obj.d;\n            }\n            if (obj.l) {\n                this.l = obj.l;\n            }\n            if (obj.color) {\n                this.color = obj.color;\n            }\n            if (obj.alpha) {\n                this.alpha = obj.alpha;\n            }\n            if (obj.width) {\n                this.width = obj.width;\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    StrokeComponent.prototype = new scope.AbstractComponent();\n\n    /**\n     * Constructor property\n     */\n    StrokeComponent.prototype.constructor = StrokeComponent;\n\n    /**\n     * @method toJSON\n     * @returns {Object}\n     */\n    StrokeComponent.prototype.toJSON = function () {\n        return {type: this.type, x: this.x, y: this.y, t: this.t};\n    };\n\n    /**\n     * Get the list of x coordinates\n     *\n     * @method getX\n     * @returns {Number[]}\n     */\n    StrokeComponent.prototype.getX = function () {\n        return this.x;\n    };\n\n    /**\n     * Set the list of x coordinates\n     *\n     * @method setX\n     * @param {Number[]} x\n     */\n    StrokeComponent.prototype.setX = function (x) {\n        this.x = x;\n    };\n\n    /**\n     * Add a x to the list of x coordinates\n     *\n     * @method addX\n     * @param {Number} x\n     */\n    StrokeComponent.prototype.addX = function (x) {\n        if ((x !== null) && (x !== undefined)) {\n            this.x.push(x);\n        }\n    };\n\n    /**\n     * Get the list of y coordinates\n     *\n     * @method getY\n     * @returns {Number[]}\n     */\n    StrokeComponent.prototype.getY = function () {\n        return this.y;\n    };\n\n    /**\n     * Set the list of y coordinates\n     *\n     * @method setY\n     * @param {Number[]} y\n     */\n    StrokeComponent.prototype.setY = function (y) {\n        this.y = y;\n    };\n\n    /**\n     * Add a y to the list of y coordinates\n     *\n     * @method addY\n     * @param {Number} y\n     */\n    StrokeComponent.prototype.addY = function (y) {\n        if ((y !== null) && (y !== undefined)) {\n            this.y.push(y);\n        }\n    };\n\n    /**\n     * Get the list of timestamps\n     *\n     * @method getT\n     * @returns {Number[]}\n     */\n    StrokeComponent.prototype.getT = function () {\n        return this.t;\n    };\n\n    /**\n     * Set the list of timestamps\n     *\n     * @method setT\n     * @param {Number[]} t\n     */\n    StrokeComponent.prototype.setT = function (t) {\n        this.t = t;\n    };\n\n    /**\n     * Add a timestamp to the list\n     *\n     * @method addT\n     * @param {Number} t\n     */\n    StrokeComponent.prototype.addT = function (t) {\n        if ((t !== null) && (t !== undefined)) {\n            this.t.push(t);\n        }\n    };\n\n    StrokeComponent.prototype.getLength = function () {\n        return this.x.length;\n    };\n\n    /**\n     * Get the boundingBox\n     *\n     * @method getBoundingBox\n     * @returns {Rectangle}\n     */\n    StrokeComponent.prototype.getBoundingBox = function () {\n        var boundingBox = new scope.Rectangle();\n        boundingBox.setX(Math.min.apply(Math, this.getX()));\n        boundingBox.setY(Math.min.apply(Math, this.getY()));\n        boundingBox.setWidth(Math.max.apply(Math, this.getX()) - boundingBox.getX());\n        boundingBox.setHeight(Math.max.apply(Math, this.getY()) - boundingBox.getY());\n        return boundingBox;\n    };\n\n    StrokeComponent.prototype.toFixed = function (precision) {\n        if (precision !== undefined) {\n            for (var i in this.x) {\n                this.x[i] = this.x[i].toFixed(precision);\n                this.y[i] = this.y[i].toFixed(precision);\n            }\n        }\n    };\n\n    StrokeComponent.prototype.getP = function () {\n        return this.p;\n    };\n\n    StrokeComponent.prototype.setP = function (p) {\n        this.p = p;\n    };\n\n    StrokeComponent.prototype.addP = function (p) {\n        if ((p !== null) && (p !== undefined)) {\n            this.p.push(p);\n        }\n    };\n\n    StrokeComponent.prototype.getD = function () {\n        return this.d;\n    };\n\n    StrokeComponent.prototype.setD = function (d) {\n        this.d = d;\n    };\n\n    StrokeComponent.prototype.addD = function (d) {\n        if ((d !== null) && (d !== undefined)) {\n            this.d.push(d);\n        }\n    };\n\n    StrokeComponent.prototype.getL = function () {\n        return this.l;\n    };\n\n    StrokeComponent.prototype.setL = function (l) {\n        this.l = l;\n    };\n\n    StrokeComponent.prototype.addL = function (l) {\n        if ((l !== null) && (l !== undefined)) {\n            this.l.push(l);\n        }\n    };\n\n    StrokeComponent.prototype.getColor = function () {\n        return this.color;\n    };\n\n    StrokeComponent.prototype.setColor = function (color) {\n        this.color = color;\n    };\n\n    StrokeComponent.prototype.getWidth = function () {\n        return this.width;\n    };\n\n    StrokeComponent.prototype.setWidth = function (width) {\n        this.width = width;\n    };\n\n    StrokeComponent.prototype.addPoint = function (x, y, t) {\n        if (_filterPointByAcquisitionDelta(x, y, this.getX(), this.getY(), this.getLastIndexPoint(), this.getWidth(), this.getLength())) {\n            this.addX(x);\n            this.addY(y);\n            this.addT(t);\n            this.addP(_computePressure(x, y, this.getX(), this.getY(), this.getL(), this.getLastIndexPoint()));\n            this.addD(_computeDistance(x, y, this.getX(), this.getY(), this.getLastIndexPoint()));\n            this.addL(_computeLength(x, y, this.getX(), this.getY(), this.getL(), this.getLastIndexPoint()));\n        }\n    };\n\n    StrokeComponent.prototype.getLastIndexPoint = function () {\n        return this.x.length - 1;\n    };\n\n    StrokeComponent.prototype.getPointByIndex = function (index) {\n        var point;\n        if (index !== undefined && index >= 0 && index < this.getLength()) {\n            point = {\n                x: this.getX()[index],\n                y: this.getY()[index],\n                t: this.getT()[index],\n                p: this.getP()[index],\n                d: this.getD()[index],\n                l: this.getL()[index]\n            };\n        }\n        return point;\n    };\n\n    function _computeDistance(x, y, xArray, yArray, lastIndexPoint) {\n        var distance = Math.sqrt(Math.pow((y - yArray[lastIndexPoint - 1]), 2) + Math.pow((x - xArray[lastIndexPoint - 1]), 2));\n\n        if (isNaN(distance)) {\n            distance = 0;\n        }\n\n        return distance;\n    }\n\n    function _computeLength(x, y, xArray, yArray, lArray, lastIndexPoint) {\n        var length = lArray[lastIndexPoint - 1] + _computeDistance(x, y, xArray, yArray, lastIndexPoint);\n\n        if (isNaN(length)) {\n            length = 0;\n        }\n\n        return length;\n    }\n\n    function _computePressure(x, y, xArray, yArray, lArray, lastIndexPoint) {\n        var ratio = 1.0;\n        var distance = _computeDistance(x, y, xArray, yArray, lastIndexPoint);\n        var length = _computeLength(x, y, xArray, yArray, lArray, lastIndexPoint);\n\n        if(length === 0) {\n            ratio = 0.5;\n        } else if(distance == length){\n            ratio = 1.0;\n        } else  if (distance < 10) {\n            ratio = 0.2 + Math.pow(0.1 * distance, 0.4);\n        } else if (distance > length - 10) {\n            ratio = 0.2 + Math.pow(0.1 * (length - distance), 0.4);\n        }\n        var pressure = ratio * Math.max(0.1, 1.0 - 0.1 * Math.sqrt(distance));\n        if (isNaN(parseFloat(pressure))) {\n            pressure = 0.5;\n        }\n        return pressure;\n    }\n\n    function _filterPointByAcquisitionDelta(x, y, xArray, yArray, lastIndexPoint, width, length) {\n        var delta = (2 + (width / 4));\n        var ret = false;\n        if (length === 0 || Math.abs(xArray[lastIndexPoint] - x) >= delta || Math.abs(yArray[lastIndexPoint] - y) >= delta) {\n            ret = true;\n        }\n        return ret;\n    }\n\n    // Export\n    scope.StrokeComponent = StrokeComponent;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * Char input component\n     *\n     * @class CharacterInputComponent\n     * @extends AbstractComponent\n     * @constructor\n     */\n    function CharacterInputComponent(obj) {\n        scope.AbstractComponent.call(this);\n        this.type = 'inputCharacter';\n        this.alternates = [];\n        if (obj) {\n            if (obj.alternates) {\n                for (var i in obj.alternates) {\n                    this.alternates.push(new scope.CharacterInputComponentAlternate(obj.alternates[i]));\n                }\n            }\n            if (obj.boundingBox) {\n                this.boundingBox = new scope.Rectangle(obj.boundingBox);\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    CharacterInputComponent.prototype = new scope.AbstractComponent();\n\n    /**\n     * Constructor property\n     */\n    CharacterInputComponent.prototype.constructor = CharacterInputComponent;\n\n    /**\n     * Get character input alternates\n     *\n     * @method getAlternates\n     * @returns {CharacterInputComponentAlternate[]}\n     */\n    CharacterInputComponent.prototype.getAlternates = function () {\n        return this.alternates;\n    };\n\n    /**\n     * Set character input alternates\n     *\n     * @method setAlternates\n     * @param {CharacterInputComponentAlternate[]} alternates\n     */\n    CharacterInputComponent.prototype.setAlternates = function (alternates) {\n        this.alternates = alternates;\n    };\n\n    /**\n     * Add a character input alternate\n     *\n     * @method addAlternate\n     * @param {CharacterInputComponent} alternate\n     */\n    CharacterInputComponent.prototype.addAlternate = function (alternate) {\n        this.alternates.push(alternate);\n    };\n\n    /**\n     * Get input component bounding-box\n     *\n     * @method getBoundingBox\n     * @returns {Rectangle}\n     */\n    CharacterInputComponent.prototype.getBoundingBox = function () {\n        return this.boundingBox;\n    };\n\n    /**\n     * Set input component bounding-box\n     *\n     * @method setBoundingBox\n     * @param {Rectangle} boundingBox\n     */\n    CharacterInputComponent.prototype.setBoundingBox = function (boundingBox) {\n        this.boundingBox = boundingBox;\n    };\n\n    // Export\n    scope.CharacterInputComponent = CharacterInputComponent;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * Character input component alternate\n     *\n     * @class CharacterInputComponentAlternate\n     * @constructor\n     */\n    function CharacterInputComponentAlternate(obj) {\n        if (obj) {\n            if (obj.alternate) {\n                this.alternate = obj.alternate;\n            }\n            if (obj.probability) {\n                this.probability = obj.probability;\n            }\n        }\n    }\n\n    /**\n     * Get alternate\n     *\n     * @method getAlternate\n     * @returns {String}\n     */\n    CharacterInputComponentAlternate.prototype.getAlternate = function () {\n        return this.alternate;\n    };\n\n    /**\n     * Set alternate\n     *\n     * @method setAlternate\n     * @param {String} alternate\n     */\n    CharacterInputComponentAlternate.prototype.setAlternate = function (alternate) {\n        this.alternate = alternate;\n    };\n\n    /**\n     * Get probability\n     *\n     * @method getProbability\n     * @returns {Number}\n     */\n    CharacterInputComponentAlternate.prototype.getProbability = function () {\n        return this.probability;\n    };\n\n    /**\n     * Set probability\n     *\n     * @method setProbability\n     * @param {Number} probability\n     */\n    CharacterInputComponentAlternate.prototype.setProbability = function (probability) {\n        this.probability = probability;\n    };\n\n    // Export\n    scope.CharacterInputComponentAlternate = CharacterInputComponentAlternate;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * Abstract parameters used for recognition\n     *\n     * @class AbstractParameter\n     * @constructor\n     */\n    function AbstractParameter() {\n    }\n\n    // Export\n    scope.AbstractParameter = AbstractParameter;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Abstraction of recognizer input\n     *\n     * @class AbstractRecognitionInput\n     * @constructor\n     */\n    function AbstractRecognitionInput() {\n    }\n\n    // Export\n    scope.AbstractRecognitionInput = AbstractRecognitionInput;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Abstract input recognition data\n     *\n     * @class AbstractRecognitionData\n     * @constructor\n     */\n    function AbstractRecognitionData() {\n    }\n\n    /**\n     * Get the application key\n     *\n     * @method getApplicationKey\n     * @returns {String}\n     */\n    AbstractRecognitionData.prototype.getApplicationKey = function () {\n        return this.applicationKey;\n    };\n\n    /**\n     * Set the application key\n     *\n     * @method setApplicationKey\n     * @param {String} applicationKey\n     */\n    AbstractRecognitionData.prototype.setApplicationKey = function (applicationKey) {\n        this.applicationKey = applicationKey;\n    };\n\n    /**\n     * Get the instanceId\n     *\n     * @method getInstanceId\n     * @returns {String}\n     */\n    AbstractRecognitionData.prototype.getInstanceId = function () {\n        return this.instanceId;\n    };\n\n    /**\n     * Set the instanceId\n     *\n     * @method setInstanceId\n     * @param {String} instanceId\n     */\n    AbstractRecognitionData.prototype.setInstanceId = function (instanceId) {\n        this.instanceId = instanceId;\n    };\n\n    /**\n     * @returns {string}\n     */\n    AbstractRecognitionData.prototype.getHmac = function () {\n        return this.hmac;\n    };\n\n    /**\n     * @param {string} hmac\n     */\n    AbstractRecognitionData.prototype.setHmac = function (hmac) {\n        this.hmac = hmac;\n    };\n\n    /**\n     * Get recognition input\n     *\n     * @method getRecognitionInput\n     * @returns {AbstractRecognitionInput} input\n     */\n    AbstractRecognitionData.prototype.getRecognitionInput = function () {\n        throw new Error('not implemented');\n    };\n\n    /**\n     * Set text input\n     *\n     * @method setRecognitionInput\n     * @param {AbstractRecognitionInput} input\n     */\n    AbstractRecognitionData.prototype.setRecognitionInput = function (input) { // jshint ignore:line\n        throw new Error('not implemented');\n    };\n\n    // Export\n    scope.AbstractRecognitionData = AbstractRecognitionData;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * List of languages recognition input\n     *\n     * @class RecognitionLanguagesData\n     * @extends AbstractRecognitionData\n     * @constructor\n     */\n    function RecognitionLanguagesData() {\n    }\n\n    /**\n     * Inheritance property\n     */\n    RecognitionLanguagesData.prototype = new scope.AbstractRecognitionData();\n\n    /**\n     * Constructor property\n     */\n    RecognitionLanguagesData.prototype.constructor = RecognitionLanguagesData;\n\n    /**\n     * Get the recognition input mode\n     *\n     * @method getInputMode\n     * @returns {String} inputMode\n     */\n    RecognitionLanguagesData.prototype.getInputMode = function () {\n        return this.inputMode;\n    };\n\n    /**\n     * Set the recognition input mode\n     *\n     * @method setInputMode\n     * @param {String} inputMode\n     */\n    RecognitionLanguagesData.prototype.setInputMode = function (inputMode) {\n        this.inputMode = inputMode;\n    };\n\n    // Export\n    scope.RecognitionLanguagesData = RecognitionLanguagesData;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * WebSocket start math recognition message\n     *\n     * @class AbstractStartRequestWSMessage\n     * @extends AbstractWSMessage\n     * @param {Object} [obj] Recognition WebSocket message\n     * @constructor\n     */\n    function AbstractStartRequestWSMessage(obj) {\n        this.type = 'start';\n        scope.AbstractWSMessage.call(this, obj);\n    }\n\n    /**\n     * Inheritance property\n     */\n    AbstractStartRequestWSMessage.prototype = new scope.AbstractWSMessage();\n\n    /**\n     * Constructor property\n     */\n    AbstractStartRequestWSMessage.prototype.constructor = AbstractStartRequestWSMessage;\n\n    // Export\n    scope.AbstractStartRequestWSMessage = AbstractStartRequestWSMessage;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * WebSocket continue math recognition message\n     *\n     * @class AbstractContinueRequestWSMessage\n     * @extends AbstractWSMessage\n     * @param {Object} [obj] Recognition WebSocket message\n     * @constructor\n     */\n    function AbstractContinueRequestWSMessage(obj) {\n        this.type = 'continue';\n        scope.AbstractWSMessage.call(this, obj);\n    }\n\n    /**\n     * Inheritance property\n     */\n    AbstractContinueRequestWSMessage.prototype = new scope.AbstractWSMessage();\n\n    /**\n     * Constructor property\n     */\n    AbstractContinueRequestWSMessage.prototype.constructor = AbstractContinueRequestWSMessage;\n\n    /**\n     * Get instanceId\n     *\n     * @method getInstanceId\n     * @returns {String}\n     */\n    AbstractContinueRequestWSMessage.prototype.getInstanceId = function () {\n        return this.instanceId;\n    };\n\n    /**\n     * Set instanceId\n     *\n     * @method setInstanceId\n     * @param {String} instanceId\n     */\n    AbstractContinueRequestWSMessage.prototype.setInstanceId = function (instanceId) {\n        this.instanceId = instanceId;\n    };\n\n    // Export\n    scope.AbstractContinueRequestWSMessage = AbstractContinueRequestWSMessage;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * WebSocket recognition hmac challenge message\n     *\n     * @class ChallengeRequestWSMessage\n     * @extends AbstractWSMessage\n     * @param {Object} [obj] Recognition WebSocket message\n     * @constructor\n     */\n    function ChallengeRequestWSMessage(obj) {\n        this.type = 'hmac';\n        scope.AbstractWSMessage.call(this, obj);\n    }\n\n    /**\n     * Inheritance property\n     */\n    ChallengeRequestWSMessage.prototype = new scope.AbstractWSMessage();\n\n    /**\n     * Constructor property\n     */\n    ChallengeRequestWSMessage.prototype.constructor = ChallengeRequestWSMessage;\n\n    /**\n     * Get the challenge\n     *\n     * @method getChallenge\n     * @returns {String}\n     */\n    ChallengeRequestWSMessage.prototype.getChallenge = function () {\n        return this.challenge;\n    };\n\n    /**\n     * Set the challenge\n     *\n     * @method setChallenge\n     * @param {String} challenge\n     */\n    ChallengeRequestWSMessage.prototype.setChallenge = function (challenge) {\n        this.challenge = challenge;\n    };\n\n    /**\n     * Get the application key\n     *\n     * @method getApplicationKey\n     * @returns {String}\n     */\n    ChallengeRequestWSMessage.prototype.getApplicationKey = function () {\n        return this.applicationKey;\n    };\n\n    /**\n     * Set the application key\n     *\n     * @method setApplicationKey\n     * @param {String} applicationKey\n     */\n    ChallengeRequestWSMessage.prototype.setApplicationKey = function (applicationKey) {\n        this.applicationKey = applicationKey;\n    };\n\n    /**\n     * Get HMAC signature\n     *\n     * @method getHmacSignature\n     * @returns {String}\n     */\n    ChallengeRequestWSMessage.prototype.getHmacSignature = function () {\n        return this.hmac;\n    };\n\n    /**\n     * Set HMAC signature\n     *\n     * @method setHmacSignature\n     * @param {String} hmac\n     */\n    ChallengeRequestWSMessage.prototype.setHmacSignature = function (hmac) {\n        this.hmac = hmac;\n    };\n\n    // Export\n    scope.ChallengeRequestWSMessage = ChallengeRequestWSMessage;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * WebSocket recognition hmac challenge message\n     *\n     * @class InitRequestWSMessage\n     * @extends AbstractWSMessage\n     * @param {Object} [obj] Recognition WebSocket message\n     * @constructor\n     */\n    function InitRequestWSMessage(obj) {\n        this.type = 'applicationKey';\n        scope.AbstractWSMessage.call(this, obj);\n    }\n\n    /**\n     * Inheritance property\n     */\n    InitRequestWSMessage.prototype = new scope.AbstractWSMessage();\n\n    /**\n     * Constructor property\n     */\n    InitRequestWSMessage.prototype.constructor = InitRequestWSMessage;\n\n    /**\n     * Get the application key\n     *\n     * @method getApplicationKey\n     * @returns {String}\n     */\n    InitRequestWSMessage.prototype.getApplicationKey = function () {\n        return this.applicationKey;\n    };\n\n    /**\n     * Set the application key\n     *\n     * @method setApplicationKey\n     * @param {String} applicationKey\n     */\n    InitRequestWSMessage.prototype.setApplicationKey = function (applicationKey) {\n        this.applicationKey = applicationKey;\n    };\n\n    // Export\n    scope.InitRequestWSMessage = InitRequestWSMessage;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * WebSocket recognition hmac challenge message\n     *\n     * @class ResetRequestWSMessage\n     * @extends AbstractWSMessage\n     * @param {Object} [obj] Recognition WebSocket message\n     * @constructor\n     */\n    function ResetRequestWSMessage(obj) {\n        this.type = 'reset';\n        scope.AbstractWSMessage.call(this, obj);\n    }\n\n    /**\n     * Inheritance property\n     */\n    ResetRequestWSMessage.prototype = new scope.AbstractWSMessage();\n\n    /**\n     * Constructor property\n     */\n    ResetRequestWSMessage.prototype.constructor = ResetRequestWSMessage;\n\n    // Export\n    scope.ResetRequestWSMessage = ResetRequestWSMessage;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Abstract text input component\n     *\n     * @class AbstractTextInputComponent\n     * @extends AbstractComponent\n     * @constructor\n     */\n    function AbstractTextInputComponent(obj) {\n        scope.AbstractComponent.call(this);\n        if (obj) {\n            if (obj.boundingBox) {\n                this.boundingBox = new scope.Rectangle(obj.boundingBox);\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    AbstractTextInputComponent.prototype = new scope.AbstractComponent();\n\n    /**\n     * Constructor property\n     */\n    AbstractTextInputComponent.prototype.constructor = AbstractTextInputComponent;\n\n    /**\n     * Get input component bounding-box\n     *\n     * @method getBoundingBox\n     * @returns {Rectangle}\n     */\n    AbstractTextInputComponent.prototype.getBoundingBox = function () {\n        return this.boundingBox;\n    };\n\n    /**\n     * Set input component bounding-box\n     *\n     * @method setBoundingBox\n     * @param {Rectangle} boundingBox\n     */\n    AbstractTextInputComponent.prototype.setBoundingBox = function (boundingBox) {\n        this.boundingBox = boundingBox;\n    };\n\n    // Export\n    scope.AbstractTextInputComponent = AbstractTextInputComponent;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * Char input component\n     *\n     * @class CharInputComponent\n     * @extends AbstractTextInputComponent\n     * @constructor\n     */\n    function CharInputComponent(obj) {\n        scope.AbstractTextInputComponent.call(this, obj);\n        this.type = 'char';\n        if (obj) {\n            if (obj.character) {\n                this.character = obj.character;\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    CharInputComponent.prototype = new scope.AbstractTextInputComponent();\n\n    /**\n     * Constructor property\n     */\n    CharInputComponent.prototype.constructor = CharInputComponent;\n\n    /**\n     * Get label\n     *\n     * @method getLabel\n     * @returns {String}\n     */\n    CharInputComponent.prototype.getLabel = function () {\n        return this.character;\n    };\n\n    /**\n     * Set label\n     *\n     * @method setLabel\n     * @param {String} label\n     */\n    CharInputComponent.prototype.setLabel = function (label) {\n        this.character = label;\n    };\n\n    // Export\n    scope.CharInputComponent = CharInputComponent;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * String input component\n     *\n     * @class StringInputComponent\n     * @extends AbstractTextInputComponent\n     * @constructor\n     */\n    function StringInputComponent(obj) {\n        scope.AbstractTextInputComponent.call(this, obj);\n        this.type = 'string';\n        if (obj) {\n            if (obj.string) {\n                this.string = obj.string;\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    StringInputComponent.prototype = new scope.AbstractTextInputComponent();\n\n    /**\n     * Constructor property\n     */\n    StringInputComponent.prototype.constructor = StringInputComponent;\n\n    /**\n     * Get label\n     *\n     * @method getLabel\n     * @returns {String}\n     */\n    StringInputComponent.prototype.getLabel = function () {\n        return this.string;\n    };\n\n    /**\n     * Set label\n     *\n     * @method setLabel\n     * @param {String} label\n     */\n    StringInputComponent.prototype.setLabel = function (label) {\n        this.string = label;\n    };\n\n    // Export\n    scope.StringInputComponent = StringInputComponent;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * Input unit used for text recognition\n     *\n     * @class TextInputUnit\n     * @constructor\n     */\n    function TextInputUnit() {\n        this.textInputType = 'MULTI_LINE_TEXT';\n        this.components = [];\n    }\n\n    /**\n     * Get the input type\n     *\n     * @method getInputType\n     * @returns {String}\n     */\n    TextInputUnit.prototype.getInputType = function () {\n        return this.textInputType;\n    };\n\n    /**\n     * Set the input type\n     *\n     * @method setInputType\n     * @returns {String} inputType\n     */\n    TextInputUnit.prototype.setInputType = function (inputType) {\n        this.textInputType = inputType;\n    };\n\n    /**\n     * Get components for this input unit\n     *\n     * @method getComponents\n     * @param {TextInkRange} [inkRange]\n     * @returns {AbstractComponent[]}\n     */\n    TextInputUnit.prototype.getComponents = function (inkRange) {\n        if (inkRange && (inkRange instanceof scope.TextInkRange)) {\n            return this.components.slice(inkRange.getStartComponent(), inkRange.getEndComponent() + 1);\n        }\n        return this.components;\n    };\n\n    /**\n     * Set components for this input unit\n     *\n     * @method setComponents\n     * @param {AbstractComponent[]} components\n     */\n    TextInputUnit.prototype.setComponents = function (components) {\n        this.components = components;\n    };\n\n    // Export\n    scope.TextInputUnit = TextInputUnit;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Parameters used for text recognition\n     *\n     * @class TextParameter\n     * @extends AbstractParameter\n     * @constructor\n     */\n    function TextParameter(obj) {\n        scope.AbstractParameter.call(this, obj);\n        this.textProperties = new scope.TextProperties();\n        if (obj) {\n            if (obj.language) {\n                this.language = obj.language;\n            }\n            if (obj.textInputMode) {\n                this.textInputMode = obj.textInputMode;\n            }\n            if (obj.contentTypes) {\n                this.contentTypes = obj.contentTypes;\n            }\n            if (obj.subsetKnowledges) {\n                this.subsetKnowledges = obj.subsetKnowledges;\n            }\n            if (obj.userResources) {\n                this.userResources = obj.userResources;\n            }\n            if (obj.userLkWords) {\n                this.userLkWords = obj.userLkWords;\n            }\n            if (obj.resultDetail) {\n                this.resultDetail = obj.resultDetail;\n            }\n            if (obj.textProperties) {\n                this.textProperties = new scope.TextProperties(obj.textProperties);\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    TextParameter.prototype = new scope.AbstractParameter();\n\n    /**\n     * Constructor property\n     */\n    TextParameter.prototype.constructor = TextParameter;\n\n    /**\n     * Get recognition language\n     *\n     * @method getLanguage\n     * @returns {String}\n     */\n    TextParameter.prototype.getLanguage = function () {\n        return this.language;\n    };\n\n    /**\n     * Set recognition language\n     *\n     * @method getLanguage\n     * @param {String} language\n     */\n    TextParameter.prototype.setLanguage = function (language) {\n        this.language = language;\n    };\n\n    /**\n     * Get input mode\n     *\n     * @method getInputMode\n     * @returns {'CURSIVE'|'ISOLATED'|'SUPERIMPOSED'|'VERTICAL'}\n     */\n    TextParameter.prototype.getInputMode = function () {\n        return this.textInputMode;\n    };\n\n    /**\n     * Set input mode\n     *\n     * @method setInputMode\n     * @param {'CURSIVE'|'ISOLATED'|'SUPERIMPOSED'|'VERTICAL'} inputMode\n     */\n    TextParameter.prototype.setInputMode = function (inputMode) {\n        this.textInputMode = inputMode;\n    };\n\n    /**\n     * Get content types\n     *\n     * @method getContentTypes\n     * @returns {Array}\n     */\n    TextParameter.prototype.getContentTypes = function () {\n        return this.contentTypes;\n    };\n\n    /**\n     * Set content types\n     *\n     * @method setContentTypes\n     * @param {Array} contentTypes\n     */\n    TextParameter.prototype.setContentTypes = function (contentTypes) {\n        this.contentTypes = contentTypes;\n    };\n\n    /**\n     * Get SK\n     *\n     * @method getSubsetKnowledges\n     * @returns {Array}\n     */\n    TextParameter.prototype.getSubsetKnowledges = function () {\n        return this.subsetKnowledges;\n    };\n\n    /**\n     * Set SK\n     *\n     * @method setSubsetKnowledges\n     * @param {Array} subsetKnowledges\n     */\n    TextParameter.prototype.setSubsetKnowledges = function (subsetKnowledges) {\n        this.subsetKnowledges = subsetKnowledges;\n    };\n\n    /**\n     * Get user resources\n     *\n     * @method getUserResources\n     * @returns {Array}\n     */\n    TextParameter.prototype.getUserResources = function () {\n        return this.userResources;\n    };\n\n    /**\n     * Set user resources\n     *\n     * @method setUserResources\n     * @param {Array} userResources\n     */\n    TextParameter.prototype.setUserResources = function (userResources) {\n        this.userResources = userResources;\n    };\n\n    /**\n     * Get user LK words\n     *\n     * @method getUserLkWords\n     * @returns {Array}\n     */\n    TextParameter.prototype.getUserLkWords = function () {\n        return this.userLkWords;\n    };\n\n    /**\n     * Set user LK words\n     *\n     * @method setUserLkWords\n     * @param {Array} userLkWords\n     */\n    TextParameter.prototype.setUserLkWords = function (userLkWords) {\n        this.userLkWords = userLkWords;\n    };\n\n    /**\n     * Get result detail (e.g. TEXT, WORD ...)\n     *\n     * @method getResultDetail\n     * @returns {'TEXT'|'WORD'|'CHARACTER'}\n     */\n    TextParameter.prototype.getResultDetail = function () {\n        return this.resultDetail;\n    };\n\n    /**\n     * Set result detail (e.g. TEXT, WORD ...)\n     *\n     * @method setResultDetail\n     * @param {'TEXT'|'WORD'|'CHARACTER'} resultDetail\n     */\n    TextParameter.prototype.setResultDetail = function (resultDetail) {\n        this.resultDetail = resultDetail;\n    };\n\n    /**\n     * Get text properties\n     *\n     * @method getTextProperties\n     * @returns {TextProperties}\n     */\n    TextParameter.prototype.getTextProperties = function () {\n        return this.textProperties;\n    };\n\n    /**\n     * Set text properties\n     *\n     * @method setTextProperties\n     * @param {TextProperties} properties\n     */\n    TextParameter.prototype.setTextProperties = function (textProperties) {\n        this.textProperties = textProperties;\n    };\n\n    // Export\n    scope.TextParameter = TextParameter;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * Text recognition properties\n     *\n     * @class TextProperties\n     * @constructor\n     */\n    function TextProperties(obj) {\n        if (obj) {\n            if (obj.textCandidateListSize) {\n                this.textCandidateListSize = obj.textCandidateListSize;\n            }\n            if (obj.wordCandidateListSize) {\n                this.wordCandidateListSize = obj.wordCandidateListSize;\n            }\n            if (obj.wordPredictionListSize) {\n                this.wordPredictionListSize = obj.wordPredictionListSize;\n            }\n            if (obj.wordCompletionListSize) {\n                this.wordCompletionListSize = obj.wordCompletionListSize;\n            }\n            if (obj.characterCandidateListSize) {\n                this.characterCandidateListSize = obj.characterCandidateListSize;\n            }\n            if (obj.discardCaseVariations) {\n                this.discardCaseVariations = obj.discardCaseVariations;\n            }\n            if (obj.discardAccentuationVariations) {\n                this.discardAccentuationVariations = obj.discardAccentuationVariations;\n            }\n            if (obj.disableSpatialOrdering) {\n                this.disableSpatialOrdering = obj.disableSpatialOrdering;\n            }\n            if (obj.glyphDistortion) {\n                this.glyphDistortion = obj.glyphDistortion;\n            }\n            if (obj.enableOutOfLexicon) {\n                this.enableOutOfLexicon = obj.enableOutOfLexicon;\n            }\n            if (obj.spellingDistortion) {\n                this.spellingDistortion = obj.spellingDistortion;\n            }\n        }\n    }\n\n    /**\n     * Get the number of text candidates requested\n     *\n     * @method getTextCandidateListSize\n     * @returns {Number}\n     */\n    TextProperties.prototype.getTextCandidateListSize = function () {\n        return this.textCandidateListSize;\n    };\n\n    /**\n     * Set the number of text candidates requested\n     *\n     * @method setTextCandidateListSize\n     * @param {Number} textCandidateListSize\n     */\n    TextProperties.prototype.setTextCandidateListSize = function (textCandidateListSize) {\n        this.textCandidateListSize = textCandidateListSize;\n    };\n\n    /**\n     * Get the number of word candidates requested\n     *\n     * @method getWordCandidateListSize\n     * @returns {Number}\n     */\n    TextProperties.prototype.getWordCandidateListSize = function () {\n        return this.wordCandidateListSize;\n    };\n\n    /**\n     * Set the number of word candidates requested\n     *\n     * @method setWordCandidateListSize\n     * @param {Number} wordCandidateListSize\n     */\n    TextProperties.prototype.setWordCandidateListSize = function (wordCandidateListSize) {\n        this.wordCandidateListSize = wordCandidateListSize;\n    };\n\n    /**\n     * Get the number of word prediction candidates requested\n     *\n     * @method getWordPredictionListSize\n     * @returns {Number}\n     */\n    TextProperties.prototype.getWordPredictionListSize = function () {\n        return this.wordPredictionListSize;\n    };\n\n    /**\n     * Set the number of word prediction candidates requested\n     *\n     * @method setWordPredictionListSize\n     * @param {Number} wordPredictionListSize\n     */\n    TextProperties.prototype.setWordPredictionListSize = function (wordPredictionListSize) {\n        this.wordPredictionListSize = wordPredictionListSize;\n    };\n\n    /**\n     * Get the number of word completion candidates requested\n     *\n     * @method getWordCompletionListSize\n     * @returns {Number}\n     */\n    TextProperties.prototype.getWordCompletionListSize = function () {\n        return this.wordCompletionListSize;\n    };\n\n    /**\n     * Set the number of word completion candidates requested\n     *\n     * @method setWordCompletionListSize\n     * @param {Number} wordCompletionListSize\n     */\n    TextProperties.prototype.setWordCompletionListSize = function (wordCompletionListSize) {\n        this.wordCompletionListSize = wordCompletionListSize;\n    };\n\n    /**\n     * Get the number of character candidates requested\n     *\n     * @method getCharacterCandidateListSize\n     * @returns {Number}\n     */\n    TextProperties.prototype.getCharacterCandidateListSize = function () {\n        return this.characterCandidateListSize;\n    };\n\n    /**\n     * Set the number of character candidates requested\n     *\n     * @method setCharacterCandidateListSize\n     * @param {Number} characterCandidateListSize\n     */\n    TextProperties.prototype.setCharacterCandidateListSize = function (characterCandidateListSize) {\n        this.characterCandidateListSize = characterCandidateListSize;\n    };\n\n    /**\n     * Get the discard case variations\n     *\n     * @method getDiscardCaseVariations\n     * @returns {boolean}\n     */\n    TextProperties.prototype.getDiscardCaseVariations = function () {\n        return this.discardCaseVariations;\n    };\n\n    /**\n     * Set the discard case variations\n     *\n     * @method setDiscardCaseVariations\n     * @param {boolean} discardCaseVariations\n     */\n    TextProperties.prototype.setDiscardCaseVariations = function (discardCaseVariations) {\n        this.discardCaseVariations = discardCaseVariations;\n    };\n\n    /**\n     * Get the discard accentuation variations\n     *\n     * @method getDiscardAccentuationVariations\n     * @returns {boolean}\n     */\n    TextProperties.prototype.getDiscardAccentuationVariations = function () {\n        return this.discardAccentuationVariations;\n    };\n\n    /**\n     * Set the discard accentuation variations\n     *\n     * @method setDiscardAccentuationVariations\n     * @param {boolean} discardAccentuationVariations\n     */\n    TextProperties.prototype.setDiscardAccentuationVariations = function (discardAccentuationVariations) {\n        this.discardAccentuationVariations = discardAccentuationVariations;\n    };\n\n    /**\n     * Get disable spatial ordering\n     *\n     * @method getDisableSpatialOrdering\n     * @returns {Boolean}\n     */\n    TextProperties.prototype.getDisableSpatialOrdering = function () {\n        return this.disableSpatialOrdering;\n    };\n\n    /**\n     * Set disable spatial ordering\n     *\n     * @method setDisableSpatialOrdering\n     * @param {Boolean} disableSpatialOrdering\n     */\n    TextProperties.prototype.setDisableSpatialOrdering = function (disableSpatialOrdering) {\n        this.disableSpatialOrdering = disableSpatialOrdering;\n    };\n\n    /**\n     * Get glyph distortion\n     *\n     * @method getGlyphDistortion\n     * @returns {Number}\n     */\n    TextProperties.prototype.getGlyphDistortion = function () {\n        return this.glyphDistortion;\n    };\n\n    /**\n     * Set glyph distortion\n     *\n     * @method setGlyphDistortion\n     * @param {Number} glyphDistortion\n     */\n    TextProperties.prototype.setGlyphDistortion = function (glyphDistortion) {\n        this.glyphDistortion = glyphDistortion;\n    };\n\n    /**\n     * Get enable out of lexicon\n     *\n     * @method getEnableOutOfLexicon\n     * @returns {Boolean}\n     */\n    TextProperties.prototype.getEnableOutOfLexicon = function () {\n        return this.enableOutOfLexicon;\n    };\n\n    /**\n     * Set enable out of lexicon\n     *\n     * @method setEnableOutOfLexicon\n     * @param {Boolean} enableOutOfLexicon\n     */\n    TextProperties.prototype.setEnableOutOfLexicon = function (enableOutOfLexicon) {\n        this.enableOutOfLexicon = enableOutOfLexicon;\n    };\n\n    /**\n     * Get spelling distortion\n     *\n     * @method getSpellingDistortion\n     * @returns {Number}\n     */\n    TextProperties.prototype.getSpellingDistortion = function () {\n        return this.spellingDistortion;\n    };\n\n    /**\n     * Set spelling distortion\n     *\n     * @method setSpellingDistortion\n     * @param {Number} spellingDistortion\n     */\n    TextProperties.prototype.setSpellingDistortion = function (spellingDistortion) {\n        this.spellingDistortion = spellingDistortion;\n    };\n\n    // Export\n    scope.TextProperties = TextProperties;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * Recognition input object for text recognition\n     *\n     * @class TextRecognitionInput\n     * @extends AbstractRecognitionInput\n     * @constructor\n     */\n    function TextRecognitionInput() {\n    }\n\n    /**\n     * Inheritance property\n     */\n    TextRecognitionInput.prototype = new scope.AbstractRecognitionInput();\n\n    /**\n     * Constructor property\n     */\n    TextRecognitionInput.prototype.constructor = TextRecognitionInput;\n\n    /**\n     * Get parameters\n     *\n     * @method getParameters\n     * @returns {TextParameter}\n     */\n    TextRecognitionInput.prototype.getParameters = function () {\n        return this.textParameter;\n    };\n\n    /**\n     * Set parameters\n     *\n     * @method setParameters\n     * @param {TextParameter} parameters\n     */\n    TextRecognitionInput.prototype.setParameters = function (parameters) {\n        this.textParameter = parameters;\n    };\n\n    /**\n     * Get input units\n     *\n     * @method getInputUnits\n     * @param {TextInkRange} [inkRange]\n     * @returns {TextInputUnit[]}\n     */\n    TextRecognitionInput.prototype.getInputUnits = function (inkRange) {\n        if (inkRange && (inkRange instanceof scope.TextInkRange)) {\n            return this.inputUnits.slice(inkRange.getStartUnit(), inkRange.getEndUnit() + 1);\n        }\n        return this.inputUnits;\n    };\n\n    /**\n     * Set input units\n     *\n     * @method setInputUnits\n     * @param {TextInputUnit[]} inputUnits\n     */\n    TextRecognitionInput.prototype.setInputUnits = function (inputUnits) {\n        this.inputUnits = inputUnits;\n    };\n\n    // Export\n    scope.TextRecognitionInput = TextRecognitionInput;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Recognition data for text input\n     *\n     * @class TextRecognitionData\n     * @extends AbstractRecognitionData\n     * @constructor\n     */\n    function TextRecognitionData() {\n    }\n\n    /**\n     * Inheritance property\n     */\n    TextRecognitionData.prototype = new scope.AbstractRecognitionData();\n\n    /**\n     * Constructor property\n     */\n    TextRecognitionData.prototype.constructor = TextRecognitionData;\n\n    /**\n     * Get text input\n     *\n     * @method getRecognitionInput\n     * @returns {TextRecognitionInput} input\n     */\n    TextRecognitionData.prototype.getRecognitionInput = function () {\n        return this.textInput;\n    };\n\n    /**\n     * Set text input\n     *\n     * @method setRecognitionInput\n     * @param {TextRecognitionInput} input\n     */\n    TextRecognitionData.prototype.setRecognitionInput = function (input) {\n        this.textInput = JSON.stringify(input);\n    };\n\n    // Export\n    scope.TextRecognitionData = TextRecognitionData;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * WebSocket start text recognition message\n     *\n     * @class TextStartRequestWSMessage\n     * @extends AbstractStartRequestWSMessage\n     * @param {Object} [obj] Recognition WebSocket message\n     * @constructor\n     */\n    function TextStartRequestWSMessage(obj) {\n        scope.AbstractStartRequestWSMessage.call(this, obj);\n    }\n\n    /**\n     * Inheritance property\n     */\n    TextStartRequestWSMessage.prototype = new scope.AbstractStartRequestWSMessage();\n\n    /**\n     * Constructor property\n     */\n    TextStartRequestWSMessage.prototype.constructor = TextStartRequestWSMessage;\n\n    /**\n     * Get parameters\n     *\n     * @method getParameters\n     * @returns {TextParameter}\n     */\n    TextStartRequestWSMessage.prototype.getParameters = function () {\n        return this.textParameter;\n    };\n\n    /**\n     * Set parameters\n     *\n     * @method setParameters\n     * @param {TextParameter} parameters\n     */\n    TextStartRequestWSMessage.prototype.setParameters = function (parameters) {\n        this.textParameter = parameters;\n    };\n\n    /**\n     * Get input units\n     *\n     * @method getInputUnits\n     * @returns {TextInputUnit[]}\n     */\n    TextStartRequestWSMessage.prototype.getInputUnits = function () {\n        return this.inputUnits;\n    };\n\n    /**\n     * Set input units\n     *\n     * @method setInputUnits\n     * @param {TextInputUnit[]} inputUnits\n     */\n    TextStartRequestWSMessage.prototype.setInputUnits = function (inputUnits) {\n        this.inputUnits = inputUnits;\n    };\n\n    // Export\n    scope.TextStartRequestWSMessage = TextStartRequestWSMessage;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * WebSocket continue text recognition message\n     *\n     * @class TextContinueRequestWSMessage\n     * @extends AbstractContinueRequestWSMessage\n     * @param {Object} [obj] Recognition WebSocket message\n     * @constructor\n     */\n    function TextContinueRequestWSMessage(obj) {\n        scope.AbstractContinueRequestWSMessage.call(this, obj);\n    }\n\n    /**\n     * Inheritance property\n     */\n    TextContinueRequestWSMessage.prototype = new scope.AbstractContinueRequestWSMessage();\n\n    /**\n     * Constructor property\n     */\n    TextContinueRequestWSMessage.prototype.constructor = TextContinueRequestWSMessage;\n\n    /**\n     * Get input units\n     *\n     * @method getInputUnits\n     * @returns {TextInputUnit[]}\n     */\n    TextContinueRequestWSMessage.prototype.getInputUnits = function () {\n        return this.inputUnits;\n    };\n\n    /**\n     * Set input units\n     *\n     * @method setInputUnits\n     * @param {TextInputUnit[]} inputUnits\n     */\n    TextContinueRequestWSMessage.prototype.setInputUnits = function (inputUnits) {\n        this.inputUnits = inputUnits;\n    };\n\n    // Export\n    scope.TextContinueRequestWSMessage = TextContinueRequestWSMessage;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Parameters used for shape recognition\n     *\n     * @class ShapeParameter\n     * @extends AbstractParameter\n     * @constructor\n     */\n    function ShapeParameter(obj) {\n        scope.AbstractParameter.call(this, obj);\n        if (obj) {\n            if (obj.rejectDetectionSensitivity) {\n                this.rejectDetectionSensitivity = obj.rejectDetectionSensitivity;\n            }\n            if (obj.doBeautification) {\n                this.doBeautification = obj.doBeautification;\n            }\n            if (obj.userResources) {\n                this.userResources = obj.userResources;\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    ShapeParameter.prototype = new scope.AbstractParameter();\n\n    /**\n     * Constructor property\n     */\n    ShapeParameter.prototype.constructor = ShapeParameter;\n\n    /**\n     * Get the sensitivity of the reject detection\n     *\n     * @method getRejectDetectionSensitivity\n     * @returns {Boolean}\n     */\n    ShapeParameter.prototype.getRejectDetectionSensitivity = function () {\n        return this.rejectDetectionSensitivity;\n    };\n\n    /**\n     * Set the sensitivity of the reject detection\n     *\n     * @method setRejectDetectionSensitivity\n     * @param {Boolean} rejectDetectionSensitivity\n     */\n    ShapeParameter.prototype.setRejectDetectionSensitivity = function (rejectDetectionSensitivity) {\n        this.rejectDetectionSensitivity = rejectDetectionSensitivity;\n    };\n\n    /**\n     * Get the beautification\n     *\n     * @method hasBeautification\n     * @returns {Boolean}\n     */\n    ShapeParameter.prototype.hasBeautification = function () {\n        return this.doBeautification;\n    };\n\n    /**\n     * Set the beautification\n     *\n     * @method setBeautification\n     * @param {Boolean} doBeautification\n     */\n    ShapeParameter.prototype.setBeautification = function (doBeautification) {\n        this.doBeautification = doBeautification;\n    };\n\n    /**\n     * Get the user resources\n     *\n     * @method getUserResources\n     * @returns {Array}\n     */\n    ShapeParameter.prototype.getUserResources = function () {\n        return this.userResources;\n    };\n\n    /**\n     * Set the user resources\n     *\n     * @method setUserResources\n     * @param {Array} userResources\n     */\n    ShapeParameter.prototype.setUserResources = function (userResources) {\n        this.userResources = userResources;\n    };\n\n    // Export\n    scope.ShapeParameter = ShapeParameter;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * Recognition input object for shape recognition\n     *\n     * @class ShapeRecognitionInput\n     * @extends AbstractRecognitionInput\n     * @constructor\n     */\n    function ShapeRecognitionInput() {\n    }\n\n    /**\n     * Inheritance property\n     */\n    ShapeRecognitionInput.prototype = new scope.AbstractRecognitionInput();\n\n    /**\n     * Constructor property\n     */\n    ShapeRecognitionInput.prototype.constructor = ShapeRecognitionInput;\n\n    /**\n     * Get parameters\n     *\n     * @method getParameters\n     * @returns {ShapeParameter}\n     */\n    ShapeRecognitionInput.prototype.getParameters = function () {\n        return new ShapeParameter({\n            rejectDetectionSensitivity: this.rejectDetectionSensitivity,\n            doBeautification: this.doBeautification,\n            userResources: this.userResources\n        });\n    };\n\n    /**\n     * Set parameters\n     *\n     * @method setParameters\n     * @param {ShapeParameter} parameters\n     */\n    ShapeRecognitionInput.prototype.setParameters = function (parameters) {\n        if (parameters) {\n            this.rejectDetectionSensitivity = parameters.getRejectDetectionSensitivity();\n            this.doBeautification = parameters.hasBeautification();\n            this.userResources = parameters.getUserResources();\n        }\n    };\n\n    /**\n     * Get input components\n     *\n     * @method getComponents\n     * @returns {AbstractComponent[]}\n     */\n    ShapeRecognitionInput.prototype.getComponents = function () {\n        return this.components;\n    };\n\n    /**\n     * Set input components\n     *\n     * @method setComponents\n     * @param {AbstractComponent[]} components\n     */\n    ShapeRecognitionInput.prototype.setComponents = function (components) {\n        this.components = components;\n    };\n\n    // Export\n    scope.ShapeRecognitionInput = ShapeRecognitionInput;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * Recognition data for shape input\n     *\n     * @class ShapeRecognitionData\n     * @extends AbstractRecognitionData\n     * @constructor\n     */\n    function ShapeRecognitionData() {\n    }\n\n    /**\n     * Inheritance property\n     */\n    ShapeRecognitionData.prototype = new scope.AbstractRecognitionData();\n\n    /**\n     * Constructor property\n     */\n    ShapeRecognitionData.prototype.constructor = ShapeRecognitionData;\n\n    /**\n     * Get shape input\n     *\n     * @method getRecognitionInput\n     * @returns {ShapeRecognitionInput}\n     */\n    ShapeRecognitionData.prototype.getRecognitionInput = function () {\n        return this.shapeInput;\n    };\n\n    /**\n     * Set shape input\n     *\n     * @method setRecognitionInput\n     * @param {ShapeRecognitionInput} input\n     */\n    ShapeRecognitionData.prototype.setRecognitionInput = function (input) {\n        this.shapeInput = JSON.stringify(input);\n    };\n\n    // Export\n    scope.ShapeRecognitionData = ShapeRecognitionData;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * Parameters used for math recognition\n     *\n     * @class MathParameter\n     * @extends AbstractParameter\n     * @constructor\n     */\n    function MathParameter(obj) {\n        scope.AbstractParameter.call(this, obj);\n        this.resultTypes = [];\n        this.userResources = [];\n        if (obj) {\n            if (obj.resultTypes) {\n                this.resultTypes = obj.resultTypes;\n            }\n            if (obj.columnarOperation) {\n                this.columnarOperation = obj.columnarOperation;\n            }\n            if (obj.userResources) {\n                this.userResources = obj.userResources;\n            }\n            if (obj.scratchOutDetectionSensitivity) {\n                this.scratchOutDetectionSensitivity = obj.scratchOutDetectionSensitivity;\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MathParameter.prototype = new scope.AbstractParameter();\n\n    /**\n     * Constructor property\n     */\n    MathParameter.prototype.constructor = MathParameter;\n\n    /**\n     * Get the math result types (e.g. LaTex, MathML, SymbolTree)\n     *\n     * @method getResultTypes\n     * @returns {Array}\n     */\n    MathParameter.prototype.getResultTypes = function () {\n        return this.resultTypes;\n    };\n\n    /**\n     * Set the math result types (e.g. LaTex, MathML, SymbolTree)\n     *\n     * @method setResultTypes\n     * @param {Array} resultTypes\n     */\n    MathParameter.prototype.setResultTypes = function (resultTypes) {\n        this.resultTypes = resultTypes;\n    };\n\n    /**\n     * Get the math result result orientation to columnar operations\n     *\n     * @method isColumnar\n     * @returns {Boolean}\n     */\n    MathParameter.prototype.isColumnar = function () {\n        return this.columnarOperation;\n    };\n\n    /**\n     * Set the math result orientation to columnar operations\n     *\n     * @method setColumnar\n     * @param  {Boolean} columnar\n     */\n    MathParameter.prototype.setColumnar = function (columnar) {\n        this.columnarOperation = columnar;\n    };\n\n    /**\n     * Get the user resources\n     *\n     * @method getUserResources\n     * @returns {Array}\n     */\n    MathParameter.prototype.getUserResources = function () {\n        return this.userResources;\n    };\n\n    /**\n     * Set the user resources\n     *\n     * @method setUserResources\n     * @param {Array} userResources\n     */\n    MathParameter.prototype.setUserResources = function (userResources) {\n        this.userResources = userResources;\n    };\n\n    /**\n     * Get the sensitivity of the scratch-out detection\n     *\n     * @method getScratchOutDetectionSensitivity\n     * @returns {Number}\n     */\n    MathParameter.prototype.getScratchOutDetectionSensitivity = function () {\n        return this.scratchOutDetectionSensitivity;\n    };\n\n    /**\n     * Set the sensitivity of the scratch-out detection\n     *\n     * @method setScratchOutDetectionSensitivity\n     * @param {Number} scratchOutDetectionSensitivity\n     */\n    MathParameter.prototype.setScratchOutDetectionSensitivity = function (scratchOutDetectionSensitivity) {\n        this.scratchOutDetectionSensitivity = scratchOutDetectionSensitivity;\n    };\n\n    // Export\n    scope.MathParameter = MathParameter;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * Recognition input object for math recognition\n     *\n     * @class MathRecognitionInput\n     * @extends AbstractRecognitionInput\n     * @constructor\n     */\n    function MathRecognitionInput() {\n    }\n\n    /**\n     * Inheritance property\n     */\n    MathRecognitionInput.prototype = new scope.AbstractRecognitionInput();\n\n    /**\n     * Constructor property\n     */\n    MathRecognitionInput.prototype.constructor = MathRecognitionInput;\n\n    /**\n     * Get parameters\n     *\n     * @method getParameters\n     * @returns {MathParameter}\n     */\n    MathRecognitionInput.prototype.getParameters = function () {\n        return new MathParameter({\n            resultTypes: this.resultTypes,\n            columnarOperation: this.columnarOperation,\n            userResources: this.userResources,\n            scratchOutDetectionSensitivity: this.scratchOutDetectionSensitivity\n        });\n    };\n\n    /**\n     * Set parameters\n     *\n     * @method setParameters\n     * @param {MathParameter} parameters\n     */\n    MathRecognitionInput.prototype.setParameters = function (parameters) {\n        if (parameters) {\n            this.resultTypes = parameters.getResultTypes();\n            this.columnarOperation = parameters.isColumnar();\n            this.userResources = parameters.getUserResources();\n            this.scratchOutDetectionSensitivity = parameters.getScratchOutDetectionSensitivity();\n        }\n    };\n\n    /**\n     * Get input components\n     *\n     * @method getComponents\n     * @returns {AbstractComponent[]}\n     */\n    MathRecognitionInput.prototype.getComponents = function () {\n        return this.components;\n    };\n\n    /**\n     * Set input components\n     *\n     * @method setComponents\n     * @param {AbstractComponent[]} components\n     */\n    MathRecognitionInput.prototype.setComponents = function (components) {\n        this.components = components;\n    };\n\n    // Export\n    scope.MathRecognitionInput = MathRecognitionInput;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * Recognition data for math input\n     *\n     * @class MathRecognitionData\n     * @extends AbstractRecognitionData\n     * @constructor\n     */\n    function MathRecognitionData() {\n    }\n\n    /**\n     * Inheritance property\n     */\n    MathRecognitionData.prototype = new scope.AbstractRecognitionData();\n\n    /**\n     * Constructor property\n     */\n    MathRecognitionData.prototype.constructor = MathRecognitionData;\n\n\n    /**\n     * Get math input\n     *\n     * @method getRecognitionInput\n     * @returns {MathRecognitionInput}\n     */\n    MathRecognitionData.prototype.getRecognitionInput = function () {\n        return this.mathInput;\n    };\n\n    /**\n     * Set math input\n     *\n     * @method setRecognitionInput\n     * @param {MathRecognitionInput} input\n     */\n    MathRecognitionData.prototype.setRecognitionInput = function (input) {\n        this.mathInput = JSON.stringify(input);\n    };\n\n    // Export\n    scope.MathRecognitionData = MathRecognitionData;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * WebSocket start math recognition message\n     *\n     * @class MathStartRequestWSMessage\n     * @extends AbstractStartRequestWSMessage\n     * @param {Object} [obj] Recognition WebSocket message\n     * @constructor\n     */\n    function MathStartRequestWSMessage(obj) {\n        scope.AbstractStartRequestWSMessage.call(this, obj);\n    }\n\n    /**\n     * Inheritance property\n     */\n    MathStartRequestWSMessage.prototype = new scope.AbstractStartRequestWSMessage();\n\n    /**\n     * Constructor property\n     */\n    MathStartRequestWSMessage.prototype.constructor = MathStartRequestWSMessage;\n\n    /**\n     * Get parameters\n     *\n     * @method getParameters\n     * @returns {MathParameter}\n     */\n    MathStartRequestWSMessage.prototype.getParameters = function () {\n        return this.parameters;\n    };\n\n    /**\n     * Set parameters\n     *\n     * @method setParameters\n     * @param {MathParameter} parameters\n     */\n    MathStartRequestWSMessage.prototype.setParameters = function (parameters) {\n        this.parameters = parameters;\n    };\n\n    /**\n     * Get components\n     *\n     * @method getComponents\n     * @returns {MathInputUnit[]}\n     */\n    MathStartRequestWSMessage.prototype.getComponents = function () {\n        return this.components;\n    };\n\n    /**\n     * Set components\n     *\n     * @method setComponents\n     * @param {MathInputUnit[]} components\n     */\n    MathStartRequestWSMessage.prototype.setComponents = function (components) {\n        this.components = components;\n    };\n\n    // Export\n    scope.MathStartRequestWSMessage = MathStartRequestWSMessage;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * WebSocket continue math recognition message\n     *\n     * @class MathContinueRequestWSMessage\n     * @extends AbstractContinueRequestWSMessage\n     * @param {Object} [obj] Recognition WebSocket message\n     * @constructor\n     */\n    function MathContinueRequestWSMessage(obj) {\n        this.type = 'continue';\n        scope.AbstractContinueRequestWSMessage.call(this, obj);\n    }\n\n    /**\n     * Inheritance property\n     */\n    MathContinueRequestWSMessage.prototype = new scope.AbstractContinueRequestWSMessage();\n\n    /**\n     * Constructor property\n     */\n    MathContinueRequestWSMessage.prototype.constructor = MathContinueRequestWSMessage;\n\n    /**\n     * Get components\n     *\n     * @method getComponents\n     * @returns {MathInputUnit[]}\n     */\n    MathContinueRequestWSMessage.prototype.getComponents = function () {\n        return this.components;\n    };\n\n    /**\n     * Set components\n     *\n     * @method setComponents\n     * @param {MathInputUnit[]} components\n     */\n    MathContinueRequestWSMessage.prototype.setComponents = function (components) {\n        this.components = components;\n    };\n\n    // Export\n    scope.MathContinueRequestWSMessage = MathContinueRequestWSMessage;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Abstract music input component\n     *\n     * @class AbstractMusicInputComponent\n     * @extends AbstractComponent\n     * @constructor\n     */\n    function AbstractMusicInputComponent(obj) {\n        scope.AbstractComponent.call(this);\n        if (obj) {\n            if (obj.boundingBox) {\n                this.boundingBox = new scope.Rectangle(obj.boundingBox);\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    AbstractMusicInputComponent.prototype = new scope.AbstractComponent();\n\n    /**\n     * Constructor property\n     */\n    AbstractMusicInputComponent.prototype.constructor = AbstractMusicInputComponent;\n\n    /**\n     * Get input component bounding-box\n     *\n     * @method getBoundingBox\n     * @returns {Rectangle}\n     */\n    AbstractMusicInputComponent.prototype.getBoundingBox = function () {\n        return this.boundingBox;\n    };\n\n    /**\n     * Set input component bounding-box\n     *\n     * @method setBoundingBox\n     * @param {Rectangle} boundingBox\n     */\n    AbstractMusicInputComponent.prototype.setBoundingBox = function (boundingBox) {\n        this.boundingBox = boundingBox;\n    };\n\n    // Export\n    scope.AbstractMusicInputComponent = AbstractMusicInputComponent;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * Accidental input component\n     *\n     * @class MusicAccidentalInputComponent\n     * @extends AbstractMusicInputComponent\n     * @constructor\n     */\n    function MusicAccidentalInputComponent(obj) {\n        scope.AbstractMusicInputComponent.call(this, obj);\n        this.type = 'accidental';\n        if (obj) {\n            if (obj.value) {\n                this.value = obj.value;\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicAccidentalInputComponent.prototype = new scope.AbstractMusicInputComponent();\n\n    /**\n     * Constructor property\n     */\n    MusicAccidentalInputComponent.prototype.constructor = MusicAccidentalInputComponent;\n\n    /**\n     * Get accidental input component value\n     *\n     * @method getValue\n     * @returns {String}\n     */\n    MusicAccidentalInputComponent.prototype.getValue = function () {\n        return this.value;\n    };\n\n    /**\n     * Set accidental input component value\n     *\n     * @method setValue\n     * @param {String} value\n     */\n    MusicAccidentalInputComponent.prototype.setValue = function (value) {\n        this.value = value;\n    };\n\n    // Export\n    scope.MusicAccidentalInputComponent = MusicAccidentalInputComponent;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * Arpeggiate input component\n     *\n     * @class MusicArpeggiateInputComponent\n     * @extends AbstractMusicInputComponent\n     * @constructor\n     */\n    function MusicArpeggiateInputComponent(obj) {\n        scope.AbstractMusicInputComponent.call(this, obj);\n        this.type = 'arpeggiate';\n        if (obj) {\n            if (obj.value) {\n                this.value = obj.value;\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicArpeggiateInputComponent.prototype = new scope.AbstractMusicInputComponent();\n\n    /**\n     * Constructor property\n     */\n    MusicArpeggiateInputComponent.prototype.constructor = MusicArpeggiateInputComponent;\n\n    /**\n     * Get arpeggiate input component value\n     *\n     * @method getValue\n     * @returns {String}\n     */\n    MusicArpeggiateInputComponent.prototype.getValue = function () {\n        return this.value;\n    };\n\n    /**\n     * Set arpeggiate input component value\n     *\n     * @method setValue\n     * @param {String} value\n     */\n    MusicArpeggiateInputComponent.prototype.setValue = function (value) {\n        this.value = value;\n    };\n\n    // Export\n    scope.MusicArpeggiateInputComponent = MusicArpeggiateInputComponent;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * Bar input component\n     *\n     * @class MusicBarInputComponent\n     * @extends AbstractMusicInputComponent\n     * @constructor\n     */\n    function MusicBarInputComponent(obj) {\n        scope.AbstractMusicInputComponent.call(this, obj);\n        this.type = 'bar';\n        this.value = new scope.MusicBar();\n        if (obj) {\n            if (obj.value) {\n                this.value = new scope.MusicBar(obj.value);\n            }\n        }\n\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicBarInputComponent.prototype = new scope.AbstractMusicInputComponent();\n\n    /**\n     * Constructor property\n     */\n    MusicBarInputComponent.prototype.constructor = MusicBarInputComponent;\n\n    /**\n     * Get bar component value\n     *\n     * @method getValue\n     * @returns {MusicBar}\n     */\n    MusicBarInputComponent.prototype.getValue = function () {\n        return this.value;\n    };\n\n    /**\n     * Set bar component value\n     *\n     * @method setValue\n     * @param {MusicBar} value\n     */\n    MusicBarInputComponent.prototype.setValue = function (value) {\n        this.value = value;\n    };\n\n    // Export\n    scope.MusicBarInputComponent = MusicBarInputComponent;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * Beam input component\n     *\n     * @class MusicBeamInputComponent\n     * @extends AbstractMusicInputComponent\n     * @constructor\n     */\n    function MusicBeamInputComponent(obj) {\n        scope.AbstractMusicInputComponent.call(this, obj);\n        this.type = 'beam';\n        this.value = new scope.MusicBeam();\n        if (obj) {\n            if (obj.value) {\n                this.value = new scope.MusicBeam(obj.value);\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicBeamInputComponent.prototype = new scope.AbstractMusicInputComponent();\n\n    /**\n     * Constructor property\n     */\n    MusicBeamInputComponent.prototype.constructor = MusicBeamInputComponent;\n\n    /**\n     * Get beam input component value\n     *\n     * @method getValue\n     * @returns {MusicBeam}\n     */\n    MusicBeamInputComponent.prototype.getValue = function () {\n        return this.value;\n    };\n\n    /**\n     * Set beam input component value\n     *\n     * @method setValue\n     * @param {MusicBeam} value\n     */\n    MusicBeamInputComponent.prototype.setValue = function (value) {\n        this.value = value;\n    };\n\n    // Export\n    scope.MusicBeamInputComponent = MusicBeamInputComponent;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * Clef input component\n     * default clef values: symbol='G', octave=0\n     *\n     * @class MusicClefInputComponent\n     * @extends AbstractMusicInputComponent\n     * @constructor\n     */\n    function MusicClefInputComponent(obj) {\n        scope.AbstractMusicInputComponent.call(this, obj);\n        this.type = 'clef';\n        this.value = new scope.MusicClef();\n        if (obj) {\n            if (obj.value) {\n                this.value = new scope.MusicClef(obj.value);\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicClefInputComponent.prototype = new scope.AbstractMusicInputComponent();\n\n    /**\n     * Constructor property\n     */\n    MusicClefInputComponent.prototype.constructor = MusicClefInputComponent;\n\n    /**\n     * Get clef input component value\n     *\n     * @method getValue\n     * @returns {MusicClef}\n     */\n    MusicClefInputComponent.prototype.getValue = function () {\n        return this.value;\n    };\n\n    /**\n     * Set clef input component value\n     *\n     * @method setValue\n     * @param {MusicClef} value\n     */\n    MusicClefInputComponent.prototype.setValue = function (value) {\n        this.value = value;\n    };\n\n    // Export\n    scope.MusicClefInputComponent = MusicClefInputComponent;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * Decoration input component\n     *\n     * @class MusicDecorationInputComponent\n     * @extends AbstractMusicInputComponent\n     * @constructor\n     */\n    function MusicDecorationInputComponent(obj) {\n        scope.AbstractMusicInputComponent.call(this, obj);\n        this.type = 'decoration';\n        this.value = new scope.MusicDecoration();\n        if (obj) {\n            if (obj.value) {\n                this.value = new scope.MusicDecoration(obj.value);\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicDecorationInputComponent.prototype = new scope.AbstractMusicInputComponent();\n\n    /**\n     * Constructor property\n     */\n    MusicDecorationInputComponent.prototype.constructor = MusicDecorationInputComponent;\n\n    /**\n     * Get decoration input component value\n     *\n     * @method getValue\n     * @returns {MusicDecoration}\n     */\n    MusicDecorationInputComponent.prototype.getValue = function () {\n        return this.value;\n    };\n\n    /**\n     * Set decoration input component value\n     *\n     * @method setValue\n     * @param {MusicDecoration} value\n     */\n    MusicDecorationInputComponent.prototype.setValue = function (value) {\n        this.value = value;\n    };\n\n    // Export\n    scope.MusicDecorationInputComponent = MusicDecorationInputComponent;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * Dots input component\n     *\n     * @class MusicDotsInputComponent\n     * @extends AbstractMusicInputComponent\n     * @constructor\n     */\n    function MusicDotsInputComponent(obj) {\n        scope.AbstractMusicInputComponent.call(this, obj);\n        this.type = 'dots';\n        if (obj) {\n            if (obj.value) {\n                this.value = obj.value;\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicDotsInputComponent.prototype = new scope.AbstractMusicInputComponent();\n\n    /**\n     * Constructor property\n     */\n    MusicDotsInputComponent.prototype.constructor = MusicDotsInputComponent;\n\n    /**\n     * Get dots input component value\n     *\n     * @method getValue\n     * @returns {String}\n     */\n    MusicDotsInputComponent.prototype.getValue = function () {\n        return this.value;\n    };\n\n    /**\n     * Set dots input component value\n     *\n     * @method setValue\n     * @param {String} value\n     */\n    MusicDotsInputComponent.prototype.setValue = function (value) {\n        this.value = value;\n    };\n\n    // Export\n    scope.MusicDotsInputComponent = MusicDotsInputComponent;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * Head input component\n     *\n     * @class MusicHeadInputComponent\n     * @extends AbstractMusicInputComponent\n     * @constructor\n     */\n    function MusicHeadInputComponent(obj) {\n        scope.AbstractMusicInputComponent.call(this, obj);\n        this.type = 'head';\n        if (obj) {\n            if (obj.value) {\n                this.value = obj.value;\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicHeadInputComponent.prototype = new scope.AbstractMusicInputComponent();\n\n    /**\n     * Constructor property\n     */\n    MusicHeadInputComponent.prototype.constructor = MusicHeadInputComponent;\n\n    /**\n     * Get head input component value\n     *\n     * @method getValue\n     * @returns {String}\n     */\n    MusicHeadInputComponent.prototype.getValue = function () {\n        return this.value;\n    };\n\n    /**\n     * Set head input component value\n     *\n     * @method setValue\n     * @param {String} value\n     */\n    MusicHeadInputComponent.prototype.setValue = function (value) {\n        this.value = value;\n    };\n\n    // Export\n    scope.MusicHeadInputComponent = MusicHeadInputComponent;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * Ledger line input component\n     *\n     * @class MusicLedgerLineInputComponent\n     * @extends AbstractMusicInputComponent\n     * @constructor\n     */\n    function MusicLedgerLineInputComponent(obj) {\n        scope.AbstractMusicInputComponent.call(this, obj);\n        this.type = 'ledgerLine';\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicLedgerLineInputComponent.prototype = new scope.AbstractMusicInputComponent();\n\n    /**\n     * Constructor property\n     */\n    MusicLedgerLineInputComponent.prototype.constructor = MusicLedgerLineInputComponent;\n\n    // Export\n    scope.MusicLedgerLineInputComponent = MusicLedgerLineInputComponent;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * Rest input component\n     *\n     * @class MusicRestInputComponent\n     * @extends AbstractMusicInputComponent\n     * @constructor\n     */\n    function MusicRestInputComponent(obj) {\n        scope.AbstractMusicInputComponent.call(this, obj);\n        this.type = 'rest';\n        if (obj) {\n            if (obj.value) {\n                this.value = obj.value;\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicRestInputComponent.prototype = new scope.AbstractMusicInputComponent();\n\n    /**\n     * Constructor property\n     */\n    MusicRestInputComponent.prototype.constructor = MusicRestInputComponent;\n\n    /**\n     * Get rest input component value\n     *\n     * @method getValue\n     * @returns {String}\n     */\n    MusicRestInputComponent.prototype.getValue = function () {\n        return this.value;\n    };\n\n    /**\n     * Set rest input component value\n     *\n     * @method setValue\n     * @param {String} value\n     */\n    MusicRestInputComponent.prototype.setValue = function (value) {\n        this.value = value;\n    };\n\n    // Export\n    scope.MusicRestInputComponent = MusicRestInputComponent;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * Stem input component\n     *\n     * @class MusicStemInputComponent\n     * @extends AbstractMusicInputComponent\n     * @constructor\n     */\n    function MusicStemInputComponent(obj) {\n        scope.AbstractMusicInputComponent.call(this, obj);\n        this.type = 'stem';\n        if (obj) {\n            if (obj.value) {\n                this.value = obj.value;\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicStemInputComponent.prototype = new scope.AbstractMusicInputComponent();\n\n    /**\n     * Constructor property\n     */\n    MusicStemInputComponent.prototype.constructor = MusicStemInputComponent;\n\n    /**\n     * Get stem input component value\n     *\n     * @method getValue\n     * @returns {String}\n     */\n    MusicStemInputComponent.prototype.getValue = function () {\n        return this.value;\n    };\n\n    /**\n     * Set stem input component value\n     *\n     * @method setValue\n     * @param {String} value\n     */\n    MusicStemInputComponent.prototype.setValue = function (value) {\n        this.value = value;\n    };\n\n    // Export\n    scope.MusicStemInputComponent = MusicStemInputComponent;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * Tie ro slur input component\n     *\n     * @class MusicTieOrSlurInputComponent\n     * @extends AbstractMusicInputComponent\n     * @constructor\n     */\n    function MusicTieOrSlurInputComponent(obj) {\n        scope.AbstractMusicInputComponent.call(this, obj);\n        this.type = 'tieOrSlur';\n        if (obj) {\n            if (obj.value) {\n                this.value = obj.value;\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicTieOrSlurInputComponent.prototype = new scope.AbstractMusicInputComponent();\n\n    /**\n     * Constructor property\n     */\n    MusicTieOrSlurInputComponent.prototype.constructor = MusicTieOrSlurInputComponent;\n\n    /**\n     * Get tie or slur input component value\n     *\n     * @method getValue\n     * @returns {String}\n     */\n    MusicTieOrSlurInputComponent.prototype.getValue = function () {\n        return this.value;\n    };\n\n    /**\n     * Set tie or slur input component value\n     *\n     * @method setValue\n     * @param {String} value\n     */\n    MusicTieOrSlurInputComponent.prototype.setValue = function (value) {\n        this.value = value;\n    };\n\n    // Export\n    scope.MusicTieOrSlurInputComponent = MusicTieOrSlurInputComponent;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * Time signature input component\n     *\n     * @class MusicTimeSignatureInputComponent\n     * @extends AbstractMusicInputComponent\n     * @constructor\n     */\n    function MusicTimeSignatureInputComponent(obj) {\n        scope.AbstractMusicInputComponent.call(this, obj);\n        this.type = 'timeSignature';\n        if (obj) {\n            if (obj.value) {\n                this.value = obj.value;\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicTimeSignatureInputComponent.prototype = new scope.AbstractMusicInputComponent();\n\n    /**\n     * Constructor property\n     */\n    MusicTimeSignatureInputComponent.prototype.constructor = MusicTimeSignatureInputComponent;\n\n    /**\n     * Get time signature input component value\n     *\n     * @method getValue\n     * @returns {String}\n     */\n    MusicTimeSignatureInputComponent.prototype.getValue = function () {\n        return this.value;\n    };\n\n    /**\n     * Set time signature input component value\n     *\n     * @method setValue\n     * @param {String} value\n     */\n    MusicTimeSignatureInputComponent.prototype.setValue = function (value) {\n        this.value = value;\n    };\n\n    // Export\n    scope.MusicTimeSignatureInputComponent = MusicTimeSignatureInputComponent;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * Represents a staff used for music recognition\n     * default values: count=5, gap=20\n     *\n     * @class MusicStaff\n     * @constructor\n     */\n    function MusicStaff(obj) {\n        this.count = 5;\n        this.gap = 20;\n        if (obj) {\n            if (obj.count) {\n                this.count = obj.count;\n            }\n            if (obj.gap) {\n                this.gap = obj.gap;\n            }\n            if (obj.top) {\n                this.top = obj.top;\n            }\n        }\n    }\n\n    /**\n     * Get the lines count\n     *\n     * @method getCount\n     * @returns {Number}\n     */\n    MusicStaff.prototype.getCount = function () {\n        return this.count;\n    };\n\n    /**\n     * Set the lines count\n     *\n     * @method setCount\n     * @param {Number} count\n     */\n    MusicStaff.prototype.setCount = function (count) {\n        this.count = count;\n    };\n\n    /**\n     * Get the spacing from the top\n     *\n     * @method getTop\n     * @returns {Number}\n     */\n    MusicStaff.prototype.getTop = function () {\n        return this.top;\n    };\n\n    /**\n     * Set the spacing from the top\n     *\n     * @method setTop\n     * @param {Number} top\n     */\n    MusicStaff.prototype.setTop = function (top) {\n        this.top = top;\n    };\n\n    /**\n     * Get the gap between lines\n     *\n     * @method getGap\n     * @returns {Number}\n     */\n    MusicStaff.prototype.getGap = function () {\n        return this.gap;\n    };\n\n    /**\n     * Set the gap between lines\n     *\n     * @method setGap\n     * @param {Number} gap\n     */\n    MusicStaff.prototype.setGap = function (gap) {\n        this.gap = gap;\n    };\n\n    // Export\n    scope.MusicStaff = MusicStaff;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * Parameters used for music recognition\n     *\n     * @class MusicParameter\n     * @extends AbstractParameter\n     * @constructor\n     */\n    function MusicParameter(obj) {\n        scope.AbstractParameter.call(this, obj);\n        this.resultTypes = [];\n        this.userResources = [];\n        if (obj) {\n            if (obj.divisions) {\n                this.divisions = obj.divisions;\n            }\n            if (obj.staff) {\n                this.staff = new scope.MusicStaff(obj.staff);\n            }\n            if (obj.scratchOutDetectionSensitivity) {\n                this.scratchOutDetectionSensitivity = obj.scratchOutDetectionSensitivity;\n            }\n            if (obj.userResources) {\n                this.userResources = obj.userResources;\n            }\n            if (obj.resultTypes) {\n                this.resultTypes = obj.resultTypes;\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicParameter.prototype = new scope.AbstractParameter();\n\n    /**\n     * Constructor property\n     */\n    MusicParameter.prototype.constructor = MusicParameter;\n\n    /**\n     * Get the music result types (e.g. MusicXML, ScoreTree)\n     *\n     * @method getResultTypes\n     * @returns {Array}\n     */\n    MusicParameter.prototype.getResultTypes = function () {\n        return this.resultTypes;\n    };\n\n    /**\n     * Set the music result types (e.g. MusicXML, ScoreTree)\n     *\n     * @method setResultTypes\n     * @param {Array} resultTypes\n     */\n    MusicParameter.prototype.setResultTypes = function (resultTypes) {\n        this.resultTypes = resultTypes;\n    };\n\n    /**\n     * Get the user resources\n     *\n     * @method getUserResources\n     * @returns {Array}\n     */\n    MusicParameter.prototype.getUserResources = function () {\n        return this.userResources;\n    };\n\n    /**\n     * Set the user resources\n     *\n     * @method setUserResources\n     * @param {Array} userResources\n     */\n    MusicParameter.prototype.setUserResources = function (userResources) {\n        this.userResources = userResources;\n    };\n\n    /**\n     * Get the sensitivity of the scratch-out detection\n     *\n     * @method getScratchOutDetectionSensitivity\n     * @returns {Number}\n     */\n    MusicParameter.prototype.getScratchOutDetectionSensitivity = function () {\n        return this.scratchOutDetectionSensitivity;\n    };\n\n    /**\n     * Set the sensitivity of the scratch-out detection\n     *\n     * @method setScratchOutDetectionSensitivity\n     * @param {Number} scratchOutDetectionSensitivity\n     */\n    MusicParameter.prototype.setScratchOutDetectionSensitivity = function (scratchOutDetectionSensitivity) {\n        this.scratchOutDetectionSensitivity = scratchOutDetectionSensitivity;\n    };\n\n    /**\n     * Get the staff\n     *\n     * @method getStaff\n     * @returns {MusicStaff}\n     */\n    MusicParameter.prototype.getStaff = function () {\n        return this.staff;\n    };\n\n    /**\n     * Set the staff\n     *\n     * @method setStaff\n     * @param {MusicStaff} staff\n     */\n    MusicParameter.prototype.setStaff = function (staff) {\n        this.staff = staff;\n    };\n\n    /**\n     * Get the number of divisions\n     *\n     * @method getDivisions\n     * @returns {Number}\n     */\n    MusicParameter.prototype.getDivisions = function () {\n        return this.divisions;\n    };\n\n    /**\n     * Set the number of divisions\n     *\n     * @method setDivisions\n     * @param {Number} divisions\n     */\n    MusicParameter.prototype.setDivisions = function (divisions) {\n        this.divisions = divisions;\n    };\n\n    // Export\n    scope.MusicParameter = MusicParameter;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * Recognition input object for music recognition\n     *\n     * @class MusicRecognitionInput\n     * @extends AbstractRecognitionInput\n     * @constructor\n     */\n    function MusicRecognitionInput() {\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicRecognitionInput.prototype = new scope.AbstractRecognitionInput();\n\n    /**\n     * Constructor property\n     */\n    MusicRecognitionInput.prototype.constructor = MusicRecognitionInput;\n\n    /**\n     * Get parameters\n     *\n     * @method getParameters\n     * @returns {MusicParameter}\n     */\n    MusicRecognitionInput.prototype.getParameters = function () {\n        return new MusicParameter({\n            divisions: this.divisions,\n            staff: this.staff,\n            scratchOutDetectionSensitivity: this.scratchOutDetectionSensitivity,\n            resultTypes: this.resultTypes,\n            userResources: this.userResources\n        });\n    };\n\n    /**\n     * Set parameters\n     *\n     * @method setParameters\n     * @param {MusicParameter} parameters\n     */\n    MusicRecognitionInput.prototype.setParameters = function (parameters) {\n        if (parameters) {\n            this.divisions = parameters.getDivisions();\n            this.staff = parameters.getStaff();\n            this.scratchOutDetectionSensitivity = parameters.getScratchOutDetectionSensitivity();\n            this.resultTypes = parameters.getResultTypes();\n            this.userResources = parameters.getUserResources();\n        }\n    };\n\n    /**\n     * Get input components\n     *\n     * @method getComponents\n     * @returns {AbstractComponent[]}\n     */\n    MusicRecognitionInput.prototype.getComponents = function () {\n        return this.components;\n    };\n\n    /**\n     * Set input components\n     *\n     * @method setComponents\n     * @param {AbstractComponent[]} components\n     */\n    MusicRecognitionInput.prototype.setComponents = function (components) {\n        this.components = components;\n    };\n\n    // Export\n    scope.MusicRecognitionInput = MusicRecognitionInput;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * Recognition data for music input\n     *\n     * @class MusicRecognitionData\n     * @extends AbstractRecognitionData\n     * @constructor\n     */\n    function MusicRecognitionData() {\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicRecognitionData.prototype = new scope.AbstractRecognitionData();\n\n    /**\n     * Constructor property\n     */\n    MusicRecognitionData.prototype.constructor = MusicRecognitionData;\n\n    /**\n     * Get music input\n     *\n     * @method getRecognitionInput\n     * @returns {MusicRecognitionInput}\n     */\n    MusicRecognitionData.prototype.getRecognitionInput = function () {\n        return this.musicInput;\n    };\n\n    /**\n     * Set music input\n     *\n     * @method setRecognitionInput\n     * @param {MusicRecognitionInput} input\n     */\n    MusicRecognitionData.prototype.setRecognitionInput = function (input) {\n        this.musicInput = JSON.stringify(input);\n    };\n\n    // Export\n    scope.MusicRecognitionData = MusicRecognitionData;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * Parameters used for analyzer recognition\n     *\n     * @class AnalyzerParameter\n     * @extends AbstractParameter\n     * @constructor\n     */\n    function AnalyzerParameter(obj) {\n        scope.AbstractParameter.call(this, obj);\n        this.textParameter = new scope.TextParameter();\n        this.textParameter.setLanguage('en_US');\n        this.textParameter.setInputMode('CURSIVE');\n        if (obj) {\n            if (obj.coordinateResolution) {\n                this.coordinateResolution = obj.coordinateResolution;\n            }\n            if (obj.textParameter) {\n                this.textParameter = new scope.TextParameter(obj.textParameter);\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    AnalyzerParameter.prototype = new scope.AbstractParameter();\n\n    /**\n     * Constructor property\n     */\n    AnalyzerParameter.prototype.constructor = AnalyzerParameter;\n\n    /**\n     * Get text recognition parameters\n     *\n     * @method getTextParameters\n     * @returns {TextParameter}\n     */\n    AnalyzerParameter.prototype.getTextParameters = function () {\n        return this.textParameter;\n    };\n\n    /**\n     * Set text recognition parameters\n     *\n     * @method setTextParameters\n     * @param {TextParameter} parameters\n     */\n    AnalyzerParameter.prototype.setTextParameters = function (parameters) {\n        this.textParameter = parameters;\n    };\n\n    /**\n     * Get analyzer coordinate resolution\n     *\n     * @method getCoordinateResolution\n     * @returns {Number}\n     */\n    AnalyzerParameter.prototype.getCoordinateResolution = function () {\n        return this.coordinateResolution;\n    };\n\n    /**\n     * Set analyzer coordinate resolution\n     *\n     * @method setCoordinateResolution\n     * @param {Number} coordinateResolution\n     */\n    AnalyzerParameter.prototype.setCoordinateResolution = function (coordinateResolution) {\n        this.coordinateResolution = coordinateResolution;\n    };\n\n    // Export\n    scope.AnalyzerParameter = AnalyzerParameter;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * Recognition input object for analyzer recognition\n     *\n     * @class AnalyzerRecognitionInput\n     * @extends AbstractRecognitionInput\n     * @constructor\n     */\n    function AnalyzerRecognitionInput() {\n\n    }\n\n    /**\n     * Inheritance property\n     */\n    AnalyzerRecognitionInput.prototype = new scope.AbstractRecognitionInput();\n\n    /**\n     * Constructor property\n     */\n    AnalyzerRecognitionInput.prototype.constructor = AnalyzerRecognitionInput;\n\n    /**\n     * Get analyzer recognition parameters\n     *\n     * @method getParameters\n     * @returns {AnalyzerParameter}\n     */\n    AnalyzerRecognitionInput.prototype.getParameters = function () {\n        return this.parameter;\n    };\n\n    /**\n     * Set analyzer recognition parameters\n     *\n     * @method setParameters\n     * @param {AnalyzerParameter} parameters\n     */\n    AnalyzerRecognitionInput.prototype.setParameters = function (parameters) {\n        this.parameter = parameters;\n    };\n\n    /**\n     * Get input components\n     *\n     * @method getComponents\n     * @returns {AbstractComponent[]}\n     */\n    AnalyzerRecognitionInput.prototype.getComponents = function () {\n        return this.components;\n    };\n\n    /**\n     * Set input components\n     *\n     * @method setComponents\n     * @param {AbstractComponent[]} components\n     */\n    AnalyzerRecognitionInput.prototype.setComponents = function (components) {\n        this.components = components;\n    };\n\n    // Export\n    scope.AnalyzerRecognitionInput = AnalyzerRecognitionInput;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Recognition data for analyzer input\n     *\n     * @class AnalyzerRecognitionData\n     * @extends AbstractRecognitionData\n     * @constructor\n     */\n    function AnalyzerRecognitionData() {\n    }\n\n    /**\n     * Inheritance property\n     */\n    AnalyzerRecognitionData.prototype = new scope.AbstractRecognitionData();\n\n    /**\n     * Constructor property\n     */\n    AnalyzerRecognitionData.prototype.constructor = AnalyzerRecognitionData;\n\n    /**\n     * Get analyzer input\n     *\n     * @method getRecognitionInput\n     * @returns {AnalyzerRecognitionInput}\n     */\n    AnalyzerRecognitionData.prototype.getRecognitionInput = function () {\n        return this.analyzerInput;\n    };\n\n    /**\n     * Set analyzer input\n     *\n     * @method setRecognitionInput\n     * @param {AnalyzerRecognitionInput} input\n     */\n    AnalyzerRecognitionData.prototype.setRecognitionInput = function (input) {\n        this.analyzerInput = JSON.stringify(input);\n    };\n\n    // Export\n    scope.AnalyzerRecognitionData = AnalyzerRecognitionData;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * Abstract result\n     *\n     * @class AbstractResult\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function AbstractResult(obj) {\n        if (obj) {\n            this.instanceId = obj.instanceId;\n        }\n    }\n\n    /**\n     * Get instance id\n     *\n     * @method getInstanceId\n     * @returns {String}\n     */\n    AbstractResult.prototype.getInstanceId = function () {\n        return this.instanceId;\n    };\n\n    /**\n     * Get document\n     *\n     * @method getDocument\n     * @returns {TextDocument|ShapeDocument|MathDocument|MusicDocument|AnalyzerDocument}\n     */\n    AbstractResult.prototype.getDocument = function () {\n        return this.result;\n    };\n\n    // Export\n    scope.AbstractResult = AbstractResult;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * WebSocket recognition text result message\n     *\n     * @class AbstractRecoResponseWSMessage\n     * @extends AbstractWSMessage\n     * @param {Object} [obj] Recognition WebSocket message\n     * @constructor\n     */\n    function AbstractRecoResponseWSMessage(obj) {\n        scope.AbstractWSMessage.call(this, obj);\n        if (obj) {\n            this.instanceId = obj.instanceId;\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    AbstractRecoResponseWSMessage.prototype = new scope.AbstractWSMessage();\n\n    /**\n     * Constructor property\n     */\n    AbstractRecoResponseWSMessage.prototype.constructor = AbstractRecoResponseWSMessage;\n\n    /**\n     * Get instance id\n     *\n     * @method getInstanceId\n     * @returns {String}\n     */\n    AbstractRecoResponseWSMessage.prototype.getInstanceId = function () {\n        return this.instanceId;\n    };\n\n    /**\n     * Get document\n     *\n     * @method getDocument\n     * @returns {TextDocument|ShapeDocument|MathDocument|MusicDocument|AnalyzerDocument}\n     */\n    AbstractRecoResponseWSMessage.prototype.getDocument = function () {\n        return this.result;\n    };\n\n    // Export\n    scope.AbstractRecoResponseWSMessage = AbstractRecoResponseWSMessage;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * WebSocket recognition hmac challenge message\n     *\n     * @class ChallengeResponseWSMessage\n     * @extends AbstractWSMessage\n     * @param {Object} [obj] Recognition WebSocket message\n     * @constructor\n     */\n    function ChallengeResponseWSMessage(obj) {\n        scope.AbstractWSMessage.call(this, obj);\n        if (obj) {\n            this.challenge = obj.challenge;\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    ChallengeResponseWSMessage.prototype = new scope.AbstractWSMessage();\n\n    /**\n     * Constructor property\n     */\n    ChallengeResponseWSMessage.prototype.constructor = ChallengeResponseWSMessage;\n\n    /**\n     * Get the challenge\n     *\n     * @method getChallenge\n     * @returns {String}\n     */\n    ChallengeResponseWSMessage.prototype.getChallenge = function () {\n        return this.challenge;\n    };\n\n    // Export\n    scope.ChallengeResponseWSMessage = ChallengeResponseWSMessage;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * WebSocket recognition error message\n     *\n     * @class ErrorResponseWSMessage\n     * @extends AbstractWSMessage\n     * @param {Object} [obj] Recognition WebSocket message\n     * @constructor\n     */\n    function ErrorResponseWSMessage(obj) {\n        scope.AbstractWSMessage.call(this, obj);\n        if (obj) {\n            this.error = obj.error;\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    ErrorResponseWSMessage.prototype = new scope.AbstractWSMessage();\n\n    /**\n     * Constructor property\n     */\n    ErrorResponseWSMessage.prototype.constructor = ErrorResponseWSMessage;\n\n    /**\n     * Get the error\n     *\n     * @method getError\n     * @returns {String}\n     */\n    ErrorResponseWSMessage.prototype.getError = function () {\n        return this.error;\n    };\n\n    // Export\n    scope.ErrorResponseWSMessage = ErrorResponseWSMessage;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * WebSocket recognition init message\n     *\n     * @class InitResponseWSMessage\n     * @extends AbstractWSMessage\n     * @param {Object} [obj] Recognition WebSocket message\n     * @constructor\n     */\n    function InitResponseWSMessage(obj) {\n        scope.AbstractWSMessage.call(this, obj);\n    }\n\n    /**\n     * Inheritance property\n     */\n    InitResponseWSMessage.prototype = new scope.AbstractWSMessage();\n\n    /**\n     * Constructor property\n     */\n    InitResponseWSMessage.prototype.constructor = InitResponseWSMessage;\n\n    // Export\n    scope.InitResponseWSMessage = InitResponseWSMessage;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * WebSocket recognition reset message\n     *\n     * @class ResetResponseWSMessage\n     * @extends AbstractWSMessage\n     * @param {Object} [obj] Recognition WebSocket message\n     * @constructor\n     */\n    function ResetResponseWSMessage(obj) {\n        scope.AbstractWSMessage.call(this, obj);\n    }\n\n    /**\n     * Inheritance property\n     */\n    ResetResponseWSMessage.prototype = new scope.AbstractWSMessage();\n\n    /**\n     * Constructor property\n     */\n    ResetResponseWSMessage.prototype.constructor = ResetResponseWSMessage;\n\n    // Export\n    scope.ResetResponseWSMessage = ResetResponseWSMessage;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Text ink ranges\n     *\n     * @class TextInkRange\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function TextInkRange(obj) {\n        if (obj) {\n            if (typeof obj === 'string') {\n                var cpt = obj.split(/[:-]+/);\n                this.startUnit = Number(cpt[0]);\n                this.startComponent = Number(cpt[1]);\n                this.startPoint = Number(cpt[2]);\n                this.endUnit = Number(cpt[3]);\n                this.endComponent = Number(cpt[4]);\n                this.endPoint = Number(cpt[5]);\n            } else {\n                this.startUnit = obj.startUnit;\n                this.startComponent = obj.startComponent;\n                this.startPoint = obj.startPoint;\n                this.endUnit = obj.endUnit;\n                this.endComponent = obj.endComponent;\n                this.endPoint = obj.endPoint;\n            }\n        }\n    }\n\n    /**\n     * Get start unit\n     *\n     * @method getStartUnit\n     * @returns {Number}\n     */\n    TextInkRange.prototype.getStartUnit = function () {\n        return this.startUnit;\n    };\n\n    /**\n     * Get end unit\n     *\n     * @method getEndUnit\n     * @returns {Number}\n     */\n    TextInkRange.prototype.getEndUnit = function () {\n        return this.endUnit;\n    };\n\n    /**\n     * Get start component\n     *\n     * @method getStartComponent\n     * @returns {Number}\n     */\n    TextInkRange.prototype.getStartComponent = function () {\n        return this.startComponent;\n    };\n\n    /**\n     * Get end component\n     *\n     * @method getEndComponent\n     * @returns {Number}\n     */\n    TextInkRange.prototype.getEndComponent = function () {\n        return this.endComponent;\n    };\n\n    /**\n     * Get start point\n     *\n     * @method getStartPoint\n     * @returns {Number}\n     */\n    TextInkRange.prototype.getStartPoint = function () {\n        return this.startPoint;\n    };\n\n    /**\n     * Get end point\n     *\n     * @method getEndPoint\n     * @returns {Number}\n     */\n    TextInkRange.prototype.getEndPoint = function () {\n        return this.endPoint;\n    };\n\n    // Export\n    scope.TextInkRange = TextInkRange;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * Text candidate\n     *\n     * @class TextCandidate\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function TextCandidate(obj) {\n        this.flags = [];\n        this.children = [];\n        if (obj) {\n            this.label = obj.label;\n            this.normalizedScore = obj.normalizedScore;\n            this.spellingDistortionRatio = obj.spellingDistortionRatio;\n            for (var i in obj.flags) {\n                this.flags.push(obj.flags[i]);\n            }\n            for (var j in obj.children) {\n                this.children.push(new scope.TextSegment(obj.children[j]));\n            }\n        }\n    }\n\n    /**\n     * Get label\n     *\n     * @method getLabel\n     * @returns {String}\n     */\n    TextCandidate.prototype.getLabel = function () {\n        return this.label;\n    };\n\n    /**\n     * Get normalized score\n     *\n     * @method getNormalizedScore\n     * @returns {Number}\n     */\n    TextCandidate.prototype.getNormalizedScore = function () {\n        return this.normalizedScore;\n    };\n\n    /**\n     * Get resemblance score\n     *\n     * @method getResemblanceScore\n     * @returns {Number}\n     */\n    TextCandidate.prototype.getResemblanceScore = function () {\n        return this.resemblanceScore;\n    };\n\n    /**\n     * Get spelling distortion ratio\n     *\n     * @method getSpellingDistortionRatio\n     * @returns {Number}\n     */\n    TextCandidate.prototype.getSpellingDistortionRatio = function () {\n        return this.spellingDistortionRatio;\n    };\n\n    /**\n     * Get flags\n     *\n     * @method getFlags\n     * @returns {Array}\n     */\n    TextCandidate.prototype.getFlags = function () {\n        return this.flags;\n    };\n\n    /**\n     * Get children\n     *\n     * @method getChildren\n     * @returns {TextSegment[]}\n     */\n    TextCandidate.prototype.getChildren = function () {\n        return this.children;\n    };\n\n    // Export\n    scope.TextCandidate = TextCandidate;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Text document\n     *\n     * @class TextDocument\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function TextDocument(obj) {\n        this.tagItems = [];\n        this.wordSegments = [];\n        this.charSegments = [];\n        if (obj) {\n            if (obj.textSegmentResult) {\n                this.textSegmentResult = new scope.TextSegment(obj.textSegmentResult);\n            }\n            for (var i in obj.tagItems) {\n                this.tagItems.push(new scope.TextTagItem(obj.tagItems[i]));\n            }\n            for (var j in obj.wordSegments) {\n                this.wordSegments.push(new scope.TextSegment(obj.wordSegments[j]));\n            }\n            for (var k in obj.charSegments) {\n                this.charSegments.push(new scope.TextSegment(obj.charSegments[k]));\n            }\n            /**\n             * @deprecated\n             */\n            for (var l in obj.wordCandidates) {\n                this.wordSegments.push(new scope.TextSegment(obj.wordCandidates[l]));\n            }\n            /**\n             * @deprecated\n             */\n            for (var m in obj.charCandidates) {\n                this.charSegments.push(new scope.TextSegment(obj.charCandidates[m]));\n            }\n        }\n    }\n\n    /**\n     * Get tag items\n     *\n     * @method getTagItems\n     * @returns {TextTagItem[]}\n     */\n    TextDocument.prototype.getTagItems = function () {\n        return this.tagItems;\n    };\n\n    /**\n     * Get word segments\n     *\n     * @method getWordSegments\n     * @returns {TextSegment[]}\n     */\n    TextDocument.prototype.getWordSegments = function () {\n        return this.wordSegments;\n    };\n\n    /**\n     * Get word segment\n     *\n     * @method getWordSegment\n     * @param {TextInkRange[]} inkRanges\n     * @returns {TextSegment}\n     */\n    TextDocument.prototype.getWordSegment = function (inkRanges) {\n        for (var i = 0; i < this.getWordSegments().length; i++) {\n            if (JSON.stringify(this.getWordSegments()[i].getInkRanges()) === JSON.stringify(inkRanges)) {\n                return this.getWordSegments()[i];\n            }\n        }\n        return undefined;\n    };\n\n    /**\n     * Get char segments\n     *\n     * @method getCharSegments\n     * @returns {TextSegment[]}\n     */\n    TextDocument.prototype.getCharSegments = function () {\n        return this.charSegments;\n    };\n\n    /**\n     * Get char segment\n     *\n     * @method getCharSegment\n     * @param {TextInkRange[]} inkRanges\n     * @returns {TextSegment}\n     */\n    TextDocument.prototype.getCharSegment = function (inkRanges) {\n        for (var i = 0; i < this.getCharSegments().length; i++) {\n            if (JSON.stringify(this.getCharSegments()[i].getInkRanges()) === JSON.stringify(inkRanges)) {\n                return this.getCharSegments()[i];\n            }\n        }\n        return undefined;\n    };\n\n    /**\n     * Get text segment\n     *\n     * @method getTextSegment\n     * @returns {TextSegment}\n     */\n    TextDocument.prototype.getTextSegment = function () {\n        return this.textSegmentResult;\n    };\n\n    /**\n     * Has scratch-out results\n     *\n     * @method hasScratchOutResults\n     * @returns {Boolean}\n     */\n    TextDocument.prototype.hasScratchOutResults = function () {\n        return false;\n    };\n\n    // Export\n    scope.TextDocument = TextDocument;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * Text result\n     *\n     * @class TextResult\n     * @extends AbstractResult\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function TextResult(obj) {\n        scope.AbstractResult.call(this, obj);\n        if (obj) {\n            this.result = new scope.TextDocument(obj.result);\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    TextResult.prototype = new scope.AbstractResult();\n\n    /**\n     * Constructor property\n     */\n    TextResult.prototype.constructor = TextResult;\n\n    // Export\n    scope.TextResult = TextResult;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * Text segment\n     *\n     * @class TextSegment\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function TextSegment(obj) {\n        this.candidates = [];\n        this.inkRanges = [];\n        if (obj) {\n            this.selectedCandidateIdx = obj.selectedCandidateIdx;\n            if (obj.inkRanges) {\n                var ranges = obj.inkRanges;\n                if (!Array.isArray(ranges)) {\n                    ranges = ranges.split(/[\\s]+/);\n                }\n                for (var j in ranges) {\n                    this.inkRanges.push(new scope.TextInkRange(ranges[j]));\n                }\n            }\n            for (var i in obj.candidates) {\n                this.candidates.push(new scope.TextCandidate(obj.candidates[i]));\n            }\n        }\n    }\n\n    /**\n     * Get candidates\n     *\n     * @method getCandidates\n     * @returns {TextCandidate[]}\n     */\n    TextSegment.prototype.getCandidates = function () {\n        return this.candidates;\n    };\n\n    /**\n     * Get selected candidate index\n     *\n     * @method getSelectedCandidateIdx\n     * @returns {Number}\n     */\n    TextSegment.prototype.getSelectedCandidateIdx = function () {\n        return this.selectedCandidateIdx;\n    };\n\n    /**\n     * Get selected candidate\n     *\n     * @method getSelectedCandidate\n     * @returns {TextCandidate}\n     */\n    TextSegment.prototype.getSelectedCandidate = function () {\n        if ((this.getCandidates().length > 0) && (this.getSelectedCandidateIdx() !== undefined)) {\n            return this.getCandidates()[this.getSelectedCandidateIdx()];\n        } else {\n            return undefined;\n        }\n    };\n\n    /**\n     * Get ink ranges\n     *\n     * @method getInkRanges\n     * @returns {TextInkRange[]}\n     */\n    TextSegment.prototype.getInkRanges = function () {\n        return this.inkRanges;\n    };\n\n    // Export\n    scope.TextSegment = TextSegment;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * Text tag item\n     *\n     * @class TextTagItem\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function TextTagItem(obj) {\n        this.inkRanges = [];\n        if (obj) {\n            this.tagType = obj.tagType;\n            if (obj.inkRanges) {\n                var ranges = obj.inkRanges;\n                if (!Array.isArray(ranges)) {\n                    ranges = ranges.split(/[\\s]+/);\n                }\n                for (var i in ranges) {\n                    this.inkRanges.push(new scope.TextInkRange(ranges[i]));\n                }\n            }\n        }\n    }\n\n    /**\n     * Get tag type\n     *\n     * @method getTagType\n     * @returns {String}\n     */\n    TextTagItem.prototype.getTagType = function () {\n        return this.tagType;\n    };\n\n    /**\n     * Get ink ranges\n     *\n     * @method getInkRanges\n     * @returns {TextInkRange[]}\n     */\n    TextTagItem.prototype.getInkRanges = function () {\n        return this.inkRanges;\n    };\n\n    // Export\n    scope.TextTagItem = TextTagItem;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * WebSocket recognition text result message\n     *\n     * @class TextResponseWSMessage\n     * @extends AbstractRecoResponseWSMessage\n     * @param {Object} [obj] Recognition WebSocket message\n     * @constructor\n     */\n    function TextResponseWSMessage(obj) {\n        scope.AbstractRecoResponseWSMessage.call(this, obj);\n        if (obj) {\n            this.result = new scope.TextDocument(obj.result);\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    TextResponseWSMessage.prototype = new scope.AbstractRecoResponseWSMessage();\n\n    /**\n     * Constructor property\n     */\n    TextResponseWSMessage.prototype.constructor = TextResponseWSMessage;\n\n    // Export\n    scope.TextResponseWSMessage = TextResponseWSMessage;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * Abstract shape primitive\n     *\n     * @class AbstractShapePrimitive\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function AbstractShapePrimitive(obj) {\n        if (obj) {\n            this.type = obj.type;\n            this.beginDecoration = obj.beginDecoration;\n            this.beginTangentAngle = obj.beginTangentAngle;\n            this.endDecoration = obj.endDecoration;\n            this.endTangentAngle = obj.endTangentAngle;\n        }\n    }\n\n    /**\n     * Get type\n     *\n     * @method getType\n     * @returns {String}\n     */\n    AbstractShapePrimitive.prototype.getType = function () {\n        return this.type;\n    };\n\n    /**\n     * Is line\n     *\n     * @method isLine\n     * @returns {Boolean}\n     */\n    AbstractShapePrimitive.prototype.isLine = function () {\n        return this.type === 'line';\n    };\n\n    /**\n     * Is ellipse\n     *\n     * @method isEllipse\n     * @returns {Boolean}\n     */\n    AbstractShapePrimitive.prototype.isEllipse = function () {\n        return this.type === 'ellipse';\n    };\n\n    /**\n     * Has begin decoration\n     *\n     * @method hasBeginDecoration\n     * @returns {Boolean}\n     */\n    AbstractShapePrimitive.prototype.hasBeginDecoration = function () {\n        return typeof this.beginDecoration !== 'undefined';\n    };\n\n    /**\n     * Has end decoration\n     *\n     * @method hasEndDecoration\n     * @returns {Boolean}\n     */\n    AbstractShapePrimitive.prototype.hasEndDecoration = function () {\n        return typeof this.endDecoration !== 'undefined';\n    };\n\n    /**\n     * Get begin decoration\n     *\n     * @method getBeginDecoration\n     * @returns {String}\n     */\n    AbstractShapePrimitive.prototype.getBeginDecoration = function () {\n        return this.beginDecoration;\n    };\n\n    /**\n     * Get end decoration\n     *\n     * @method getEndDecoration\n     * @returns {String}\n     */\n    AbstractShapePrimitive.prototype.getEndDecoration = function () {\n        return this.endDecoration;\n    };\n\n    /**\n     * Get begin tangent angle\n     *\n     * @method getBeginTangentAngle\n     * @returns {Number}\n     */\n    AbstractShapePrimitive.prototype.getBeginTangentAngle = function () {\n        return this.beginTangentAngle;\n    };\n\n    /**\n     * Get end tangent angle\n     *\n     * @method getEndTangentAngle\n     * @returns {Number}\n     */\n    AbstractShapePrimitive.prototype.getEndTangentAngle = function () {\n        return this.endTangentAngle;\n    };\n\n    // Export\n    scope.AbstractShapePrimitive = AbstractShapePrimitive;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Shape candidate\n     *\n     * @class ShapeCandidate\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function ShapeCandidate(obj) {\n        if (obj) {\n            this.type = obj.type;\n        }\n    }\n\n    /**\n     * Get type\n     *\n     * @method getType\n     * @returns {String}\n     */\n    ShapeCandidate.prototype.getType = function () {\n        return this.type;\n    };\n\n    /**\n     * Is erased\n     *\n     * @method isErased\n     * @returns {Boolean}\n     */\n    ShapeCandidate.prototype.isErased = function () {\n        return this.type === 'erased';\n    };\n\n    /**\n     * Is scratch-out\n     *\n     * @method isScratchOut\n     * @returns {Boolean}\n     */\n    ShapeCandidate.prototype.isScratchOut = function () {\n        return this.type === 'scratchOut';\n    };\n\n    /**\n     * Is not recognized\n     *\n     * @method isNotRecognized\n     * @returns {Boolean}\n     */\n    ShapeCandidate.prototype.isNotRecognized = function () {\n        return this.type === 'notRecognized';\n    };\n\n    /**\n     * Is recognized\n     *\n     * @method isRecognized\n     * @returns {Boolean}\n     */\n    ShapeCandidate.prototype.isRecognized = function () {\n        return this.type === 'recognizedShape';\n    };\n\n    // Export\n    scope.ShapeCandidate = ShapeCandidate;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Shape document\n     *\n     * @class ShapeDocument\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function ShapeDocument(obj) {\n        this.segments = [];\n        if (obj) {\n            for (var i in obj.segments) {\n                this.segments.push(new scope.ShapeSegment(obj.segments[i]));\n            }\n        }\n    }\n\n    /**\n     * Get segments\n     *\n     * @method getSegments\n     * @returns {ShapeSegment[]}\n     */\n    ShapeDocument.prototype.getSegments = function () {\n        return this.segments;\n    };\n\n    /**\n     * Get ink ranges\n     *\n     * @method getInkRanges\n     * @returns {ShapeInkRange[]}\n     */\n    ShapeDocument.prototype.getInkRanges = function () {\n        var inkRanges = [];\n        for (var i in this.segments) {\n            inkRanges = inkRanges.concat(this.segments[i].getInkRanges());\n        }\n        return inkRanges;\n    };\n\n    /**\n     * Has scratch-out results\n     *\n     * @method hasScratchOutResults\n     * @returns {Boolean}\n     */\n    ShapeDocument.prototype.hasScratchOutResults = function () {\n        for (var i in this.getSegments()) {\n            var currentSeg = this.getSegments()[i];\n            for (var j in currentSeg.getCandidates()) {\n                var currentCandidate = currentSeg.getCandidates()[j];\n                if (currentCandidate instanceof scope.ShapeScratchOut) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    };\n\n    // Export\n    scope.ShapeDocument = ShapeDocument;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * Shape ellipse\n     *\n     * @class ShapeEllipse\n     * @extends AbstractShapePrimitive\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function ShapeEllipse(obj) {\n        scope.AbstractShapePrimitive.call(this, obj);\n        if (obj) {\n            this.center = new scope.Point(obj.center);\n            this.minRadius = obj.minRadius;\n            this.maxRadius = obj.maxRadius;\n            this.orientation = obj.orientation;\n            this.startAngle = obj.startAngle;\n            this.sweepAngle = obj.sweepAngle;\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    ShapeEllipse.prototype = new scope.AbstractShapePrimitive();\n\n    /**\n     * Constructor property\n     */\n    ShapeEllipse.prototype.constructor = ShapeEllipse;\n\n    /**\n     * Get center\n     *\n     * @method getCenter\n     * @returns {Point}\n     */\n    ShapeEllipse.prototype.getCenter = function () {\n        return this.center;\n    };\n\n    /**\n     * Get min radius\n     *\n     * @method getMinRadius\n     * @returns {Number}\n     */\n    ShapeEllipse.prototype.getMinRadius = function () {\n        return this.minRadius;\n    };\n\n    /**\n     * Get max radius\n     *\n     * @method getMaxRadius\n     * @returns {Number}\n     */\n    ShapeEllipse.prototype.getMaxRadius = function () {\n        return this.maxRadius;\n    };\n\n    /**\n     * Get orientation\n     *\n     * @method getOrientation\n     * @returns {String}\n     */\n    ShapeEllipse.prototype.getOrientation = function () {\n        return this.orientation;\n    };\n\n    /**\n     * Get start angle\n     *\n     * @method getStartAngle\n     * @returns {Number}\n     */\n    ShapeEllipse.prototype.getStartAngle = function () {\n        return this.startAngle;\n    };\n\n    /**\n     * Get sweep angle\n     *\n     * @method getSweepAngle\n     * @returns {Number}\n     */\n    ShapeEllipse.prototype.getSweepAngle = function () {\n        return this.sweepAngle;\n    };\n\n    // Export\n    scope.ShapeEllipse = ShapeEllipse;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Shape erased\n     *\n     * @class ShapeErased\n     * @extends ShapeCandidate\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function ShapeErased(obj) {\n        scope.ShapeCandidate.call(this, obj);\n    }\n\n    /**\n     * Inheritance property\n     */\n    ShapeErased.prototype = new scope.ShapeCandidate();\n\n    /**\n     * Constructor property\n     */\n    ShapeErased.prototype.constructor = ShapeErased;\n\n    // Export\n    scope.ShapeErased = ShapeErased;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Shape ink range\n     *\n     * @class ShapeInkRange\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function ShapeInkRange(obj) {\n        if (obj) {\n            this.firstStroke = obj.firstStroke;\n            this.lastStroke = obj.lastStroke;\n            this.firstPoint = obj.firstPoint;\n            this.lastPoint = obj.lastPoint;\n        }\n    }\n\n    /**\n     * Get first stroke\n     *\n     * @method getFirstStroke\n     * @returns {Number}\n     */\n    ShapeInkRange.prototype.getFirstStroke = function () {\n        return this.firstStroke;\n    };\n\n    /**\n     * Get last stroke\n     *\n     * @method getLastStroke\n     * @returns {Number}\n     */\n    ShapeInkRange.prototype.getLastStroke = function () {\n        return this.lastStroke;\n    };\n\n    /**\n     * Get first point\n     *\n     * @method getFirstPoint\n     * @returns {Number}\n     */\n    ShapeInkRange.prototype.getFirstPoint = function () {\n        return this.firstPoint;\n    };\n\n    /**\n     * Get last point\n     *\n     * @method getLastPoint\n     * @returns {Number}\n     */\n    ShapeInkRange.prototype.getLastPoint = function () {\n        return this.lastPoint;\n    };\n\n    // Export\n    scope.ShapeInkRange = ShapeInkRange;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Shape line\n     *\n     * @class ShapeLine\n     * @extends AbstractShapePrimitive\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function ShapeLine(obj) {\n        scope.AbstractShapePrimitive.call(this, obj);\n        if (obj) {\n            this.firstPoint = new scope.Point(obj.firstPoint);\n            this.lastPoint = new scope.Point(obj.lastPoint);\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    ShapeLine.prototype = new scope.AbstractShapePrimitive();\n\n    /**\n     * Constructor property\n     */\n    ShapeLine.prototype.constructor = ShapeLine;\n\n    /**\n     * Get first point\n     *\n     * @method getFirstPoint\n     * @returns {Point}\n     */\n    ShapeLine.prototype.getFirstPoint = function () {\n        return this.firstPoint;\n    };\n\n    /**\n     * Get last point\n     *\n     * @method getLastPoint\n     * @returns {Point}\n     */\n    ShapeLine.prototype.getLastPoint = function () {\n        return this.lastPoint;\n    };\n\n    // Export\n    scope.ShapeLine = ShapeLine;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Shape not recognized\n     *\n     * @class ShapeNotRecognized\n     * @extends ShapeCandidate\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function ShapeNotRecognized(obj) {\n        scope.ShapeCandidate.call(this, obj);\n    }\n\n    /**\n     * Inheritance property\n     */\n    ShapeNotRecognized.prototype = new scope.ShapeCandidate();\n\n    /**\n     * Constructor property\n     */\n    ShapeNotRecognized.prototype.constructor = ShapeNotRecognized;\n\n    // Export\n    scope.ShapeNotRecognized = ShapeNotRecognized;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Shape recognized\n     *\n     * @class ShapeRecognized\n     * @extends ShapeCandidate\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function ShapeRecognized(obj) {\n        scope.ShapeCandidate.call(this, obj);\n        this.primitives = [];\n        if (obj) {\n            this.label = obj.label;\n            this.normalizedRecognitionScore = obj.normalizedRecognitionScore;\n            this.resemblanceScore = obj.resemblanceScore;\n            for (var i in obj.primitives) {\n                switch (obj.primitives[i].type) {\n                    case 'line':\n                        this.primitives.push(new scope.ShapeLine(obj.primitives[i]));\n                        break;\n                    case 'ellipse':\n                        this.primitives.push(new scope.ShapeEllipse(obj.primitives[i]));\n                        break;\n                    default:\n                        throw new Error('Unknown shape primitive');\n                }\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    ShapeRecognized.prototype = new scope.ShapeCandidate();\n\n    /**\n     * Constructor property\n     */\n    ShapeRecognized.prototype.constructor = ShapeRecognized;\n\n    /**\n     * Get primitives\n     *\n     * @method getPrimitives\n     * @returns {AbstractShapePrimitive[]}\n     */\n    ShapeRecognized.prototype.getPrimitives = function () {\n        return this.primitives;\n    };\n\n    /**\n     * Get label\n     *\n     * @method getLabel\n     * @returns {String}\n     */\n    ShapeRecognized.prototype.getLabel = function () {\n        return this.label;\n    };\n\n    /**\n     * Get normalized score\n     *\n     * @method getNormalizedRecognitionScore\n     * @returns {Number}\n     */\n    ShapeRecognized.prototype.getNormalizedRecognitionScore = function () {\n        return this.normalizedRecognitionScore;\n    };\n\n    /**\n     * Get resemblance score\n     *\n     * @method getResemblanceScore\n     * @returns {Number}\n     */\n    ShapeRecognized.prototype.getResemblanceScore = function () {\n        return this.resemblanceScore;\n    };\n\n    // Export\n    scope.ShapeRecognized = ShapeRecognized;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Shape result\n     *\n     * @class ShapeResult\n     * @extends AbstractResult\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function ShapeResult(obj) {\n        scope.AbstractResult.call(this, obj);\n        if (obj) {\n            this.result = new scope.ShapeDocument(obj.result);\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    ShapeResult.prototype = new scope.AbstractResult();\n\n    /**\n     * Constructor property\n     */\n    ShapeResult.prototype.constructor = ShapeResult;\n\n    // Export\n    scope.ShapeResult = ShapeResult;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * Shape scratch-out\n     *\n     * @class ShapeScratchOut\n     * @extends ShapeCandidate\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function ShapeScratchOut(obj) {\n        scope.ShapeCandidate.call(this, obj);\n        this.inkRanges = [];\n        if (obj) {\n            for (var j in obj.inkRanges) {\n                this.inkRanges.push(new scope.ShapeInkRange(obj.inkRanges[j]));\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    ShapeScratchOut.prototype = new scope.ShapeCandidate();\n\n    /**\n     * Constructor property\n     */\n    ShapeScratchOut.prototype.constructor = ShapeScratchOut;\n\n    /**\n     * Get ink ranges\n     *\n     * @method getInkRanges\n     * @returns {ShapeInkRange[]}\n     */\n    ShapeScratchOut.prototype.getInkRanges = function () {\n        return this.inkRanges;\n    };\n\n    // Export\n    scope.ShapeScratchOut = ShapeScratchOut;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Shape segment\n     *\n     * @class ShapeSegment\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function ShapeSegment(obj) {\n        this.inkRanges = [];\n        this.candidates = [];\n        if (obj) {\n            this.elementType = obj.elementType;\n            this.uniqueID = obj.uniqueID;\n            this.selectedCandidateIndex = obj.selectedCandidateIndex;\n            for (var i in obj.candidates) {\n                switch (obj.candidates[i].type) {\n                    case 'erased':\n                        this.candidates.push(new scope.ShapeErased(obj.candidates[i]));\n                        break;\n                    case 'scratchOut':\n                        this.candidates.push(new scope.ShapeScratchOut(obj.candidates[i]));\n                        break;\n                    case 'recognizedShape':\n                        this.candidates.push(new scope.ShapeRecognized(obj.candidates[i]));\n                        break;\n                    default:\n                        this.candidates.push(new scope.ShapeNotRecognized(obj.candidates[i]));\n                        break;\n                }\n            }\n            for (var j in obj.inkRanges) {\n                this.inkRanges.push(new scope.ShapeInkRange(obj.inkRanges[j]));\n            }\n        }\n    }\n\n    /**\n     * Get element type\n     *\n     * @method getElementType\n     * @returns {String}\n     */\n    ShapeSegment.prototype.getElementType = function () {\n        return this.elementType;\n    };\n\n    /**\n     * Get unique id\n     *\n     * @method getUniqueId\n     * @returns {String}\n     */\n    ShapeSegment.prototype.getUniqueId = function () {\n        return this.uniqueID;\n    };\n\n    /**\n     * Get ink ranges\n     *\n     * @method getInkRanges\n     * @returns {ShapeInkRange[]}\n     */\n    ShapeSegment.prototype.getInkRanges = function () {\n        return this.inkRanges;\n    };\n\n    /**\n     * Get selected candidate index\n     *\n     * @method getSelectedCandidateIdx\n     * @returns {Number}\n     */\n    ShapeSegment.prototype.getSelectedCandidateIdx = function () {\n        return this.selectedCandidateIndex;\n    };\n\n    /**\n     * Get candidates\n     *\n     * @method getCandidates\n     * @returns {ShapeCandidate[]}\n     */\n    ShapeSegment.prototype.getCandidates = function () {\n        return this.candidates;\n    };\n\n    /**\n     * Get selected candidate\n     *\n     * @method getSelectedCandidate\n     * @returns {ShapeCandidate}\n     */\n    ShapeSegment.prototype.getSelectedCandidate = function () {\n        if ((this.getCandidates().length > 0) && (this.getSelectedCandidateIdx() !== undefined)) {\n            return this.getCandidates()[this.getSelectedCandidateIdx()];\n        } else {\n            return undefined;\n        }\n    };\n\n    // Export\n    scope.ShapeSegment = ShapeSegment;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Math node\n     *\n     * @class MathNode\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MathNode(obj) {\n        if (obj) {\n            this.name = obj.name;\n            this.type = obj.type;\n        }\n    }\n\n    /**\n     * Get name\n     *\n     * @method getName\n     * @returns {String}\n     */\n    MathNode.prototype.getName = function () {\n        return this.name;\n    };\n\n    /**\n     * Get type\n     *\n     * @method getType\n     * @returns {String}\n     */\n    MathNode.prototype.getType = function () {\n        return this.type;\n    };\n\n    // Export\n    scope.MathNode = MathNode;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Math non-terminal node\n     *\n     * @class MathNonTerminalNode\n     * @extends MathNode\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MathNonTerminalNode(obj) {\n        scope.MathNode.call(this, obj);\n        this.candidates = [];\n        if (obj) {\n            this.selectedCandidate = obj.selectedCandidate;\n            for (var i in obj.candidates) {\n                switch (obj.candidates[i].type) {\n                    case 'nonTerminalNode':\n                        this.candidates.push(new scope.MathNonTerminalNode(obj.candidates[i]));\n                        break;\n                    case 'terminalNode':\n                        this.candidates.push(new scope.MathTerminalNode(obj.candidates[i]));\n                        break;\n                    case 'rule':\n                        this.candidates.push(new scope.MathRuleNode(obj.candidates[i]));\n                        break;\n                    case 'cell':\n                        this.candidates.push(new scope.MathCellNonTerminalNode(obj.candidates[i]));\n                        break;\n                    case 'border':\n                        this.candidates.push(new scope.MathBorderNonTerminalNode(obj.candidates[i]));\n                        break;\n                    case 'table':\n                        this.candidates.push(new scope.MathTableRuleNode(obj.candidates[i]));\n                        break;\n                    default:\n                        throw new Error('Unknown math node type: ' + obj.candidates[i].type);\n                }\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MathNonTerminalNode.prototype = new scope.MathNode();\n\n    /**\n     * Constructor property\n     */\n    MathNonTerminalNode.prototype.constructor = MathNonTerminalNode;\n\n    /**\n     * Get candidates\n     *\n     * @method getCandidates\n     * @returns {MathNode[]}\n     */\n    MathNonTerminalNode.prototype.getCandidates = function () {\n        return this.candidates;\n    };\n\n    /**\n     * Get selected candidate index\n     *\n     * @method getSelectedCandidateIdx\n     * @returns {Number}\n     */\n    MathNonTerminalNode.prototype.getSelectedCandidateIdx = function () {\n        return this.selectedCandidate;\n    };\n\n    /**\n     * Get selected candidate\n     *\n     * @method getSelectedCandidate\n     * @returns {MathNode}\n     */\n    MathNonTerminalNode.prototype.getSelectedCandidate = function () {\n        if ((this.getCandidates().length > 0) && (this.getSelectedCandidateIdx() !== undefined)) {\n            return this.getCandidates()[this.getSelectedCandidateIdx()];\n        } else {\n            return undefined;\n        }\n    };\n\n    /**\n     * Get ink ranges\n     *\n     * @method getInkRanges\n     * @returns {MathInkRange[]}\n     */\n    MathNonTerminalNode.prototype.getInkRanges = function () {\n        if (this.getSelectedCandidate()) {\n            return this.getSelectedCandidate().getInkRanges();\n        } else {\n            throw new Error('No selected candidate');\n        }\n    };\n\n    // Export\n    scope.MathNonTerminalNode = MathNonTerminalNode;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * Abstract math result\n     *\n     * @class MathResultElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MathResultElement(obj) {\n        if (obj) {\n            this.type = obj.type;\n        }\n    }\n\n    /**\n     * Get type\n     *\n     * @method getType\n     * @returns {String}\n     */\n    MathResultElement.prototype.getType = function () {\n        return this.type;\n    };\n\n    /**\n     * Is LaTeX result\n     *\n     * @method isLatex\n     * @returns {Boolean}\n     */\n    MathResultElement.prototype.isLaTex = function () {\n        return this.type === 'LATEX';\n    };\n\n    /**\n     * Is MathML result\n     *\n     * @method isMathMl\n     * @returns {Boolean}\n     */\n    MathResultElement.prototype.isMathMl = function () {\n        return this.type === 'MATHML';\n    };\n\n    /**\n     * Is SymbolTree result\n     *\n     * @method isSymbolTree\n     * @returns {Boolean}\n     */\n    MathResultElement.prototype.isSymbolTree = function () {\n        return this.type === 'SYMBOLTREE';\n    };\n\n    // Export\n    scope.MathResultElement = MathResultElement;\n})(MyScript);\n(function (scope) {\n    \n    /**\n     * Math rule node\n     *\n     * @class MathRuleNode\n     * @extends MathNode\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MathRuleNode(obj) {\n        scope.MathNode.call(this, obj);\n        this.children = [];\n        if (obj) {\n            this.name = obj.name;\n            for (var i in obj.children) {\n                switch (obj.children[i].type) {\n                    case 'nonTerminalNode':\n                        this.children.push(new scope.MathNonTerminalNode(obj.children[i]));\n                        break;\n                    case 'terminalNode':\n                        this.children.push(new scope.MathTerminalNode(obj.children[i]));\n                        break;\n                    case 'rule':\n                        this.children.push(new scope.MathRuleNode(obj.children[i]));\n                        break;\n                    case 'cell':\n                        this.children.push(new scope.MathCellNonTerminalNode(obj.children[i]));\n                        break;\n                    case 'border':\n                        this.children.push(new scope.MathBorderNonTerminalNode(obj.children[i]));\n                        break;\n                    case 'table':\n                        this.children.push(new scope.MathTableRuleNode(obj.children[i]));\n                        break;\n                    default:\n                        throw new Error('Unknown math node type: ' + obj.children[i].type);\n                }\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MathRuleNode.prototype = new scope.MathNode();\n\n    /**\n     * Constructor property\n     */\n    MathRuleNode.prototype.constructor = MathRuleNode;\n\n    /**\n     * Get name\n     *\n     * @method getName\n     * @returns {String}\n     */\n    MathRuleNode.prototype.getName = function () {\n        return this.name;\n    };\n\n    /**\n     * Get children\n     *\n     * @method getChildren\n     * @returns {MathNode[]}\n     */\n    MathRuleNode.prototype.getChildren = function () {\n        return this.children;\n    };\n\n    /**\n     * Get ink ranges\n     *\n     * @method getInkRanges\n     * @returns {MathInkRange[]}\n     */\n    MathRuleNode.prototype.getInkRanges = function () {\n        var inkRanges = [];\n        for (var i in this.getChildren()) {\n            var childInkRanges = this.getChildren()[i].getInkRanges();\n            for (var j in childInkRanges) {\n                inkRanges.push(childInkRanges[j]);\n            }\n        }\n        return inkRanges;\n    };\n\n    // Export\n    scope.MathRuleNode = MathRuleNode;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Math document\n     *\n     * @class MathDocument\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MathDocument(obj) {\n        this.results = [];\n        this.scratchOutResults = [];\n        if (obj) {\n            for (var i in obj.results) {\n                var result = obj.results[i];\n                switch (result.type) {\n                    case 'MATHML':\n                        this.results.push(new scope.MathMathMLResultElement(result));\n                        break;\n                    case 'LATEX':\n                        this.results.push(new scope.MathLaTexResultElement(result));\n                        break;\n                    case 'SYMBOLTREE':\n                        this.results.push(new scope.MathSymbolTreeResultElement(result));\n                        break;\n                    case 'OFFICEOPENXMLMATH':\n                        this.results.push(new scope.MathOfficeOpenXmlMathResultElement(result));\n                        break;\n                    default:\n                        throw new Error('Unknown math result type: ' + result.type);\n                }\n            }\n            for (var j in obj.scratchOutResults) {\n                this.scratchOutResults.push(new scope.MathScratchOut(obj.scratchOutResults[j]));\n            }\n        }\n    }\n\n    /**\n     * Get result elements\n     *\n     * @method getResultElements\n     * @returns {MathResultElement[]}\n     */\n    MathDocument.prototype.getResultElements = function () {\n        return this.results;\n    };\n\n    /**\n     * Get scratch-out results\n     *\n     * @method getScratchOutResults\n     * @returns {MathScratchOut[]}\n     */\n    MathDocument.prototype.getScratchOutResults = function () {\n        return this.scratchOutResults;\n    };\n\n    /**\n     * Has scratch-out results\n     *\n     * @method hasScratchOutResults\n     * @returns {Boolean}\n     */\n    MathDocument.prototype.hasScratchOutResults = function () {\n        if (this.getScratchOutResults() && (this.getScratchOutResults().length > 0)) {\n            return true;\n        }\n        return false;\n    };\n\n    // Export\n    scope.MathDocument = MathDocument;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * Math ink range\n     *\n     * @class MathInkRange\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MathInkRange(obj) {\n        if (obj) {\n            this.component = obj.component;\n            this.firstItem = obj.firstItem;\n            this.lastItem = obj.lastItem;\n        }\n    }\n\n    /**\n     * Get component\n     *\n     * @method getComponent\n     * @returns {Number}\n     */\n    MathInkRange.prototype.getComponent = function () {\n        return this.component;\n    };\n\n    /**\n     * Get first item\n     *\n     * @method getFirstItem\n     * @returns {Number}\n     */\n    MathInkRange.prototype.getFirstItem = function () {\n        return this.firstItem;\n    };\n\n    /**\n     * Get last item\n     *\n     * @method getLastItem\n     * @returns {Number}\n     */\n    MathInkRange.prototype.getLastItem = function () {\n        return this.lastItem;\n    };\n\n    // Export\n    scope.MathInkRange = MathInkRange;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * MathOfficeOpenXmlMathResultElement result element\n     *\n     * @class MathOfficeOpenXmlMathResultElement\n     * @extends MathResultElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MathOfficeOpenXmlMathResultElement(obj) {\n        scope.MathResultElement.call(this, obj);\n        if (obj) {\n            this.value = obj.value;\n        }\n    }\n\n\n    /**\n     * Inheritance property\n     */\n    MathOfficeOpenXmlMathResultElement.prototype = new scope.MathResultElement();\n\n    /**\n     * Constructor property\n     */\n    MathOfficeOpenXmlMathResultElement.prototype.constructor = MathOfficeOpenXmlMathResultElement;\n\n    /**\n     * Get value\n     *\n     * @method getValue\n     * @returns {String}\n     */\n    MathOfficeOpenXmlMathResultElement.prototype.getValue = function () {\n        return this.value;\n    };\n\n    // Export\n    scope.MathOfficeOpenXmlMathResultElement = MathOfficeOpenXmlMathResultElement;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * LaTex result element\n     *\n     * @class MathLaTexResultElement\n     * @extends MathResultElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MathLaTexResultElement(obj) {\n        scope.MathResultElement.call(this, obj);\n        if (obj) {\n            this.value = obj.value;\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MathLaTexResultElement.prototype = new scope.MathResultElement();\n\n    /**\n     * Constructor property\n     */\n    MathLaTexResultElement.prototype.constructor = MathLaTexResultElement;\n\n    /**\n     * Get value\n     *\n     * @method getValue\n     * @returns {String}\n     */\n    MathLaTexResultElement.prototype.getValue = function () {\n        return this.value;\n    };\n\n    // Export\n    scope.MathLaTexResultElement = MathLaTexResultElement;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * MathML result element\n     *\n     * @class MathMathMLResultElement\n     * @extends MathResultElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MathMathMLResultElement(obj) {\n        scope.MathResultElement.call(this, obj);\n        if (obj) {\n            this.value = obj.value;\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MathMathMLResultElement.prototype = new scope.MathResultElement();\n\n    /**\n     * Constructor property\n     */\n    MathMathMLResultElement.prototype.constructor = MathMathMLResultElement;\n\n    /**\n     * Get value\n     *\n     * @method getValue\n     * @returns {String}\n     */\n    MathMathMLResultElement.prototype.getValue = function () {\n        return this.value;\n    };\n\n    // Export\n    scope.MathMathMLResultElement = MathMathMLResultElement;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Math result\n     *\n     * @class MathResult\n     * @extends AbstractResult\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MathResult(obj) {\n        scope.AbstractResult.call(this, obj);\n        if (obj) {\n            this.result = new scope.MathDocument(obj.result);\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MathResult.prototype = new scope.AbstractResult();\n\n    /**\n     * Constructor property\n     */\n    MathResult.prototype.constructor = MathResult;\n\n    // Export\n    scope.MathResult = MathResult;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * Math scratch-out\n     *\n     * @class MathScratchOut\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MathScratchOut(obj) {\n        this.inkRanges = [];\n        this.erasedInkRanges = [];\n        if (obj) {\n            for (var i in obj.inkRanges) {\n                this.inkRanges.push(new scope.MathInkRange(obj.inkRanges[i]));\n            }\n            for (var j in obj.erasedInkRanges) {\n                this.erasedInkRanges.push(new scope.MathInkRange(obj.erasedInkRanges[j]));\n            }\n        }\n    }\n\n    /**\n     * Get ink ranges\n     *\n     * @method getInkRanges\n     * @returns {MathInkRange[]}\n     */\n    MathScratchOut.prototype.getInkRanges = function () {\n        return this.inkRanges;\n    };\n\n    /**\n     * Get erased ink ranges\n     *\n     * @method getErasedInkRanges\n     * @returns {MathInkRange[]}\n     */\n    MathScratchOut.prototype.getErasedInkRanges = function () {\n        return this.erasedInkRanges;\n    };\n\n    // Export\n    scope.MathScratchOut = MathScratchOut;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Math symbol tree\n     *\n     * @class MathSymbolTreeResultElement\n     * @extends MathResultElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MathSymbolTreeResultElement(obj) {\n        scope.MathResultElement.call(this, obj);\n        if (obj) {\n            if (obj.root) {\n                switch (obj.root.type) {\n                    case 'nonTerminalNode':\n                        this.root = new scope.MathNonTerminalNode(obj.root);\n                        break;\n                    case 'terminalNode':\n                        this.root = new scope.MathTerminalNode(obj.root);\n                        break;\n                    case 'rule':\n                        this.root = new scope.MathRuleNode(obj.root);\n                        break;\n                    case 'cell':\n                        this.root = new scope.MathCellNonTerminalNode(obj.root);\n                        break;\n                    case 'border':\n                        this.root = new scope.MathBorderNonTerminalNode(obj.root);\n                        break;\n                    case 'table':\n                        this.root = new scope.MathTableRuleNode(obj.root);\n                        break;\n                    default:\n                        throw new Error('Unknown math node type: ' + obj.root.type);\n                }\n                this.value = JSON.stringify(obj.root, null, '  ');\n            } else {\n                throw new Error('Missing root');\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MathSymbolTreeResultElement.prototype = new scope.MathResultElement();\n\n    /**\n     * Constructor property\n     */\n    MathSymbolTreeResultElement.prototype.constructor = MathSymbolTreeResultElement;\n\n    /**\n     * Get tree root\n     *\n     * @method getRoot\n     * @returns {MathNode}\n     */\n    MathSymbolTreeResultElement.prototype.getRoot = function () {\n        return this.root;\n    };\n\n    /**\n     * Get ink ranges\n     *\n     * @method getInkRanges\n     * @returns {MathInkRange[]}\n     */\n    MathSymbolTreeResultElement.prototype.getInkRanges = function () {\n        if (this.getRoot()) {\n            return this.getRoot().getInkRanges();\n        } else {\n            throw new Error('No selected candidate');\n        }\n    };\n\n    /**\n    * Get value\n    *\n    * @method getValue\n    * @returns {String}\n    */\n    MathSymbolTreeResultElement.prototype.getValue = function () {\n        return this.value;\n    };\n\n    // Export\n    scope.MathSymbolTreeResultElement = MathSymbolTreeResultElement;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * Math terminal node\n     *\n     * @class MathTerminalNode\n     * @extends MathNode\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MathTerminalNode(obj) {\n        scope.MathNode.call(this, obj);\n        this.candidates = [];\n        this.inkRanges = [];\n        if (obj) {\n            this.selectedCandidate = obj.selectedCandidate;\n            for (var i in obj.candidates) {\n                this.candidates.push(new scope.MathTerminalNodeCandidate(obj.candidates[i]));\n            }\n            for (var j in obj.inkRanges) {\n                this.inkRanges.push(new scope.MathInkRange(obj.inkRanges[j]));\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MathTerminalNode.prototype = new scope.MathNode();\n\n    /**\n     * Constructor property\n     */\n    MathTerminalNode.prototype.constructor = MathTerminalNode;\n\n    /**\n     * Get candidates\n     *\n     * @method getCandidates\n     * @returns {MathTerminalNodeCandidate[]}\n     */\n    MathTerminalNode.prototype.getCandidates = function () {\n        return this.candidates;\n    };\n\n    /**\n     * Get ink ranges\n     *\n     * @method getInkRanges\n     * @returns {MathInkRange[]}\n     */\n    MathTerminalNode.prototype.getInkRanges = function () {\n        return this.inkRanges;\n    };\n\n    /**\n     * Get selected candidate index\n     *\n     * @method getSelectedCandidateIdx\n     * @returns {Number}\n     */\n    MathTerminalNode.prototype.getSelectedCandidateIdx = function () {\n        return this.selectedCandidate;\n    };\n\n    /**\n     * Get selected candidate\n     *\n     * @method getSelectedCandidate\n     * @returns {MathTerminalNodeCandidate}\n     */\n    MathTerminalNode.prototype.getSelectedCandidate = function () {\n        if ((this.getCandidates().length > 0) && (this.getSelectedCandidateIdx() !== undefined)) {\n            return this.getCandidates()[this.getSelectedCandidateIdx()];\n        } else {\n            return undefined;\n        }\n    };\n\n    // Export\n    scope.MathTerminalNode = MathTerminalNode;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * Math terminal node candidate\n     *\n     * @class MathTerminalNodeCandidate\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MathTerminalNodeCandidate(obj) {\n        if (obj) {\n            this.label = obj.label;\n            this.normalizedRecognitionScore = obj.normalizedRecognitionScore;\n        }\n    }\n\n    /**\n     * Get label\n     *\n     * @method getLabel\n     * @returns {String}\n     */\n    MathTerminalNodeCandidate.prototype.getLabel = function () {\n        return this.label;\n    };\n\n    /**\n     * Get score\n     *\n     * @method getNormalizedRecognitionScore\n     * @returns {Number}\n     */\n    MathTerminalNodeCandidate.prototype.getNormalizedRecognitionScore = function () {\n        return this.normalizedRecognitionScore;\n    };\n\n    // Export\n    scope.MathTerminalNodeCandidate = MathTerminalNodeCandidate;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Math border data\n     *\n     * @class MathBorderData\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MathBorderData(obj) {\n        if (obj) {\n            this.position = obj.position;\n            this.start = obj.start;\n            this.stop = obj.stop;\n            this.type = obj.type;\n        }\n    }\n\n    /**\n     * Get position\n     *\n     * @method getPosition\n     * @returns {Number}\n     */\n    MathBorderData.prototype.getPosition = function () {\n        return this.position;\n    };\n\n    /**\n     * Get start\n     *\n     * @method getStart\n     * @returns {Number}\n     */\n    MathBorderData.prototype.getStart = function () {\n        return this.start;\n    };\n\n    /**\n     * Get stop\n     *\n     * @method getStop\n     * @returns {Number}\n     */\n    MathBorderData.prototype.getStop = function () {\n        return this.stop;\n    };\n\n    /**\n     * Get type\n     *\n     * @method getType\n     * @returns {String}\n     */\n    MathBorderData.prototype.getType = function () {\n        return this.type;\n    };\n\n    // Export\n    scope.MathBorderData = MathBorderData;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * Math border non-terminal node\n     *\n     * @class MathBorderNonTerminalNode\n     * @extends MathNonTerminalNode\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MathBorderNonTerminalNode(obj) {\n        scope.MathNonTerminalNode.call(this, obj);\n        if (obj) {\n            this.data = new scope.MathBorderData(obj.data);\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MathBorderNonTerminalNode.prototype = new scope.MathNonTerminalNode();\n\n    /**\n     * Constructor property\n     */\n    MathBorderNonTerminalNode.prototype.constructor = MathBorderNonTerminalNode;\n\n    /**\n     * Get data\n     *\n     * @method getData\n     * @returns {MathBorderData}\n     */\n    MathBorderNonTerminalNode.prototype.getData = function () {\n        return this.data;\n    };\n\n    // Export\n    scope.MathBorderNonTerminalNode = MathBorderNonTerminalNode;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * Math cell data\n     *\n     * @class MathCellData\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MathCellData(obj) {\n        if (obj) {\n            this.columnStart = obj.columnStart;\n            this.columnStop = obj.columnStop;\n            this.rowStart = obj.rowStart;\n            this.rowStop = obj.rowStop;\n        }\n    }\n\n    /**\n     * Get column start\n     *\n     * @method getColumnStart\n     * @returns {Number}\n     */\n    MathCellData.prototype.getColumnStart = function () {\n        return this.columnStart;\n    };\n\n    /**\n     * Get column stop\n     *\n     * @method getColumnStop\n     * @returns {Number}\n     */\n    MathCellData.prototype.getColumnStop = function () {\n        return this.columnStop;\n    };\n\n    /**\n     * Get row start\n     *\n     * @method getRowStart\n     * @returns {Number}\n     */\n    MathCellData.prototype.getRowStart = function () {\n        return this.rowStart;\n    };\n\n    /**\n     * Get row stop\n     *\n     * @method getRowStop\n     * @returns {Number}\n     */\n    MathCellData.prototype.getRowStop = function () {\n        return this.rowStop;\n    };\n\n    // Export\n    scope.MathCellData = MathCellData;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * Math cell non-terminal node\n     *\n     * @class MathCellNonTerminalNode\n     * @extends MathNonTerminalNode\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MathCellNonTerminalNode(obj) {\n        scope.MathNonTerminalNode.call(this, obj);\n        if (obj) {\n            this.data = new scope.MathCellData(obj.data);\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MathCellNonTerminalNode.prototype = new scope.MathNonTerminalNode();\n\n    /**\n     * Constructor property\n     */\n    MathCellNonTerminalNode.prototype.constructor = MathCellNonTerminalNode;\n\n    /**\n     * Get data\n     *\n     * @method getData\n     * @returns {MathCellData}\n     */\n    MathCellNonTerminalNode.prototype.getData = function () {\n        return this.data;\n    };\n\n    // Export\n    scope.MathCellNonTerminalNode = MathCellNonTerminalNode;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * Math table data\n     *\n     * @class MathTableData\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MathTableData(obj) {\n        if (obj) {\n            this.columnCount = obj.columnCount;\n            this.rowCount = obj.rowCount;\n        }\n    }\n\n    /**\n     * Get column count\n     *\n     * @method getColumnCount\n     * @returns {Number}\n     */\n    MathTableData.prototype.getColumnCount = function () {\n        return this.columnCount;\n    };\n\n    /**\n     * Get row count\n     *\n     * @method getRowCount\n     * @returns {Number}\n     */\n    MathTableData.prototype.getRowCount = function () {\n        return this.rowCount;\n    };\n\n    // Export\n    scope.MathTableData = MathTableData;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * Math table rule node\n     *\n     * @class MathTableRuleNode\n     * @extends MathRuleNode\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MathTableRuleNode(obj) {\n        scope.MathRuleNode.call(this, obj);\n        if (obj) {\n            this.data = new scope.MathTableData(obj.data);\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MathTableRuleNode.prototype = new scope.MathRuleNode();\n\n    /**\n     * Constructor property\n     */\n    MathTableRuleNode.prototype.constructor = MathTableRuleNode;\n\n    /**\n     * Get data\n     *\n     * @method getData\n     * @returns {MathTableData}\n     */\n    MathTableRuleNode.prototype.getData = function () {\n        return this.data;\n    };\n\n    // Export\n    scope.MathTableRuleNode = MathTableRuleNode;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * WebSocket recognition math result message\n     *\n     * @class MathResponseWSMessage\n     * @extends AbstractRecoResponseWSMessage\n     * @param {Object} [obj] Recognition WebSocket message\n     * @constructor\n     */\n    function MathResponseWSMessage(obj) {\n        scope.AbstractRecoResponseWSMessage.call(this, obj);\n        if (obj) {\n            this.result = new scope.MathDocument(obj.result);\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MathResponseWSMessage.prototype = new scope.AbstractRecoResponseWSMessage();\n\n    /**\n     * Constructor property\n     */\n    MathResponseWSMessage.prototype.constructor = MathResponseWSMessage;\n\n    // Export\n    scope.MathResponseWSMessage = MathResponseWSMessage;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * Abstract music element\n     *\n     * @class MusicElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicElement(obj) {\n        if (obj) {\n            this.inputRanges = [];\n            this.elementType = obj.elementType;\n            this.inputRanges = obj.inputRanges;\n        }\n    }\n\n    /**\n     * Get element type\n     *\n     * @method getElementType\n     * @returns {String}\n     */\n    MusicElement.prototype.getElementType = function () {\n        return this.elementType;\n    };\n\n    /**\n     * Get input ranges\n     *\n     * @method getInputRanges\n     * @returns {MusicInputRange[]}\n     */\n    MusicElement.prototype.getInputRanges = function () {\n        return this.inputRanges;\n    };\n\n    // Export\n    scope.MusicElement = MusicElement;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Abstract music result element\n     *\n     * @class MusicResultElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicResultElement(obj) {\n        if (obj) {\n            this.type = obj.type;\n        }\n    }\n\n    /**\n     * Get type\n     *\n     * @method getType\n     * @returns {String}\n     */\n    MusicResultElement.prototype.getType = function () {\n        return this.type;\n    };\n\n    /**\n     * Is MusicXML\n     *\n     * @method isMusicXML\n     * @returns {Boolean}\n     */\n    MusicResultElement.prototype.isMusicXML = function () {\n        return this.type === 'MUSICXML';\n    };\n\n    /**\n     * Is ScoreTree\n     *\n     * @method isScoreTree\n     * @returns {Boolean}\n     */\n    MusicResultElement.prototype.isScoreTree = function () {\n        return this.type === 'SCORETREE';\n    };\n\n    // Export\n    scope.MusicResultElement = MusicResultElement;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Music accidental\n     *\n     * @class MusicAccidental\n     * @extends MusicElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicAccidental(obj) {\n        scope.MusicElement.call(this, obj);\n        if (obj) {\n            this.type = obj.type;\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicAccidental.prototype = new scope.MusicElement();\n\n    /**\n     * Constructor property\n     */\n    MusicAccidental.prototype.constructor = MusicAccidental;\n\n    /**\n     * Get type\n     *\n     * @method getType\n     * @returns {String}\n     */\n    MusicAccidental.prototype.getType = function () {\n        return this.type;\n    };\n\n    // Export\n    scope.MusicAccidental = MusicAccidental;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Music annotation\n     *\n     * @class MusicAnnotation\n     * @extends MusicElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicAnnotation(obj) {\n        scope.MusicElement.call(this, obj);\n        if (obj) {\n            this.label = obj.label;\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicAnnotation.prototype = new scope.MusicElement();\n\n    /**\n     * Constructor property\n     */\n    MusicAnnotation.prototype.constructor = MusicAnnotation;\n\n    /**\n     * Get label\n     *\n     * @method getLabel\n     * @returns {String}\n     */\n    MusicAnnotation.prototype.getLabel = function () {\n        return this.label;\n    };\n\n    // Export\n    scope.MusicAnnotation = MusicAnnotation;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Music arpeggiate\n     *\n     * @class MusicArpeggiate\n     * @extends MusicElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicArpeggiate(obj) {\n        scope.MusicElement.call(this, obj);\n        if (obj) {\n            this.type = obj.type;\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicArpeggiate.prototype = new scope.MusicElement();\n\n    /**\n     * Constructor property\n     */\n    MusicArpeggiate.prototype.constructor = MusicArpeggiate;\n\n    /**\n     * Get type\n     *\n     * @method getType\n     * @returns {String}\n     */\n    MusicArpeggiate.prototype.getType = function () {\n        return this.type;\n    };\n\n    // Export\n    scope.MusicArpeggiate = MusicArpeggiate;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Music bar\n     *\n     * @class MusicBar\n     * @extends MusicElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicBar(obj) {\n        scope.MusicElement.call(this, obj);\n        this.decorations = [];\n        if (obj) {\n            this.repeatDirection = obj.repeatDirection;\n            this.style = obj.style;\n            for (var i in obj.decorations) {\n                this.decorations.push(new scope.MusicDecoration(obj.decorations[i]));\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicBar.prototype = new scope.MusicElement();\n\n    /**\n     * Constructor property\n     */\n    MusicBar.prototype.constructor = MusicBar;\n\n    /**\n     * Get repeat direction\n     *\n     * @method getRepeatDirection\n     * @returns {String}\n     */\n    MusicBar.prototype.getRepeatDirection = function () {\n        return this.repeatDirection;\n    };\n\n    /**\n     * Set repeat direction\n     *\n     * @method setRepeatDirection\n     * @param {String} repeatDirection\n     */\n    MusicBar.prototype.setRepeatDirection = function (repeatDirection) {\n        this.repeatDirection = repeatDirection;\n    };\n\n    /**\n     * Get style\n     *\n     * @method getStyle\n     * @returns {String}\n     */\n    MusicBar.prototype.getStyle = function () {\n        return this.style;\n    };\n\n    /**\n     * Set style\n     *\n     * @method setStyle\n     * @param {String} style\n     */\n    MusicBar.prototype.setStyle = function (style) {\n        this.style = style;\n    };\n\n    /**\n     * Get decorations\n     *\n     * @method getDecorations\n     * @returns {MusicDecoration[]}\n     */\n    MusicBar.prototype.getDecorations = function () {\n        return this.decorations;\n    };\n\n    /**\n     * Set decorations\n     *\n     * @method setDecorations\n     * @param {MusicDecoration[]}\n     */\n    MusicBar.prototype.setDecorations = function (decorations) {\n        this.decorations = decorations;\n    };\n\n    // Export\n    scope.MusicBar = MusicBar;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Music beam\n     *\n     * @class MusicBeam\n     * @extends MusicElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicBeam(obj) {\n        scope.MusicElement.call(this, obj);\n        if (obj) {\n            this.gap = obj.gap;\n            this.slope = obj.slope;\n            this.placement = obj.placement;\n            this.leftCount = obj.leftCount;\n            this.rightCount = obj.rightCount;\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicBeam.prototype = new scope.MusicElement();\n\n    /**\n     * Constructor property\n     */\n    MusicBeam.prototype.constructor = MusicBeam;\n\n    /**\n     * Get gap\n     *\n     * @method getGap\n     * @returns {Number}\n     */\n    MusicBeam.prototype.getGap = function () {\n        return this.gap;\n    };\n\n    /**\n     * Set gap\n     *\n     * @method setGap\n     * @param {Number} gap\n     */\n    MusicBeam.prototype.setGap = function (gap) {\n        this.gap = gap;\n    };\n\n    /**\n     * Get slope\n     *\n     * @method getSlope\n     * @returns {String}\n     */\n    MusicBeam.prototype.getSlope = function () {\n        return this.slope;\n    };\n\n    /**\n     * Set slope\n     *\n     * @method setSlope\n     * @param {String} slope\n     */\n    MusicBeam.prototype.setSlope = function (slope) {\n        this.slope = slope;\n    };\n\n    /**\n     * Get placement\n     *\n     * @method getPlacement\n     * @returns {String}\n     */\n    MusicBeam.prototype.getPlacement = function () {\n        return this.placement;\n    };\n\n    /**\n     * Set placement\n     *\n     * @method setPlacement\n     * @param {String} placement\n     */\n    MusicBeam.prototype.setPlacement = function (placement) {\n        this.placement = placement;\n    };\n\n    /**\n     * Get left count\n     *\n     * @method getLeftCount\n     * @returns {Number}\n     */\n    MusicBeam.prototype.getLeftCount = function () {\n        return this.leftCount;\n    };\n\n    /**\n     * Set left count\n     *\n     * @method setLeftCount\n     * @param {Number} leftCount\n     */\n    MusicBeam.prototype.setLeftCount = function (leftCount) {\n        this.leftCount = leftCount;\n    };\n\n    /**\n     * Get right count\n     *\n     * @method getRightCount\n     * @returns {Number}\n     */\n    MusicBeam.prototype.getRightCount = function () {\n        return this.rightCount;\n    };\n\n    /**\n     * Set right count\n     *\n     * @method setRightCount\n     * @param {Number} rightCount\n     */\n    MusicBeam.prototype.setRightCount = function (rightCount) {\n        this.rightCount = rightCount;\n    };\n\n\n    // Export\n    scope.MusicBeam = MusicBeam;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Music chord\n     *\n     * @class MusicChord\n     * @extends MusicElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicChord(obj) {\n        scope.MusicElement.call(this, obj);\n        this.decorations = [];\n        this.notes = [];\n        this.beamTypes = [];\n        this.ledgerLines = [];\n        this.startSlurs = [];\n        this.stopSlurs = [];\n        if (obj) {\n            this.duration = obj.duration;\n            this.arpeggiate = new scope.MusicArpeggiate(obj.arpeggiate);\n            this.startBeam = new scope.MusicBeam(obj.startBeam);\n            this.stopBeam = new scope.MusicBeam(obj.stopBeam);\n            this.stem = new scope.MusicStem(obj.stem);\n            for (var i in obj.decorations) {\n                this.decorations.push(new scope.MusicDecoration(obj.decorations[i]));\n            }\n            for (var j in obj.notes) {\n                this.notes.push(new scope.MusicNote(obj.notes[j]));\n            }\n            for (var k in obj.beamTypes) {\n                this.beamTypes.push(obj.beamTypes[k]);\n            }\n            for (var l in obj.ledgerLines) {\n                this.ledgerLines.push(new scope.MusicLedgerLine(obj.ledgerLines[l]));\n            }\n            for (var m in obj.startSlurs) {\n                this.startSlurs.push(new scope.MusicSlur(obj.startSlurs[m]));\n            }\n            for (var n in obj.stopSlurs) {\n                this.stopSlurs.push(new scope.MusicSlur(obj.stopSlurs[n]));\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicChord.prototype = new scope.MusicElement();\n\n    /**\n     * Constructor property\n     */\n    MusicChord.prototype.constructor = MusicChord;\n\n    /**\n     * Get duration\n     *\n     * @method getDuration\n     * @returns {Number}\n     */\n    MusicChord.prototype.getDuration = function () {\n        return this.duration;\n    };\n\n    /**\n     * Get arpeggiate\n     *\n     * @method getArpeggiate\n     * @returns {MusicArpeggiate}\n     */\n    MusicChord.prototype.getArpeggiate = function () {\n        return this.arpeggiate;\n    };\n\n    /**\n     * Get start beam\n     *\n     * @method getStartBeam\n     * @returns {MusicBeam}\n     */\n    MusicChord.prototype.getStartBeam = function () {\n        return this.startBeam;\n    };\n\n    /**\n     * Get stop beam\n     *\n     * @method getStopBeam\n     * @returns {MusicBeam}\n     */\n    MusicChord.prototype.getStopBeam = function () {\n        return this.stopBeam;\n    };\n\n    /**\n     * Get stem\n     *\n     * @method getStem\n     * @returns {MusicStem}\n     */\n    MusicChord.prototype.getStem = function () {\n        return this.stem;\n    };\n\n    /**\n     * Get decorations\n     *\n     * @method getDecorations\n     * @returns {MusicDecoration[]}\n     */\n    MusicChord.prototype.getDecorations = function () {\n        return this.decorations;\n    };\n\n    /**\n     * Get notes\n     *\n     * @method getNotes\n     * @returns {MusicNote[]}\n     */\n    MusicChord.prototype.getNotes = function () {\n        return this.notes;\n    };\n\n    /**\n     * Get beam types\n     *\n     * @method getBeamTypes\n     * @returns {Array}\n     */\n    MusicChord.prototype.getBeamTypes = function () {\n        return this.beamTypes;\n    };\n\n    /**\n     * Get ledger lines\n     *\n     * @method getLedgerLines\n     * @returns {MusicLedgerLine[]}\n     */\n    MusicChord.prototype.getLedgerLines = function () {\n        return this.ledgerLines;\n    };\n\n    /**\n     * Get start slurs\n     *\n     * @method getStartSlurs\n     * @returns {MusicSlur[]}\n     */\n    MusicChord.prototype.getStartSlurs = function () {\n        return this.startSlurs;\n    };\n\n    /**\n     * Get stop slurs\n     *\n     * @method getStopSlurs\n     * @returns {MusicSlur[]}\n     */\n    MusicChord.prototype.getStopSlurs = function () {\n        return this.stopSlurs;\n    };\n\n    // Export\n    scope.MusicChord = MusicChord;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Music clef\n     * default values: symbol='G', octave=0\n     *\n     * @class MusicClef\n     * @extends MusicElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicClef(obj) {\n        scope.MusicElement.call(this, obj);\n        this.symbol = 'G';\n        this.octave = 0;\n        if (obj) {\n            this.line = obj.line;\n            this.yAnchor = obj.yAnchor;\n            this.octave = obj.octave;\n            this.symbol = obj.symbol;\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicClef.prototype = new scope.MusicElement();\n\n    /**\n     * Constructor property\n     */\n    MusicClef.prototype.constructor = MusicClef;\n\n    /**\n     * Get y anchor\n     *\n     * @method getYAnchor\n     * @returns {Number}\n     */\n    MusicClef.prototype.getYAnchor = function () {\n        return this.yAnchor;\n    };\n\n    /**\n     * Set y anchor\n     *\n     * @method setYAnchor\n     * @param {Number} yAnchor\n     */\n    MusicClef.prototype.setYAnchor = function (yAnchor) {\n        this.yAnchor = yAnchor;\n    };\n\n    /**\n     * Get line\n     *\n     * @method getLine\n     * @returns {Number}\n     */\n    MusicClef.prototype.getLine = function () {\n        return this.line;\n    };\n\n    /**\n     * Set line\n     *\n     * @method setLine\n     * @param {Number} line\n     */\n    MusicClef.prototype.setLine = function (line) {\n        this.line = line;\n    };\n\n    /**\n     * Get octave\n     *\n     * @method getOctave\n     * @returns {Number}\n     */\n    MusicClef.prototype.getOctave = function () {\n        return this.octave;\n    };\n\n    /**\n     * Set octave\n     *\n     * @method setOctave\n     * @param {Number} octave\n     */\n    MusicClef.prototype.setOctave = function (octave) {\n        this.octave = octave;\n    };\n\n    /**\n     * Get symbol\n     *\n     * @method getSymbol\n     * @returns {String}\n     */\n    MusicClef.prototype.getSymbol = function () {\n        return this.symbol;\n    };\n\n    /**\n     * Set symbol\n     *\n     * @method setSymbol\n     * @param {String} symbol\n     */\n    MusicClef.prototype.setSymbol = function (symbol) {\n        this.symbol = symbol;\n    };\n\n    // Export\n    scope.MusicClef = MusicClef;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Music decoration\n     *\n     * @class MusicDecoration\n     * @extends MusicElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicDecoration(obj) {\n        scope.MusicElement.call(this, obj);\n        if (obj) {\n            this.symbol = obj.symbol;\n            this.placement = obj.placement;\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicDecoration.prototype = new scope.MusicElement();\n\n    /**\n     * Constructor property\n     */\n    MusicDecoration.prototype.constructor = MusicDecoration;\n\n    /**\n     * Get symbol\n     *\n     * @method getSymbol\n     * @returns {String}\n     */\n    MusicDecoration.prototype.getSymbol = function () {\n        return this.symbol;\n    };\n\n    /**\n     * Set symbol\n     *\n     * @method setSymbol\n     * @param {String} symbol\n     */\n    MusicDecoration.prototype.setSymbol = function (symbol) {\n        this.symbol = symbol;\n    };\n\n    /**\n     * Get placement\n     *\n     * @method getPlacement\n     * @returns {String}\n     */\n    MusicDecoration.prototype.getPlacement = function () {\n        return this.placement;\n    };\n\n    /**\n     * Set placement\n     *\n     * @method setPlacement\n     * @param {String} placement\n     */\n    MusicDecoration.prototype.setPlacement = function (placement) {\n        this.placement = placement;\n    };\n\n    // Export\n    scope.MusicDecoration = MusicDecoration;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Music document\n     *\n     * @class MusicDocument\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicDocument(obj) {\n        this.results = [];\n        this.scratchOutResults = [];\n        if (obj) {\n            for (var i in obj.results) {\n                switch (obj.results[i].type) {\n                    case 'MUSICXML':\n                        this.results.push(new scope.MusicXMLResultElement(obj.results[i]));\n                        break;\n                    default:\n                        this.results.push(new scope.MusicScoreTreeResultElement(obj.results[i]));\n                        break;\n                }\n            }\n            for (var j in obj.scratchOutResults) {\n                this.scratchOutResults.push(new scope.MusicScratchOut(obj.scratchOutResults[j]));\n            }\n        }\n    }\n\n    /**\n     * Get result elements\n     *\n     * @method getResultElements\n     * @returns {MusicResultElement[]}\n     */\n    MusicDocument.prototype.getResultElements = function () {\n        return this.results;\n    };\n\n    /**\n     * Get scratch-out results\n     *\n     * @method getScratchOutResults\n     * @returns {MusicScratchOut[]}\n     */\n    MusicDocument.prototype.getScratchOutResults = function () {\n        return this.scratchOutResults;\n    };\n\n    /**\n     * Has scratch-out results\n     *\n     * @method hasScratchOutResults\n     * @returns {Boolean}\n     */\n    MusicDocument.prototype.hasScratchOutResults = function () {\n        if (this.getScratchOutResults() && (this.getScratchOutResults().length > 0)) {\n            return true;\n        }\n        return false;\n    };\n\n    // Export\n    scope.MusicDocument = MusicDocument;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Music dots\n     *\n     * @class MusicDots\n     * @extends MusicElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicDots(obj) {\n        scope.MusicElement.call(this, obj);\n        if (obj) {\n            this.count = obj.count;\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicDots.prototype = new scope.MusicElement();\n\n    /**\n     * Constructor property\n     */\n    MusicDots.prototype.constructor = MusicDots;\n\n    /**\n     * Get dots counts\n     *\n     * @method getCount\n     * @returns {Number}\n     */\n    MusicDots.prototype.getCount = function () {\n        return this.count;\n    };\n\n    // Export\n    scope.MusicDots = MusicDots;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Music head\n     *\n     * @class MusicHead\n     * @extends MusicElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicHead(obj) {\n        scope.MusicElement.call(this, obj);\n        if (obj) {\n            this.type = obj.type;\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicHead.prototype = new scope.MusicElement();\n\n    /**\n     * Constructor property\n     */\n    MusicHead.prototype.constructor = MusicHead;\n\n    /**\n     * Get type\n     *\n     * @method getType\n     * @returns {String}\n     */\n    MusicHead.prototype.getType = function () {\n        return this.type;\n    };\n\n    // Export\n    scope.MusicHead = MusicHead;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Music input range\n     *\n     * @class MusicInputRange\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicInputRange(obj) {\n        if (obj) {\n            this.component = obj.component;\n            this.firstItem = obj.firstItem;\n            this.lastItem = obj.lastItem;\n        }\n    }\n\n    /**\n     * Get component\n     *\n     * @method getComponent\n     * @returns {Number}\n     */\n    MusicInputRange.prototype.getComponent = function () {\n        return this.component;\n    };\n\n    /**\n     * Get first item\n     *\n     * @method getFirstItem\n     * @returns {Number}\n     */\n    MusicInputRange.prototype.getFirstItem = function () {\n        return this.firstItem;\n    };\n\n    /**\n     * Get last item\n     *\n     * @method getLastItem\n     * @returns {Number}\n     */\n    MusicInputRange.prototype.getLastItem = function () {\n        return this.lastItem;\n    };\n\n    // Export\n    scope.MusicInputRange = MusicInputRange;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Music key signature\n     *\n     * @class MusicKeySignature\n     * @extends MusicElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicKeySignature(obj) {\n        scope.MusicElement.call(this, obj);\n        this.accidentals = [];\n        if (obj) {\n            this.signature = new scope.MusicKeySignatureData(obj.signature);\n            for (var i in obj.accidentals) {\n                this.accidentals.push(new scope.MusicAccidental(obj.accidentals[i]));\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicKeySignature.prototype = new scope.MusicElement();\n\n    /**\n     * Constructor property\n     */\n    MusicKeySignature.prototype.constructor = MusicKeySignature;\n\n    /**\n     * Get signature\n     *\n     * @method getSignature\n     * @returns {MusicKeySignatureData}\n     */\n    MusicKeySignature.prototype.getSignature = function () {\n        return this.signature;\n    };\n\n    /**\n     * Get accidentals\n     *\n     * @method getAccidentals\n     * @returns {MusicAccidental[]}\n     */\n    MusicKeySignature.prototype.getAccidentals = function () {\n        return this.accidentals;\n    };\n\n    // Export\n    scope.MusicKeySignature = MusicKeySignature;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Music key signature data\n     *\n     * @class MusicKeySignatureData\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicKeySignatureData(obj) {\n        if (obj) {\n            this.fifths = obj.fifths;\n            this.cancel = obj.cancel;\n        }\n    }\n\n    /**\n     * Get fifths\n     *\n     * @method getFifths\n     * @returns {Number}\n     */\n    MusicKeySignatureData.prototype.getFifths = function () {\n        return this.fifths;\n    };\n\n    /**\n     * Get cancel\n     *\n     * @method getCancel\n     * @returns {Number}\n     */\n    MusicKeySignatureData.prototype.getCancel = function () {\n        return this.cancel;\n    };\n\n    // Export\n    scope.MusicKeySignatureData = MusicKeySignatureData;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Music ledger line\n     *\n     * @class MusicLedgerLine\n     * @extends MusicElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicLedgerLine(obj) {\n        scope.MusicElement.call(this, obj);\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicLedgerLine.prototype = new scope.MusicElement();\n\n    /**\n     * Constructor property\n     */\n    MusicLedgerLine.prototype.constructor = MusicLedgerLine;\n\n    // Export\n    scope.MusicLedgerLine = MusicLedgerLine;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Music note\n     *\n     * @class MusicNote\n     * @extends MusicElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicNote(obj) {\n        scope.MusicElement.call(this, obj);\n        this.decorations = [];\n        this.beamTypes = [];\n        this.ledgerLines = [];\n        this.startSlurs = [];\n        this.stopSlurs = [];\n        if (obj) {\n            this.accidental = new scope.MusicAccidental(obj.accidental);\n            this.dots = new scope.MusicDots(obj.dots);\n            this.duration = obj.duration;\n            this.head = new scope.MusicHead(obj.head);\n            this.line = obj.line;\n            this.pitch = new scope.MusicPitchData(obj.pitch);\n            this.startBeam = new scope.MusicBeam(obj.startBeam);\n            this.stopBeam = new scope.MusicBeam(obj.stopBeam);\n            this.stem = new scope.MusicStem(obj.stem);\n            this.startTie = new scope.MusicTie(obj.startTie);\n            this.stopTie = new scope.MusicTie(obj.stopTie);\n            this.startTuplet = new scope.MusicTuplet(obj.startTuplet);\n            this.stopTuplet = new scope.MusicTuplet(obj.stopTuplet);\n            this.timeModification = new scope.MusicTimeModificationData(obj.timeModification);\n            this.type = obj.type;\n            for (var i in obj.decorations) {\n                this.decorations.push(new scope.MusicDecoration(obj.decorations[i]));\n            }\n            for (var j in obj.beamTypes) {\n                this.beamTypes.push(obj.beamTypes[j]);\n            }\n            for (var k in obj.ledgerLines) {\n                this.ledgerLines.push(new scope.MusicLedgerLine(obj.ledgerLines[k]));\n            }\n            for (var l in obj.startSlurs) {\n                this.startSlurs.push(new scope.MusicSlur(obj.startSlurs[l]));\n            }\n            for (var m in obj.stopSlurs) {\n                this.stopSlurs.push(new scope.MusicSlur(obj.stopSlurs[m]));\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicNote.prototype = new scope.MusicElement();\n\n    /**\n     * Constructor property\n     */\n    MusicNote.prototype.constructor = MusicNote;\n\n    /**\n     * Get accidental\n     *\n     * @method getAccidental\n     * @returns {MusicAccidental}\n     */\n    MusicNote.prototype.getAccidental = function () {\n        return this.accidental;\n    };\n\n    /**\n     * Get dots\n     *\n     * @method getDots\n     * @returns {MusicDots}\n     */\n    MusicNote.prototype.getDots = function () {\n        return this.dots;\n    };\n\n    /**\n     * Get duration\n     *\n     * @method getDuration\n     * @returns {Number}\n     */\n    MusicNote.prototype.getDuration = function () {\n        return this.duration;\n    };\n\n    /**\n     * Get head\n     *\n     * @method getHead\n     * @returns {MusicHead}\n     */\n    MusicNote.prototype.getHead = function () {\n        return this.head;\n    };\n\n    /**\n     * Get line\n     *\n     * @method getLine\n     * @returns {Number}\n     */\n    MusicNote.prototype.getLine = function () {\n        return this.line;\n    };\n\n    /**\n     * Get pitch\n     *\n     * @method getPitch\n     * @returns {MusicPitchData}\n     */\n    MusicNote.prototype.getPitch = function () {\n        return this.pitch;\n    };\n\n    /**\n     * Get start beam\n     *\n     * @method getStartBeam\n     * @returns {MusicBeam}\n     */\n    MusicNote.prototype.getStartBeam = function () {\n        return this.startBeam;\n    };\n\n    /**\n     * Get stop beam\n     *\n     * @method getStopBeam\n     * @returns {MusicBeam}\n     */\n    MusicNote.prototype.getStopBeam = function () {\n        return this.stopBeam;\n    };\n\n    /**\n     * Get stem\n     *\n     * @method getStem\n     * @returns {MusicStem}\n     */\n    MusicNote.prototype.getStem = function () {\n        return this.stem;\n    };\n\n    /**\n     * Get start tie\n     *\n     * @method getStartTie\n     * @returns {MusicTie}\n     */\n    MusicNote.prototype.getStartTie = function () {\n        return this.startTie;\n    };\n\n    /**\n     * Get stop tie\n     *\n     * @method getStopTie\n     * @returns {MusicTie}\n     */\n    MusicNote.prototype.getStopTie = function () {\n        return this.stopTie;\n    };\n\n    /**\n     * Get start tuplet\n     *\n     * @method getStartTuplet\n     * @returns {MusicTuplet}\n     */\n    MusicNote.prototype.getStartTuplet = function () {\n        return this.startTuplet;\n    };\n\n    /**\n     * Get stop tuplet\n     *\n     * @method getStopTuplet\n     * @returns {MusicTuplet}\n     */\n    MusicNote.prototype.getStopTuplet = function () {\n        return this.stopTuplet;\n    };\n\n    /**\n     * Get time modification\n     *\n     * @method getTimeModification\n     * @returns {MusicTimeModificationData}\n     */\n    MusicNote.prototype.getTimeModification = function () {\n        return this.timeModification;\n    };\n\n    /**\n     * Get type\n     *\n     * @method getType\n     * @returns {String}\n     */\n    MusicNote.prototype.getType = function () {\n        return this.type;\n    };\n\n    /**\n     * Get decorations\n     *\n     * @method getDecorations\n     * @returns {MusicDecoration[]}\n     */\n    MusicNote.prototype.getDecorations = function () {\n        return this.decorations;\n    };\n\n    /**\n     * Get beam types\n     *\n     * @method getBeamTypes\n     * @returns {Array}\n     */\n    MusicNote.prototype.getBeamTypes = function () {\n        return this.beamTypes;\n    };\n\n    /**\n     * Get ledger lines\n     *\n     * @method getLedgerLines\n     * @returns {MusicLedgerLine[]}\n     */\n    MusicNote.prototype.getLedgerLines = function () {\n        return this.ledgerLines;\n    };\n\n    /**\n     * Get start slurs\n     *\n     * @method getStartSlurs\n     * @returns {MusicSlur[]}\n     */\n    MusicNote.prototype.getStartSlurs = function () {\n        return this.startSlurs;\n    };\n\n    /**\n     * Get stop slurs\n     *\n     * @method getStopSlurs\n     * @returns {MusicSlur[]}\n     */\n    MusicNote.prototype.getStopSlurs = function () {\n        return this.stopSlurs;\n    };\n\n    // Export\n    scope.MusicNote = MusicNote;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Music part\n     *\n     * @class MusicPart\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicPart(obj) {\n        this.elements = [];\n        if (obj) {\n            for (var i in obj.elements) {\n                switch (obj.elements[i].elementType) {\n                    case 'accidental':\n                        this.elements.push(new scope.MusicAccidental(obj.elements[i]));\n                        break;\n                    case 'annotation':\n                        this.elements.push(new scope.MusicAnnotation(obj.elements[i]));\n                        break;\n                    case 'arpeggiate':\n                        this.elements.push(new scope.MusicArpeggiate(obj.elements[i]));\n                        break;\n                    case 'bar':\n                        this.elements.push(new scope.MusicBar(obj.elements[i]));\n                        break;\n                    case 'beam':\n                        this.elements.push(new scope.MusicBeam(obj.elements[i]));\n                        break;\n                    case 'chord':\n                        this.elements.push(new scope.MusicChord(obj.elements[i]));\n                        break;\n                    case 'clef':\n                        this.elements.push(new scope.MusicClef(obj.elements[i]));\n                        break;\n                    case 'decoration':\n                        this.elements.push(new scope.MusicDecoration(obj.elements[i]));\n                        break;\n                    case 'dots':\n                        this.elements.push(new scope.MusicDots(obj.elements[i]));\n                        break;\n                    case 'head':\n                        this.elements.push(new scope.MusicHead(obj.elements[i]));\n                        break;\n                    case 'keySignature':\n                        this.elements.push(new scope.MusicKeySignature(obj.elements[i]));\n                        break;\n                    case 'ledgerLine':\n                        this.elements.push(new scope.MusicLedgerLine(obj.elements[i]));\n                        break;\n                    case 'note':\n                        this.elements.push(new scope.MusicNote(obj.elements[i]));\n                        break;\n                    case 'rest':\n                        this.elements.push(new scope.MusicRest(obj.elements[i]));\n                        break;\n                    case 'slur':\n                        this.elements.push(new scope.MusicSlur(obj.elements[i]));\n                        break;\n                    case 'stem':\n                        this.elements.push(new scope.MusicStem(obj.elements[i]));\n                        break;\n                    case 'tie':\n                        this.elements.push(new scope.MusicTie(obj.elements[i]));\n                        break;\n                    case 'timeSignature':\n                        this.elements.push(new scope.MusicTimeSignature(obj.elements[i]));\n                        break;\n                    case 'tuplet':\n                        this.elements.push(new scope.MusicTuplet(obj.elements[i]));\n                        break;\n                    case 'tupletBracket':\n                        this.elements.push(new scope.MusicTupletBracket(obj.elements[i]));\n                        break;\n                    default:\n                        throw new Error('Unknown music element');\n                }\n            }\n        }\n    }\n\n    /**\n     * Get elements\n     *\n     * @method getElements\n     * @returns {MusicElement[]}\n     */\n    MusicPart.prototype.getElements = function () {\n        return this.elements;\n    };\n\n    // Export\n    scope.MusicPart = MusicPart;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Music pitch data\n     *\n     * @class MusicPitchData\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicPitchData(obj) {\n        if (obj) {\n            this.alteration = obj.alteration;\n            this.octave = obj.octave;\n            this.step = obj.step;\n        }\n    }\n\n    /**\n     * Get alteration\n     *\n     * @method getAlteration\n     * @returns {Number}\n     */\n    MusicPitchData.prototype.getAlteration = function () {\n        return this.alteration;\n    };\n\n    /**\n     * Get octave\n     *\n     * @method getOctave\n     * @returns {Number}\n     */\n    MusicPitchData.prototype.getOctave = function () {\n        return this.octave;\n    };\n\n    /**\n     * Get step\n     *\n     * @method getStep\n     * @returns {String}\n     */\n    MusicPitchData.prototype.getStep = function () {\n        return this.step;\n    };\n\n    // Export\n    scope.MusicPitchData = MusicPitchData;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Music rest\n     *\n     * @class MusicRest\n     * @extends MusicElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicRest(obj) {\n        scope.MusicElement.call(this, obj);\n        this.decorations = [];\n        this.startSlurs = [];\n        this.stopSlurs = [];\n        if (obj) {\n            this.type = obj.type;\n            this.dots = new scope.MusicDots(obj.dots);\n            this.startTuplet = new scope.MusicTuplet(obj.startTuplet);\n            this.stopTuplet = new scope.MusicTuplet(obj.stopTuplet);\n            this.timeModification = new scope.MusicTimeModificationData(obj.timeModification);\n            this.duration = obj.duration;\n            for (var i in obj.decorations) {\n                this.decorations.push(new scope.MusicDecoration(obj.decorations[i]));\n            }\n            for (var l in obj.startSlurs) {\n                this.startSlurs.push(new scope.MusicSlur(obj.startSlurs[l]));\n            }\n            for (var m in obj.stopSlurs) {\n                this.stopSlurs.push(new scope.MusicSlur(obj.stopSlurs[m]));\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicRest.prototype = new scope.MusicElement();\n\n    /**\n     * Constructor property\n     */\n    MusicRest.prototype.constructor = MusicRest;\n\n    /**\n     * Get type\n     *\n     * @method getType\n     * @returns {String}\n     */\n    MusicRest.prototype.getType = function () {\n        return this.type;\n    };\n\n    /**\n     * Get dots\n     *\n     * @method getDots\n     * @returns {MusicDots}\n     */\n    MusicRest.prototype.getDots = function () {\n        return this.dots;\n    };\n\n    /**\n     * Get start tuplet\n     *\n     * @method getStartTuplet\n     * @returns {MusicTuplet}\n     */\n    MusicRest.prototype.getStartTuplet = function () {\n        return this.startTuplet;\n    };\n\n    /**\n     * Get stop tuplet\n     *\n     * @method getStopTuplet\n     * @returns {MusicTuplet}\n     */\n    MusicRest.prototype.getStopTuplet = function () {\n        return this.stopTuplet;\n    };\n\n    /**\n     * Get time modification\n     *\n     * @method getTimeModification\n     * @returns {MusicTimeModificationData}\n     */\n    MusicRest.prototype.getTimeModification = function () {\n        return this.timeModification;\n    };\n\n    /**\n     * Get duration\n     *\n     * @method getDuration\n     * @returns {Number}\n     */\n    MusicRest.prototype.getDuration = function () {\n        return this.duration;\n    };\n\n    /**\n     * Get decorations\n     *\n     * @method getDecorations\n     * @returns {MusicDecoration[]}\n     */\n    MusicRest.prototype.getDecorations = function () {\n        return this.decorations;\n    };\n\n    /**\n     * Get start slurs\n     *\n     * @method getStartSlurs\n     * @returns {MusicSlur[]}\n     */\n    MusicRest.prototype.getStartSlurs = function () {\n        return this.startSlurs;\n    };\n\n    /**\n     * Get stop slurs\n     *\n     * @method getStopSlurs\n     * @returns {MusicSlur[]}\n     */\n    MusicRest.prototype.getStopSlurs = function () {\n        return this.stopSlurs;\n    };\n\n    // Export\n    scope.MusicRest = MusicRest;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Music result\n     *\n     * @class MusicResult\n     * @extends AbstractResult\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicResult(obj) {\n        scope.AbstractResult.call(this, obj);\n        if (obj) {\n            this.result = new scope.MusicDocument(obj.result);\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicResult.prototype = new scope.AbstractResult();\n\n    /**\n     * Constructor property\n     */\n    MusicResult.prototype.constructor = MusicResult;\n\n    // Export\n    scope.MusicResult = MusicResult;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * Music score\n     *\n     * @class MusicScore\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicScore(obj) {\n        this.parts = [];\n        if (obj) {\n            for (var i in obj.parts) {\n                this.parts.push(new scope.MusicPart(obj.parts[i]));\n            }\n        }\n    }\n\n    /**\n     * Get parts\n     *\n     * @method getParts\n     * @returns {MusicPart[]}\n     */\n    MusicScore.prototype.getParts = function () {\n        return this.parts;\n    };\n\n    // Export\n    scope.MusicScore = MusicScore;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Music score tree\n     *\n     * @class MusicScoreTreeResultElement\n     * @extends MusicResultElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicScoreTreeResultElement(obj) {\n        scope.MusicResultElement.call(this, obj);\n        if (obj) {\n            this.score = new scope.MusicScore(obj.score);\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicScoreTreeResultElement.prototype = new scope.MusicResultElement();\n\n    /**\n     * Constructor property\n     */\n    MusicScoreTreeResultElement.prototype.constructor = MusicScoreTreeResultElement;\n\n    /**\n     * Get score\n     *\n     * @method getScore\n     * @returns {MusicScore}\n     */\n    MusicScoreTreeResultElement.prototype.getScore = function () {\n        return this.score;\n    };\n\n    // Export\n    scope.MusicScoreTreeResultElement = MusicScoreTreeResultElement;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Music scratch-out\n     *\n     * @class MusicScratchOut\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicScratchOut(obj) {\n        this.inputRanges = [];\n        this.erasedInputRanges = [];\n        if (obj) {\n            for (var i in obj.inputRanges) {\n                this.inputRanges.push(new scope.MusicInputRange(obj.inputRanges[i]));\n            }\n            for (var j in obj.erasedInputRanges) {\n                this.erasedInputRanges.push(new scope.MusicInputRange(obj.erasedInputRanges[j]));\n            }\n        }\n    }\n\n    /**\n     * Get input ranges\n     *\n     * @method getInputRanges\n     * @returns {MusicInputRange[]}\n     */\n    MusicScratchOut.prototype.getInputRanges = function () {\n        return this.inputRanges;\n    };\n\n    /**\n     * Get erased input ranges\n     *\n     * @method getErasedInputRanges\n     * @returns {MusicInputRange[]}\n     */\n    MusicScratchOut.prototype.getErasedInputRanges = function () {\n        return this.erasedInputRanges;\n    };\n\n    // Export\n    scope.MusicScratchOut = MusicScratchOut;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Music slur\n     *\n     * @class MusicSlur\n     * @extends MusicElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicSlur(obj) {\n        scope.MusicElement.call(this, obj);\n        if (obj) {\n            this.placement = obj.placement;\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicSlur.prototype = new scope.MusicElement();\n\n    /**\n     * Constructor property\n     */\n    MusicSlur.prototype.constructor = MusicSlur;\n\n    /**\n     * Get placement\n     *\n     * @method getPlacement\n     * @returns {String}\n     */\n    MusicSlur.prototype.getPlacement = function () {\n        return this.placement;\n    };\n\n    // Export\n    scope.MusicSlur = MusicSlur;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Music stem\n     *\n     * @class MusicStem\n     * @extends MusicElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicStem(obj) {\n        scope.MusicElement.call(this, obj);\n        if (obj) {\n            this.type = obj.type;\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicStem.prototype = new scope.MusicElement();\n\n    /**\n     * Constructor property\n     */\n    MusicStem.prototype.constructor = MusicStem;\n\n    /**\n     * Get type\n     *\n     * @method getType\n     * @returns {String}\n     */\n    MusicStem.prototype.getType = function () {\n        return this.type;\n    };\n\n    // Export\n    scope.MusicStem = MusicStem;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Music tie\n     *\n     * @class MusicTie\n     * @extends MusicElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicTie(obj) {\n        scope.MusicElement.call(this, obj);\n        if (obj) {\n            this.placement = obj.placement;\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicTie.prototype = new scope.MusicElement();\n\n    /**\n     * Constructor property\n     */\n    MusicTie.prototype.constructor = MusicTie;\n\n    /**\n     * Get placement\n     *\n     * @method getPlacement\n     * @returns {String}\n     */\n    MusicTie.prototype.getPlacement = function () {\n        return this.placement;\n    };\n\n    // Export\n    scope.MusicTie = MusicTie;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Music time modification data\n     *\n     * @class MusicTimeModificationData\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicTimeModificationData(obj) {\n        if (obj) {\n            this.actual = obj.actual;\n            this.dots = obj.dots;\n            this.normal = obj.normal;\n            this.type = obj.type;\n        }\n    }\n\n    /**\n     * Get actual\n     *\n     * @method getActual\n     * @returns {Number}\n     */\n    MusicTimeModificationData.prototype.getActual = function () {\n        return this.actual;\n    };\n\n    /**\n     * Get dots\n     *\n     * @method getDots\n     * @returns {Number}\n     */\n    MusicTimeModificationData.prototype.getDots = function () {\n        return this.dots;\n    };\n\n    /**\n     * Get normal\n     *\n     * @method getNormal\n     * @returns {Number}\n     */\n    MusicTimeModificationData.prototype.getNormal = function () {\n        return this.normal;\n    };\n\n    /**\n     * Get type\n     *\n     * @method getType\n     * @returns {String}\n     */\n    MusicTimeModificationData.prototype.getType = function () {\n        return this.type;\n    };\n\n    // Export\n    scope.MusicTimeModificationData = MusicTimeModificationData;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Music time signature\n     *\n     * @class MusicTimeSignature\n     * @extends MusicElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicTimeSignature(obj) {\n        scope.MusicElement.call(this, obj);\n        if (obj) {\n            this.top = new scope.MusicAnnotation(obj.top);\n            this.bottom = new scope.MusicAnnotation(obj.bottom);\n            this.type = obj.type;\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicTimeSignature.prototype = new scope.MusicElement();\n\n    /**\n     * Constructor property\n     */\n    MusicTimeSignature.prototype.constructor = MusicTimeSignature;\n\n    /**\n     * Get top\n     *\n     * @method getTop\n     * @returns {MusicAnnotation}\n     */\n    MusicTimeSignature.prototype.getTop = function () {\n        return this.top;\n    };\n\n    /**\n     * Get bottom\n     *\n     * @method getBottom\n     * @returns {MusicAnnotation}\n     */\n    MusicTimeSignature.prototype.getBottom = function () {\n        return this.bottom;\n    };\n\n    /**\n     * Get type\n     *\n     * @method getType\n     * @returns {String}\n     */\n    MusicTimeSignature.prototype.getType = function () {\n        return this.type;\n    };\n\n    // Export\n    scope.MusicTimeSignature = MusicTimeSignature;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Music tuplet bracket\n     *\n     * @class MusicTupletBracket\n     * @extends MusicElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicTupletBracket(obj) {\n        scope.MusicElement.call(this, obj);\n        if (obj) {\n            this.type = obj.type;\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicTupletBracket.prototype = new scope.MusicElement();\n\n    /**\n     * Constructor property\n     */\n    MusicTupletBracket.prototype.constructor = MusicTupletBracket;\n\n    /**\n     * Get type\n     *\n     * @method getType\n     * @returns {String}\n     */\n    MusicTupletBracket.prototype.getType = function () {\n        return this.type;\n    };\n\n    // Export\n    scope.MusicTupletBracket = MusicTupletBracket;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Music tuplet\n     *\n     * @class MusicTuplet\n     * @extends MusicElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicTuplet(obj) {\n        scope.MusicElement.call(this, obj);\n        this.brackets = [];\n        if (obj) {\n            this.placement = obj.placement;\n            this.number = new scope.MusicAnnotation(obj.number);\n            for (var i in obj.brackets) {\n                this.brackets.push(new scope.MusicTupletBracket(obj.brackets[i]));\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicTuplet.prototype = new scope.MusicElement();\n\n    /**\n     * Constructor property\n     */\n    MusicTuplet.prototype.constructor = MusicTuplet;\n\n    /**\n     * Get placement\n     *\n     * @method getPlacement\n     * @returns {String}\n     */\n    MusicTuplet.prototype.getPlacement = function () {\n        return this.placement;\n    };\n\n    /**\n     * Get number\n     *\n     * @method getNumber\n     * @returns {MusicAnnotation}\n     */\n    MusicTuplet.prototype.getNumber = function () {\n        return this.number;\n    };\n\n    /**\n     * Get brackets\n     *\n     * @method getBrackets\n     * @returns {Array}\n     */\n    MusicTuplet.prototype.getBrackets = function () {\n        return this.brackets;\n    };\n\n    // Export\n    scope.MusicTuplet = MusicTuplet;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * MusicXML result\n     *\n     * @class MusicXMLResultElement\n     * @extends MusicResultElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicXMLResultElement(obj) {\n        scope.MusicResultElement.call(this, obj);\n        if (obj) {\n            this.value = obj.value;\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicXMLResultElement.prototype = new scope.MusicResultElement();\n\n    /**\n     * Constructor property\n     */\n    MusicXMLResultElement.prototype.constructor = MusicXMLResultElement;\n\n    /**\n     * Get value\n     *\n     * @method getValue\n     * @returns {String}\n     */\n    MusicXMLResultElement.prototype.getValue = function () {\n        return this.value;\n    };\n\n    // Export\n    scope.MusicXMLResultElement = MusicXMLResultElement;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Analyzer element\n     *\n     * @class AnalyzerElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function AnalyzerElement(obj) {\n        if (obj) {\n            this.elementType = obj.elementType;\n        }\n    }\n\n    /**\n     * Get element type\n     *\n     * @method getElementType\n     * @returns {String}\n     */\n    AnalyzerElement.prototype.getElementType = function () {\n        return this.elementType;\n    };\n\n    // Export\n    scope.AnalyzerElement = AnalyzerElement;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Analyzer table cell\n     *\n     * @class AnalyzerCell\n     * @extends AnalyzerElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function AnalyzerCell(obj) {\n        scope.AnalyzerElement.call(this, obj);\n        if (obj) {\n            this.data = new scope.AnalyzerCellData(obj.data);\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    AnalyzerCell.prototype = new scope.AnalyzerElement();\n\n    /**\n     * Constructor property\n     */\n    AnalyzerCell.prototype.constructor = AnalyzerCell;\n\n    /**\n     * Get analyzer cell data\n     *\n     * @method getData\n     * @returns {AnalyzerCellData}\n     */\n    AnalyzerCell.prototype.getData = function () {\n        return this.data;\n    };\n\n    // Export\n    scope.AnalyzerCell = AnalyzerCell;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Analyzer cell data\n     *\n     * @class AnalyzerCellData\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function AnalyzerCellData(obj) {\n        if (obj) {\n            this.firstColumn = obj.firstColumn;\n            this.lastColumn = obj.lastColumn;\n            this.firstRow = obj.firstRow;\n            this.lastRow = obj.lastRow;\n            this.height = obj.height;\n            this.width = obj.width;\n            this.orientation = obj.orientation;\n            this.topLeftPoint = new scope.Point(obj.topLeftPoint);\n            this.topBorder = obj.topBorder;\n            this.bottomBorder = obj.bottomBorder;\n            this.leftBorder = obj.leftBorder;\n            this.rightBorder = obj.rightBorder;\n        }\n    }\n\n    /**\n     * Get first column\n     *\n     * @method getFirstColumn\n     * @returns {Number}\n     */\n    AnalyzerCellData.prototype.getFirstColumn = function () {\n        return this.firstColumn;\n    };\n\n    /**\n     * Get last column\n     *\n     * @method getLastColumn\n     * @returns {Number}\n     */\n    AnalyzerCellData.prototype.getLastColumn = function () {\n        return this.lastColumn;\n    };\n\n    /**\n     * Get first row\n     *\n     * @method getFirstRow\n     * @returns {Number}\n     */\n    AnalyzerCellData.prototype.getFirstRow = function () {\n        return this.firstRow;\n    };\n\n    /**\n     * Get last row\n     *\n     * @method getLastRow\n     * @returns {Number}\n     */\n    AnalyzerCellData.prototype.getLastRow = function () {\n        return this.lastRow;\n    };\n\n    /**\n     * Get height\n     *\n     * @method getHeight\n     * @returns {Number}\n     */\n    AnalyzerCellData.prototype.getHeight = function () {\n        return this.height;\n    };\n\n    /**\n     * Get width\n     *\n     * @method getWidth\n     * @returns {Number}\n     */\n    AnalyzerCellData.prototype.getWidth = function () {\n        return this.width;\n    };\n\n    /**\n     * Get orientation\n     *\n     * @method getOrientation\n     * @returns {String}\n     */\n    AnalyzerCellData.prototype.getOrientation = function () {\n        return this.orientation;\n    };\n\n    /**\n     * Get top-left point\n     *\n     * @method getTopLeftPoint\n     * @returns {Point}\n     */\n    AnalyzerCellData.prototype.getTopLeftPoint = function () {\n        return this.topLeftPoint;\n    };\n\n    /**\n     * Has top border\n     *\n     * @method hasTopBorder\n     * @returns {Boolean}\n     */\n    AnalyzerCellData.prototype.hasTopBorder = function () {\n        return this.topBorder;\n    };\n\n    /**\n     * Has bottom border\n     *\n     * @method hasBottomBorder\n     * @returns {Boolean}\n     */\n    AnalyzerCellData.prototype.hasBottomBorder = function () {\n        return this.bottomBorder;\n    };\n\n    /**\n     * Has left border\n     *\n     * @method hasLeftBorder\n     * @returns {Boolean}\n     */\n    AnalyzerCellData.prototype.hasLeftBorder = function () {\n        return this.leftBorder;\n    };\n\n    /**\n     * Has right border\n     *\n     * @method hasRightBorder\n     * @returns {Boolean}\n     */\n    AnalyzerCellData.prototype.hasRightBorder = function () {\n        return this.rightBorder;\n    };\n\n    /**\n     * Get bounding box\n     *\n     * @method getBoundingBox\n     * @returns {Rectangle}\n     */\n    AnalyzerCellData.prototype.getBoundingBox = function () {\n        var rectangle = new scope.Rectangle();\n        rectangle.setTopLeftPoint(this.getTopLeftPoint());\n        rectangle.setWidth(this.getWidth());\n        rectangle.setHeight(this.getHeight());\n        return rectangle;\n    };\n\n    // Export\n    scope.AnalyzerCellData = AnalyzerCellData;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Analyzer document\n     *\n     * @class AnalyzerDocument\n     * @extends AnalyzerElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function AnalyzerDocument(obj) {\n        scope.AnalyzerElement.call(this, obj);\n        this.textLines = [];\n        this.shapes = [];\n        this.tables = [];\n        this.groups = [];\n        if (obj) {\n            for (var i in obj.textLines) {\n                this.textLines.push(new scope.AnalyzerTextLine(obj.textLines[i]));\n            }\n            for (var j in obj.shapes) {\n                this.shapes.push(new scope.ShapeSegment(obj.shapes[j]));\n            }\n            for (var k in obj.tables) {\n                this.tables.push(new scope.AnalyzerTable(obj.tables[k]));\n            }\n            for (var l in obj.groups) {\n                this.groups.push(new scope.AnalyzerGroup(obj.groups[l]));\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    AnalyzerDocument.prototype = new scope.AnalyzerElement();\n\n    /**\n     * Constructor property\n     */\n    AnalyzerDocument.prototype.constructor = AnalyzerDocument;\n\n    /**\n     * Get text lines\n     *\n     * @method getTextLines\n     * @returns {AnalyzerTextLine[]}\n     */\n    AnalyzerDocument.prototype.getTextLines = function () {\n        return this.textLines;\n    };\n\n    /**\n     * Get shapes\n     *\n     * @method getShapes\n     * @returns {ShapeSegment[]}\n     */\n    AnalyzerDocument.prototype.getShapes = function () {\n        return this.shapes;\n    };\n\n    /**\n     * Get tables\n     *\n     * @method getTables\n     * @returns {AnalyzerTable[]}\n     */\n    AnalyzerDocument.prototype.getTables = function () {\n        return this.tables;\n    };\n\n    /**\n     * Get groups\n     *\n     * @method getGroups\n     * @returns {AnalyzerGroup[]}\n     */\n    AnalyzerDocument.prototype.getGroups = function () {\n        return this.groups;\n    };\n\n    /**\n     * Has scratch-out results\n     *\n     * @method hasScratchOutResults\n     * @returns {Boolean}\n     */\n    AnalyzerDocument.prototype.hasScratchOutResults = function () {\n        for (var i in this.getShapes()) {\n            var currentSeg = this.getShapes()[i];\n            for (var j in currentSeg.getCandidates()) {\n                var currentCandidate = currentSeg.getCandidates()[j];\n                if (currentCandidate instanceof scope.ShapeScratchOut) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    };\n\n    // Export\n    scope.AnalyzerDocument = AnalyzerDocument;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Analyzer element reference\n     *\n     * @class AnalyzerElementReference\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function AnalyzerElementReference(obj) {\n        if (obj) {\n            this.uniqueID = obj.uniqueID;\n            this.type = obj.type;\n        }\n    }\n\n    /**\n     * Get unique id\n     *\n     * @method getUniqueId\n     * @returns {String}\n     */\n    AnalyzerElementReference.prototype.getUniqueId = function () {\n        return this.uniqueID;\n    };\n\n    /**\n     * Get type\n     *\n     * @method getType\n     * @returns {String}\n     */\n    AnalyzerElementReference.prototype.getType = function () {\n        return this.type;\n    };\n\n    // Export\n    scope.AnalyzerElementReference = AnalyzerElementReference;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Analyzer group\n     *\n     * @class AnalyzerGroup\n     * @extends AnalyzerElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function AnalyzerGroup(obj) {\n        scope.AnalyzerElement.call(this, obj);\n        this.elementReferences = [];\n        if (obj) {\n            this.type = obj.type;\n            this.uniqueID = obj.uniqueID;\n            for (var i in obj.elementReferences) {\n                this.elementReferences.push(new scope.AnalyzerElementReference(obj.elementReferences[i]));\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    AnalyzerGroup.prototype = new scope.AnalyzerElement();\n\n    /**\n     * Constructor property\n     */\n    AnalyzerGroup.prototype.constructor = AnalyzerGroup;\n\n    /**\n     * Get element references\n     *\n     * @method getElementReferences\n     * @returns {AnalyzerElementReference[]}\n     */\n    AnalyzerGroup.prototype.getElementReferences = function () {\n        return this.elementReferences;\n    };\n\n    /**\n     * Get type\n     *\n     * @method getType\n     * @returns {String}\n     */\n    AnalyzerGroup.prototype.getType = function () {\n        return this.type;\n    };\n\n    /**\n     * Get unique Id\n     *\n     * @method getUniqueId\n     * @returns {String}\n     */\n    AnalyzerGroup.prototype.getUniqueId = function () {\n        return this.uniqueID;\n    };\n\n    // Export\n    scope.AnalyzerGroup = AnalyzerGroup;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Analyzer ink range\n     *\n     * @class AnalyzerInkRange\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function AnalyzerInkRange(obj) {\n        if (obj) {\n            this.firstPoint = new scope.Point(obj.firstPoint);\n            this.lastPoint = new scope.Point(obj.lastPoint);\n            this.stroke = new scope.AnalyzerRecognizedStroke(obj.stroke);\n        }\n    }\n\n    /**\n     * Get first point\n     *\n     * @method getFirstPoint\n     * @returns {Point}\n     */\n    AnalyzerInkRange.prototype.getFirstPoint = function () {\n        return this.firstPoint;\n    };\n\n    /**\n     * Get last point\n     *\n     * @method getLastPoint\n     * @returns {Point}\n     */\n    AnalyzerInkRange.prototype.getLastPoint = function () {\n        return this.lastPoint;\n    };\n\n    /**\n     * Get stroke\n     *\n     * @method getStroke\n     * @returns {null|*}\n     */\n    AnalyzerInkRange.prototype.getStroke = function () {\n        return this.stroke;\n    };\n\n    // Export\n    scope.AnalyzerInkRange = AnalyzerInkRange;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Analyzer line\n     *\n     * @class AnalyzerLine\n     * @extends AnalyzerElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function AnalyzerLine(obj) {\n        scope.AnalyzerElement.call(this, obj);\n        if (obj) {\n            this.data = new scope.AnalyzerLineData(obj.data);\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    AnalyzerLine.prototype = new scope.AnalyzerElement();\n\n    /**\n     * Constructor property\n     */\n    AnalyzerLine.prototype.constructor = AnalyzerLine;\n\n    /**\n     * Get data\n     *\n     * @method getData\n     * @returns {AnalyzerLineData}\n     */\n    AnalyzerLine.prototype.getData = function () {\n        return this.data;\n    };\n\n    // Export\n    scope.AnalyzerLine = AnalyzerLine;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Analyzer line data\n     *\n     * @class AnalyzerLineData\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function AnalyzerLineData(obj) {\n        if (obj) {\n            this.p1 = new scope.Point(obj.p1);\n            this.p2 = new scope.Point(obj.p2);\n        }\n    }\n\n    /**\n     * Get p1\n     *\n     * @method getP1\n     * @returns {Point}\n     */\n    AnalyzerLineData.prototype.getP1 = function () {\n        return this.p1;\n    };\n\n    /**\n     * Get p2\n     *\n     * @method getP2\n     * @returns {Point}\n     */\n    AnalyzerLineData.prototype.getP2 = function () {\n        return this.p2;\n    };\n\n    // Export\n    scope.AnalyzerLineData = AnalyzerLineData;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * AnalyzerRecognizedStroke\n     *\n     * @class AnalyzerRecognizedStroke\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function AnalyzerRecognizedStroke(obj) {\n        if (obj) {\n            this.type = obj.type;\n            this.x = obj.x;\n            this.y = obj.y;\n        }\n    }\n\n    /**\n     * Get type\n     *\n     * @method getType\n     * @returns {String}\n     */\n    AnalyzerRecognizedStroke.prototype.getType = function () {\n        return this.type;\n    };\n\n    /**\n     * Get x\n     *\n     * @method getX\n     * @returns {Number[]}\n     */\n    AnalyzerRecognizedStroke.prototype.getX = function () {\n        return this.x;\n    };\n\n    /**\n     * Get y\n     *\n     * @method getY\n     * @returns {Number[]}\n     */\n    AnalyzerRecognizedStroke.prototype.getY = function () {\n        return this.y;\n    };\n\n    // Export\n    scope.AnalyzerRecognizedStroke = AnalyzerRecognizedStroke;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Analyzer result\n     *\n     * @class AnalyzerResult\n     * @extends AbstractResult\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function AnalyzerResult(obj) {\n        scope.AbstractResult.call(this, obj);\n        if (obj) {\n            this.result = new scope.AnalyzerDocument(obj.result);\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    AnalyzerResult.prototype = new scope.AbstractResult();\n\n    /**\n     * Constructor property\n     */\n    AnalyzerResult.prototype.constructor = AnalyzerResult;\n\n    // Export\n    scope.AnalyzerResult = AnalyzerResult;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * Analyzer stroke type\n     *\n     * @class AnalyzerStrokeType\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function AnalyzerStrokeType(obj) {\n        if (obj) {\n            this.inkRange = new scope.AnalyzerInkRange(obj.inkRange);\n            this.type = obj.type;\n        }\n    }\n\n    /**\n     * Get ink range\n     *\n     * @method getInkRange\n     * @returns {AnalyzerInkRange}\n     */\n    AnalyzerStrokeType.prototype.getInkRange = function () {\n        return this.inkRange;\n    };\n\n    /**\n     * Get type\n     *\n     * @method getType\n     * @returns {String}\n     */\n    AnalyzerStrokeType.prototype.getType = function () {\n        return this.type;\n    };\n\n    // Export\n    scope.AnalyzerStrokeType = AnalyzerStrokeType;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Analyzer table\n     *\n     * @class AnalyzerTable\n     * @extends AnalyzerElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function AnalyzerTable(obj) {\n        scope.AnalyzerElement.call(this, obj);\n        this.lines = [];\n        this.cells = [];\n        this.inkRanges = [];\n        if (obj) {\n            this.data = new scope.AnalyzerTableData(obj.data);\n            for (var i in obj.lines) {\n                this.lines.push(new scope.AnalyzerLine(obj.lines[i]));\n            }\n            for (var j in obj.cells) {\n                this.cells.push(new scope.AnalyzerCell(obj.cells[j]));\n            }\n            for (var k in obj.inkRanges) {\n                this.inkRanges.push(new scope.AnalyzerInkRange(obj.inkRanges[k]));\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    AnalyzerTable.prototype = new scope.AnalyzerElement();\n\n    /**\n     * Constructor property\n     */\n    AnalyzerTable.prototype.constructor = AnalyzerTable;\n\n    /**\n     * Get data\n     *\n     * @method getData\n     * @returns {AnalyzerTableData}\n     */\n    AnalyzerTable.prototype.getData = function () {\n        return this.data;\n    };\n\n    /**\n     * Get lines\n     *\n     * @method getLines\n     * @returns {AnalyzerLine[]}\n     */\n    AnalyzerTable.prototype.getLines = function () {\n        return this.lines;\n    };\n\n    /**\n     * Get cells\n     *\n     * @method getCells\n     * @returns {AnalyzerCell[]}\n     */\n    AnalyzerTable.prototype.getCells = function () {\n        return this.cells;\n    };\n\n    /**\n     * Get ink ranges\n     *\n     * @method getInkRanges\n     * @returns {AnalyzerInkRange[]}\n     */\n    AnalyzerTable.prototype.getInkRanges = function () {\n        return this.inkRanges;\n    };\n\n    // Export\n    scope.AnalyzerTable = AnalyzerTable;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Analyzer table data\n     *\n     * @class AnalyzerTableData\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function AnalyzerTableData(obj) {\n        if (obj) {\n            this.columnCount = obj.columnCount;\n            this.rowCount = obj.rowCount;\n        }\n    }\n\n    /**\n     * Get column count\n     *\n     * @method getColumnCount\n     * @returns {Number}\n     */\n    AnalyzerTableData.prototype.getColumnCount = function () {\n        return this.columnCount;\n    };\n\n    /**\n     * Get row count\n     *\n     * @method getRowCount\n     * @returns {Number}\n     */\n    AnalyzerTableData.prototype.getRowCount = function () {\n        return this.rowCount;\n    };\n\n    // Export\n    scope.AnalyzerTableData = AnalyzerTableData;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Analyzer text line\n     *\n     * @class AnalyzerTextLine\n     * @extends AnalyzerElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function AnalyzerTextLine(obj) {\n        scope.AnalyzerElement.call(this, obj);\n        this.inkRanges = [];\n        this.underlineList = [];\n        if (obj) {\n            this.data = new scope.AnalyzerTextLineData(obj.data);\n            this.result = new scope.TextDocument(obj.result);\n            for (var i in obj.inkRanges) {\n                this.inkRanges.push(new scope.AnalyzerInkRange(obj.inkRanges[i]));\n            }\n            for (var j in obj.underlineList) {\n                this.underlineList.push(new scope.AnalyzerUnderline(obj.underlineList[j]));\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    AnalyzerTextLine.prototype = new scope.AnalyzerElement();\n\n    /**\n     * Constructor property\n     */\n    AnalyzerTextLine.prototype.constructor = AnalyzerTextLine;\n\n    /**\n     * Get data\n     *\n     * @method getData\n     * @returns {AnalyzerTextLineData}\n     */\n    AnalyzerTextLine.prototype.getData = function () {\n        return this.data;\n    };\n\n    /**\n     * Get text document\n     *\n     * @method getTextDocument\n     * @returns {TextDocument}\n     */\n    AnalyzerTextLine.prototype.getTextDocument = function () {\n        return this.result;\n    };\n\n    /**\n     * Get ink ranges\n     *\n     * @method getInkRanges\n     * @returns {AnalyzerInkRange[]}\n     */\n    AnalyzerTextLine.prototype.getInkRanges = function () {\n        return this.inkRanges;\n    };\n\n    /**\n     * Get underline list\n     *\n     * @method getUnderlineList\n     * @returns {AnalyzerUnderline[]}\n     */\n    AnalyzerTextLine.prototype.getUnderlineList = function () {\n        return this.underlineList;\n    };\n\n    // Export\n    scope.AnalyzerTextLine = AnalyzerTextLine;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Analyzer text line data\n     *\n     * @class AnalyzerTextLineData\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function AnalyzerTextLineData(obj) {\n        if (obj) {\n            this.baselinePos = obj.baselinePos;\n            this.toMidline = obj.toMidline;\n            this.orientation = obj.orientation;\n            this.topLeftPoint = new scope.Point(obj.topLeftPoint);\n            this.textHeight = obj.textHeight;\n            this.justificationType = obj.justificationType;\n            this.height = obj.height;\n            this.width = obj.width;\n        }\n    }\n\n    /**\n     * Get baseline position\n     *\n     * @method getBaselinePos\n     * @returns {Number}\n     */\n    AnalyzerTextLineData.prototype.getBaselinePos = function () {\n        return this.baselinePos;\n    };\n\n    /**\n     * Get to midline\n     *\n     * @method getToMidline\n     * @returns {Number}\n     */\n    AnalyzerTextLineData.prototype.getToMidline = function () {\n        return this.toMidline;\n    };\n\n    /**\n     * Get orientation\n     *\n     * @method getOrientation\n     * @returns {String}\n     */\n    AnalyzerTextLineData.prototype.getOrientation = function () {\n        return this.orientation;\n    };\n\n    /**\n     * Get top-left point\n     *\n     * @method getTopLeftPoint\n     * @returns {Point}\n     */\n    AnalyzerTextLineData.prototype.getTopLeftPoint = function () {\n        return this.topLeftPoint;\n    };\n\n    /**\n     * Get text height\n     *\n     * @method getTextHeight\n     * @returns {Number}\n     */\n    AnalyzerTextLineData.prototype.getTextHeight = function () {\n        return this.textHeight;\n    };\n\n    /**\n     * Get justification type\n     *\n     * @method getJustificationType\n     * @returns {String}\n     */\n    AnalyzerTextLineData.prototype.getJustificationType = function () {\n        return this.justificationType;\n    };\n\n    /**\n     * Get height\n     *\n     * @method getHeight\n     * @returns {Number}\n     */\n    AnalyzerTextLineData.prototype.getHeight = function () {\n        return this.height;\n    };\n\n    /**\n     * Get width\n     *\n     * @method getWidth\n     * @returns {Number}\n     */\n    AnalyzerTextLineData.prototype.getWidth = function () {\n        return this.width;\n    };\n\n    /**\n     * Get bounding box\n     *\n     * @method getBoundingBox\n     * @returns {Rectangle}\n     */\n    AnalyzerTextLineData.prototype.getBoundingBox = function () {\n        var rectangle = new scope.Rectangle();\n        if (this.getTopLeftPoint() || this.getWidth() || this.getHeight()) {\n            rectangle.setTopLeftPoint(this.getTopLeftPoint());\n            rectangle.setWidth(this.getWidth());\n            rectangle.setHeight(this.getHeight());\n        }\n        return rectangle;\n    };\n\n    // Export\n    scope.AnalyzerTextLineData = AnalyzerTextLineData;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Analyzer underline\n     *\n     * @class AnalyzerUnderline\n     * @extends AnalyzerElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function AnalyzerUnderline(obj) {\n        scope.AnalyzerElement.call(this, obj);\n        this.inkRanges = [];\n        if (obj) {\n            this.data = new scope.AnalyzerUnderlineData(obj.data);\n            for (var i in obj.inkRanges) {\n                this.inkRanges.push(new scope.AnalyzerInkRange(obj.inkRanges[i]));\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    AnalyzerUnderline.prototype = new scope.AnalyzerElement();\n\n    /**\n     * Constructor property\n     */\n    AnalyzerUnderline.prototype.constructor = AnalyzerUnderline;\n\n    /**\n     * Get data\n     *\n     * @method getData\n     * @returns {AnalyzerUnderlineData}\n     */\n    AnalyzerUnderline.prototype.getData = function () {\n        return this.data;\n    };\n\n    /**\n     * Get ink ranges\n     *\n     * @method getInkRanges\n     * @returns {AnalyzerInkRange[]}\n     */\n    AnalyzerUnderline.prototype.getInkRanges = function () {\n        return this.inkRanges;\n    };\n\n    // Export\n    scope.AnalyzerUnderline = AnalyzerUnderline;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Analyzer underline data\n     *\n     * @class AnalyzerUnderlineData\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function AnalyzerUnderlineData(obj) {\n        if (obj) {\n            this.firstCharacter = obj.firstCharacter;\n            this.lastCharacter = obj.lastCharacter;\n        }\n    }\n\n    /**\n     * Get first character\n     *\n     * @method getFirstCharacter\n     * @returns {Number}\n     */\n    AnalyzerUnderlineData.prototype.getFirstCharacter = function () {\n        return this.firstCharacter;\n    };\n\n    /**\n     * Get last character\n     *\n     * @method getLastCharacter\n     * @returns {Number}\n     */\n    AnalyzerUnderlineData.prototype.getLastCharacter = function () {\n        return this.lastCharacter;\n    };\n\n    // Export\n    scope.AnalyzerUnderlineData = AnalyzerUnderlineData;\n})(MyScript);\n\n\n(function (scope, Q) {\n    /**\n     * Network interface\n     *\n     * @class NetworkInterface\n     * @constructor\n     */\n    function NetworkInterface() {\n    }\n\n    NetworkInterface.parseURL = function (url) {\n\n        var parser = document.createElement('a'),\n            searchObject = {},\n            queries, split, i;\n        // Let the browser do the work\n        parser.href = url;\n        // Convert query string to object\n        queries = parser.search.replace(/^\\?/, '').split('&');\n        for (i = 0; i < queries.length; i++) {\n            split = queries[i].split('=');\n            searchObject[split[0]] = split[1];\n        }\n        return {\n            protocol: parser.protocol,\n            host: parser.host,\n            hostname: parser.hostname,\n            port: parser.port,\n            pathname: parser.pathname,\n            search: parser.search,\n            searchObject: searchObject,\n            hash: parser.hash\n        };\n    };\n\n    /**\n     * Parse JSON String to Object\n     *\n     * @method parse\n     * @param {Object} req\n     * @returns {Object}\n     */\n    NetworkInterface.parse = function (req) {\n        var result;\n        try {\n            result = JSON.parse(req.responseText);\n        } catch (e) {\n            result = req.responseText;\n        }\n        return result;\n    };\n\n    /**\n     * Transform object data request to a list of parameters\n     *\n     * @method transformRequest\n     * @param {Object} [obj]\n     * @returns {String}\n     */\n    NetworkInterface.transformRequest = function (obj) {\n        var str = [];\n        for (var p in obj) {\n            if ((typeof obj[p] !== 'undefined') &&\n                (typeof obj[p] !== 'function')) {\n                str.push(encodeURIComponent(p) + '=' + encodeURIComponent(obj[p]));\n            }\n        }\n        return str.join('&');\n    };\n\n    /**\n     * Send request to the network and return a promise\n     *\n     * @method xhr\n     * @param {String} type\n     * @param {String} url\n     * @param {Object} data\n     * @returns {Promise}\n     */\n    NetworkInterface.xhr = function (type, url, data) {\n\n        return Q.Promise(function (resolve, reject, notify) {\n\n            function onStateChange() {\n                if (request.readyState === 4) {\n                    if (request.status >= 200 && request.status < 300) {\n                        resolve(NetworkInterface.parse(request));\n                    }\n                }\n            }\n\n            function onLoad() {\n                if (request.status >= 200 && request.status < 300) {\n                    resolve(NetworkInterface.parse(request));\n                } else {\n                    reject(new Error(request.responseText));\n                }\n            }\n\n            function onError() {\n                reject(new Error('Can\\'t XHR ' + url));\n            }\n\n            function onProgress(e) {\n                notify(e.loaded / e.total);\n            }\n\n            var request = new XMLHttpRequest();\n            request.open(type, url, true);\n            request.withCredentials = true;\n            request.setRequestHeader('Accept', 'application/json');\n            request.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded;charset=UTF-8');\n            request.onerror = onError;\n            request.onprogress = onProgress;\n            request.onload = onLoad;\n            request.onreadystatechange = onStateChange;\n            request.send(NetworkInterface.transformRequest(data));\n        });\n    };\n\n    /**\n     * Get request\n     *\n     * @method get\n     * @param {String} src\n     * @param {Object} params\n     * @returns {Promise}\n     */\n    NetworkInterface.get = function (src, params) {\n        if (params) {\n            src += '?' + NetworkInterface.transformRequest(params);\n        }\n        return scope.NetworkInterface.xhr('GET', src, undefined);\n    };\n\n    /**\n     * Put request\n     *\n     * @method put\n     * @param {String} url\n     * @param {Object} data\n     * @returns {Promise}\n     */\n    NetworkInterface.put = function (url, data) {\n        return scope.NetworkInterface.xhr('PUT', url, data);\n    };\n\n    /**\n     * Post request\n     *\n     * @method post\n     * @param {String} url\n     * @param {Object} data\n     * @returns {Promise}\n     */\n    NetworkInterface.post = function (url, data) {\n        return scope.NetworkInterface.xhr('POST', url, data);\n    };\n\n    /**\n     * Delete request\n     *\n     * @method delete\n     * @param {String} url\n     * @param {Object} data\n     * @returns {Promise}\n     */\n    NetworkInterface.delete = function (url, data) {\n        return scope.NetworkInterface.xhr('DELETE', url, data);\n    };\n\n    // Export\n    scope.NetworkInterface = NetworkInterface;\n})(MyScript, Q);\n\n\n/* jshint ignore:start */\n\n(function (scope, Q) {\n    /**\n     * Network interface\n     *\n     * @class NetworkWSInterface\n     * @constructor\n     */\n    function NetworkWSInterface() {\n    }\n\n    NetworkWSInterface.prototype.setUrl = function (url) {\n        if ((url !== undefined) && (url !== this._url)) {\n            this.close();\n            this._url = url;\n        }\n    };\n\n    NetworkWSInterface.prototype.getUrl = function () {\n        return this._url;\n    };\n\n    NetworkWSInterface.prototype.setCallback = function (callback) {\n        if (callback !== undefined) {\n            this.close();\n            this._callback = callback;\n        }\n    };\n\n    NetworkWSInterface.prototype.getCallback = function () {\n        return this._callback;\n    };\n\n    NetworkWSInterface.prototype.getState = function () {\n        return _getWebSocketState(this._socket);\n    };\n\n    NetworkWSInterface.prototype.isClosed = function () {\n        return this.getState() === 3;\n    };\n\n    NetworkWSInterface.prototype.isClosing = function () {\n        return this.getState() === 2;\n    };\n\n    NetworkWSInterface.prototype.isOpen = function () {\n        return this.getState() === 1;\n    };\n\n    NetworkWSInterface.prototype.isConnecting = function () {\n        return this.getState() === 0;\n    };\n\n    NetworkWSInterface.prototype.open = function () {\n        if (this.getUrl() && this.getCallback() && ((this.getState() < 0) || this.isClosed())) {\n            this._socket = _openWebSocket(this.getUrl(), this.getCallback());\n        }\n    };\n\n    NetworkWSInterface.prototype.close = function (code, reason) {\n        if (this.getState() < 2) {\n            _closeWebSocket(this._socket, code, reason);\n        }\n    };\n\n    NetworkWSInterface.prototype.send = function (request) {\n        var state = _getWebSocketState(this._socket);\n        if (state  === 1) {\n            _sendMessage(this._socket, request);\n        } else {\n            this.open();\n        }\n    };\n\n    /**\n     *\n     * @param url\n     * @param callback\n     * @returns {WebSocket}\n     * @private\n     */\n    var _openWebSocket = function (url, callback) {\n        function onOpen(e) {\n            callback(e);\n        }\n        function onClose(e) {\n            callback(e);\n        }\n        function onError(e) {\n            callback(e);\n        }\n        function onMessage(e) {\n            callback({\n                type: e.type,\n                data: JSON.parse(e.data)\n            });\n        }\n\n        var socket = new WebSocket(url);\n        socket.onopen = onOpen;\n        socket.onclose = onClose;\n        socket.onerror = onError;\n        socket.onmessage = onMessage;\n        return socket;\n    };\n\n    /**\n     *\n     * @param socket\n     * @param code\n     * @param reason\n     * @private\n     */\n    var _closeWebSocket = function (socket, code, reason) {\n        if (socket) {\n            socket.close(code, reason);\n        }\n    };\n\n    /**\n     *\n     * @param socket\n     * @returns {*}\n     * @private\n     */\n    var _getWebSocketState = function (socket) {\n        if (socket) {\n            return socket.readyState;\n        }\n        return -1;\n    };\n\n    /**\n     *\n     * @param socket\n     * @param message\n     * @private\n     */\n    var _sendMessage = function (socket, message) {\n        if (socket) {\n            socket.send(JSON.stringify(message));\n        }\n    };\n\n    // Export\n    scope.NetworkWSInterface = NetworkWSInterface;\n})(MyScript, Q);\n/* jshint ignore:end */\n\n\n\n(function (scope, CryptoJS) {\n    /**\n     * Abstract recognizer interface\n     *\n     * @class AbstractRecognizer\n     * @param {String} [host='cloud.myscript.com'] Recognition service host\n     * @constructor\n     */\n    function AbstractRecognizer(host) {\n        this.setUrl(this.getProtocol() + 'cloud.myscript.com');\n        if (host) {\n            this.setUrl(this.getProtocol() + host);\n        }\n        this.setSSL(true);\n    }\n\n    AbstractRecognizer.prototype.getProtocol = function() {\n        return this._ssl? 'https://': 'http://';\n    };\n\n    AbstractRecognizer.prototype.getSSL = function() {\n        return this._ssl;\n    };\n\n    AbstractRecognizer.prototype.setSSL = function (ssl) {\n        if (ssl !== undefined) {\n            this._ssl = ssl;\n            this.setUrl(this.getProtocol() + this.getHost());\n        }\n    };\n\n    /**\n     * Get the recognition service host\n     *\n     * @method getHost\n     * @returns {string|String|*}\n     */\n    AbstractRecognizer.prototype.getHost = function() {\n        return scope.NetworkInterface.parseURL(this.getUrl()).host;\n    };\n\n    /**\n     * Set the recognition service host\n     *\n     * @method setHost\n     * @param {String}\n     */\n    AbstractRecognizer.prototype.setHost = function (host) {\n        if (host !== undefined) {\n            this.setUrl(this.getProtocol() + host);\n        }\n    };\n\n    /**\n     * Get the recognition service host\n     *\n     * @method getUrl\n     * @returns {String}\n     */\n    AbstractRecognizer.prototype.getUrl = function() {\n        return this.url;\n    };\n\n    /**\n     * Set the recognition service url\n     *\n     * @method setUrl\n     * @param {String}\n     */\n    AbstractRecognizer.prototype.setUrl = function (url) {\n        if (url !== undefined) {\n            this.url = url;\n        }\n    };\n\n    /**\n     * Get parameters\n     *\n     * @method getParameters\n     * @returns {AbstractParameter}\n     */\n    AbstractRecognizer.prototype.getParameters = function () {\n        return this.parameters;\n    };\n\n    /**\n     * Set parameters\n     *\n     * @method setParameters\n     * @param {AbstractParameter} parameters\n     */\n    AbstractRecognizer.prototype.setParameters = function (parameters) {\n        this.parameters = parameters;\n    };\n\n    /**\n     * Get precision\n     *\n     * @method getPrecision\n     * @returns {Number}\n     */\n    AbstractRecognizer.prototype.getPrecision = function () {\n        return this.precision;\n    };\n\n    /**\n     * Set precision\n     *\n     * @method setPrecision\n     * @param {Number} precision\n     */\n    AbstractRecognizer.prototype.setPrecision = function (precision) {\n        this.precision = precision;\n    };\n\n    /**\n     * Get the recognition languages available for an application and a specific inputMode\n     *\n     * @method getAvailableLanguageList\n     * @param {String} applicationKey\n     * @param {String} inputMode\n     * @returns {Promise}\n     */\n    AbstractRecognizer.prototype.getAvailableLanguageList = function (applicationKey, inputMode) {\n        var data = new scope.RecognitionLanguagesData();\n        data.setApplicationKey(applicationKey);\n        data.setInputMode(inputMode);\n\n        return scope.NetworkInterface.get(this.getUrl() + '/api/v3.0/recognition/rest/text/languages.json', data).then(\n            function success(response) {\n                return response.result;\n            }\n        );\n    };\n\n    /**\n     * Do REST recognition\n     *\n     * @private\n     * @method doRestRecognition\n     * @param {AbstractRecognitionInput} input\n     * @param {String} applicationKey\n     * @param {String} hmacKey\n     * @param {String} instanceId\n     * @returns {Promise}\n     */\n    AbstractRecognizer.prototype.doRestRecognition = function (input, applicationKey, hmacKey, instanceId) {\n        if (input.getComponents) {\n            _filterStrokes(input.getComponents(), this.getPrecision());\n        } else if (input.getInputUnits) {\n            for (var i in input.getInputUnits()) {\n                _filterStrokes(input.getInputUnits()[i].getComponents(), this.getPrecision());\n            }\n        }\n\n        if (input instanceof scope.TextRecognitionInput) {\n            return _doTextRecognition(this.getUrl(), input, applicationKey, hmacKey, instanceId);\n        } else if (input instanceof scope.ShapeRecognitionInput) {\n            return _doShapeRecognition(this.getUrl(), input, applicationKey, hmacKey, instanceId);\n        } else if (input instanceof scope.MathRecognitionInput) {\n            return _doMathRecognition(this.getUrl(), input, applicationKey, hmacKey, instanceId);\n        } else if (input instanceof scope.MusicRecognitionInput) {\n            return _doMusicRecognition(this.getUrl(), input, applicationKey, hmacKey, instanceId);\n        } else if (input instanceof scope.AnalyzerRecognitionInput) {\n            return _doAnalyzerRecognition(this.getUrl(), input, applicationKey, hmacKey, instanceId);\n        } else {\n            throw new Error('not implemented');\n        }\n    };\n\n    /**\n     * Clear REST recognition\n     *\n     * @method clearRestRecognition\n     * @param {String} instanceId\n     * @returns {Promise}\n     */\n    AbstractRecognizer.prototype.clearRestRecognition = function (instanceId) {\n        var data = {\n            instanceSessionId: instanceId\n        };\n        return _clearShapeRecognition(this.getUrl(), data);\n    };\n\n    /**\n     * Do text recognition\n     *\n     * @private\n     * @method _doTextRecognition\n     * @param {String} url\n     * @param {TextRecognitionInput} input\n     * @param {String} applicationKey\n     * @param {String} hmacKey\n     * @param {String} instanceId\n     * @returns {Promise}\n     */\n    var _doTextRecognition = function (url, input, applicationKey, hmacKey, instanceId) {\n        var data = new scope.TextRecognitionData();\n        _fillData(data, input, instanceId, applicationKey, hmacKey);\n\n        return scope.NetworkInterface.post(url + '/api/v3.0/recognition/rest/text/doSimpleRecognition.json', data).then(\n            function success(response) {\n                return new scope.TextResult(response);\n            }\n        );\n    };\n\n    /**\n     * Do shape recognition\n     *\n     * @private\n     * @method _doShapeRecognition\n     * @param {String} url\n     * @param {ShapeRecognitionInput} input\n     * @param {String} applicationKey\n     * @param {String} hmacKey\n     * @param {String} instanceId\n     * @returns {Promise}\n     */\n    var _doShapeRecognition = function (url, input, applicationKey, hmacKey, instanceId) {\n        var data = new scope.ShapeRecognitionData();\n        _fillData(data, input, instanceId, applicationKey, hmacKey);\n\n        return scope.NetworkInterface.post(url + '/api/v3.0/recognition/rest/shape/doSimpleRecognition.json', data).then(\n            function success(response) {\n                return new scope.ShapeResult(response);\n            }\n        );\n    };\n\n    /**\n     * Clear shape recognition\n     *\n     * @private\n     * @method _clearShapeRecognition\n     * @param {String} url\n     * @param {String} instanceId\n     * @returns {Promise}\n     */\n    var _clearShapeRecognition = function (url, instanceId) {\n        var data = {\n            instanceSessionId: instanceId\n        };\n\n        return scope.NetworkInterface.post(url + '/api/v3.0/recognition/rest/shape/clearSessionId.json', data).then(\n            function success(response) {\n                return new scope.ShapeResult(response);\n            }\n        );\n    };\n\n    /**\n     * Do shape recognition\n     *\n     * @private\n     * @method _doMathRecognition\n     * @param {String} url\n     * @param {MathRecognitionInput} input\n     * @param {String} applicationKey\n     * @param {String} hmacKey\n     * @param {String} instanceId\n     * @returns {Promise}\n     */\n    var _doMathRecognition = function (url, input, applicationKey, hmacKey, instanceId) {\n        var data = new scope.MathRecognitionData();\n        _fillData(data, input, instanceId, applicationKey, hmacKey);\n\n        return scope.NetworkInterface.post(url + '/api/v3.0/recognition/rest/math/doSimpleRecognition.json', data).then(\n            function success(response) {\n                return new scope.MathResult(response);\n            }\n        );\n    };\n\n    /**\n     * Do music recognition\n     *\n     * @private\n     * @method _doMusicRecognition\n     * @param {String} url\n     * @param {MusicRecognitionInput} input\n     * @param {String} applicationKey\n     * @param {String} hmacKey\n     * @param {String} instanceId\n     * @returns {Promise}\n     */\n    var _doMusicRecognition = function (url, input, applicationKey, hmacKey, instanceId) {\n        var data = new scope.MusicRecognitionData();\n        _fillData(data, input, instanceId, applicationKey, hmacKey);\n\n        return scope.NetworkInterface.post(url + '/api/v3.0/recognition/rest/music/doSimpleRecognition.json', data).then(\n            function success(response) {\n                return new scope.MusicResult(response);\n            }\n        );\n    };\n\n    /**\n     * Do analyzer recognition\n     *\n     * @method _doAnalyzerRecognition\n     * @param {String} url\n     * @param {AnalyzerRecognitionInput} input\n     * @param {String} applicationKey\n     * @param {String} hmacKey\n     * @param {String} instanceId\n     * @returns {Promise}\n     */\n    var _doAnalyzerRecognition = function (url, input, applicationKey, hmacKey, instanceId) {\n        var data = new scope.AnalyzerRecognitionData();\n        _fillData(data, input, instanceId, applicationKey, hmacKey);\n\n        return scope.NetworkInterface.post(url + '/api/v3.0/recognition/rest/analyzer/doSimpleRecognition.json', data).then(\n            function success(response) {\n                return new scope.AnalyzerResult(response);\n            }\n        );\n    };\n\n    /**\n     * Compute HMAC signature for server authentication\n     *\n     * @private\n     * @method _computeHmac\n     * @param {AbstractRecognitionInput} input\n     * @param {String} applicationKey\n     * @param {String} hmacKey\n     */\n    var _computeHmac = function (input, applicationKey, hmacKey) {\n        var jsonInput = (typeof input === 'object') ? JSON.stringify(input) : input;\n        return CryptoJS.HmacSHA512(jsonInput, applicationKey + hmacKey).toString(CryptoJS.enc.Hex);\n    };\n\n    var _filterStrokes = function (components, precision) {\n        components.forEach(function (currentValue) {\n            if (currentValue instanceof scope.StrokeComponent) {\n                currentValue.toFixed(precision);\n            }\n        });\n    };\n\n    var _fillData = function (data, input, instanceId, applicationKey, hmacKey) {\n        data.setRecognitionInput(input);\n        data.setApplicationKey(applicationKey);\n        data.setInstanceId(instanceId);\n        if (hmacKey) {\n            data.setHmac(_computeHmac(data.getRecognitionInput(), applicationKey, hmacKey));\n        }\n    };\n\n    // Export\n    scope.AbstractRecognizer = AbstractRecognizer;\n})(MyScript, CryptoJS);\n\n\n\n(function (scope, CryptoJS) {\n    /**\n     * Abstract WebSocket recognizer interface\n     *\n     * @class AbstractWSRecognizer\n     * @constructor\n     */\n    function AbstractWSRecognizer() {\n        this._wsInterface = new scope.NetworkWSInterface();\n    }\n\n    AbstractWSRecognizer.prototype.getProtocol = function() {\n        return this._ssl? 'wss://': 'ws://';\n    };\n\n    AbstractWSRecognizer.prototype.getSSL = function() {\n        return this._ssl;\n    };\n\n    AbstractWSRecognizer.prototype.setSSL = function (ssl) {\n        if (ssl !== undefined) {\n            this._ssl = ssl;\n            this.setUrl(this.getProtocol() + this.getHost());\n        }\n    };\n\n    /**\n     * Get the recognition service host\n     *\n     * @method getHost\n     * @returns {string|String|*}\n     */\n    AbstractWSRecognizer.prototype.getHost = function() {\n        return scope.NetworkInterface.parseURL(this.getUrl()).host;\n    };\n\n    /**\n     * Set the recognition service host\n     *\n     * @method setHost\n     * @param {String}\n     */\n    AbstractWSRecognizer.prototype.setHost = function (host) {\n        if ((host !== undefined) && (host != this.getHost())) {\n            this.setUrl(this.getProtocol() + host);\n        }\n    };\n\n    AbstractWSRecognizer.prototype.setUrl = function (url) { // jshint ignore:line\n        throw new Error('not implemented');\n    };\n\n    AbstractWSRecognizer.prototype.getUrl = function () {\n        return this._wsInterface.getUrl();\n    };\n\n    AbstractWSRecognizer.prototype.setCallback = function (callback) { // jshint ignore:line\n        throw new Error('not implemented');\n    };\n\n    /**\n     * Get parameters\n     *\n     * @method getParameters\n     * @returns {AbstractParameter}\n     */\n    AbstractWSRecognizer.prototype.getParameters = function () {\n        return this.parameters;\n    };\n\n    /**\n     * Set parameters\n     *\n     * @method setParameters\n     * @param {AbstractParameter} parameters\n     */\n    AbstractWSRecognizer.prototype.setParameters = function (parameters) {\n        this.parameters = parameters;\n    };\n\n    /**\n     * Get precision\n     *\n     * @method getPrecision\n     * @returns {Number}\n     */\n    AbstractWSRecognizer.prototype.getPrecision = function () {\n        return this.precision;\n    };\n\n    /**\n     * Set precision\n     *\n     * @method setPrecision\n     * @param {Number} precision\n     */\n    AbstractWSRecognizer.prototype.setPrecision = function (precision) {\n        this.precision = precision;\n    };\n\n    AbstractWSRecognizer.prototype.isClosed = function () {\n        return this._wsInterface.isClosed();\n    };\n\n    AbstractWSRecognizer.prototype.isClosing = function () {\n        return this._wsInterface.isClosing();\n    };\n\n    AbstractWSRecognizer.prototype.isOpen = function () {\n        return this._wsInterface.isOpen();\n    };\n\n    AbstractWSRecognizer.prototype.isConnecting = function () {\n        return this._wsInterface.isConnecting();\n    };\n\n    /**\n     * Open the socket\n     *\n     * @method open\n     */\n    AbstractWSRecognizer.prototype.open = function () {\n        this._wsInterface.open();\n    };\n\n    /**\n     * Close the socket\n     *\n     * @method close\n     */\n    AbstractWSRecognizer.prototype.close = function () {\n        this._wsInterface.close();\n    };\n\n    /**\n     * Send a message\n     *\n     * @method sendMessage\n     * @param {AbstractWSMessage} message\n     */\n    AbstractWSRecognizer.prototype.sendMessage = function (message) {\n        if (message.getComponents) {\n            _filterStrokes(message.getComponents(), this.getPrecision());\n        } else if (message.getInputUnits) {\n            for (var i in message.getInputUnits()) {\n                _filterStrokes(message.getInputUnits()[i].getComponents(), this.getPrecision());\n            }\n        }\n        this._wsInterface.send(message);\n    };\n\n    /**\n     * Initialize the WebSocket\n     *\n     * @method initWSRecognition\n     * @param {String} applicationKey\n     */\n    AbstractWSRecognizer.prototype.initWSRecognition = function (applicationKey) {\n        var message = new scope.InitRequestWSMessage();\n        message.setApplicationKey(applicationKey);\n        this.sendMessage(message);\n    };\n\n    /**\n     * Authenticate the WebSocket client end with a handshake of HMAC signature\n     *\n     * @method takeUpHmacChallenge\n     * @param {String} applicationKey\n     * @param {String} challenge\n     * @param {String} hmacKey\n     */\n    AbstractWSRecognizer.prototype.takeUpHmacChallenge = function (applicationKey, challenge, hmacKey) {\n        var message = new scope.ChallengeRequestWSMessage();\n        message.setApplicationKey(applicationKey);\n        message.setChallenge(challenge);\n        if (hmacKey) {\n            message.setHmacSignature(_computeHmac(challenge, applicationKey, hmacKey));\n        }\n        this.sendMessage(message);\n    };\n\n    /**\n     * Reset the WebSocket recognition session\n     *\n     * @method resetWSRecognition\n     */\n    AbstractWSRecognizer.prototype.resetWSRecognition = function () {\n        var message = new scope.ResetRequestWSMessage();\n        this.sendMessage(message);\n    };\n\n    /**\n     * Compute HMAC signature for server authentication\n     *\n     * @private\n     * @method _computeHmac\n     * @param {String} input\n     * @param {String} applicationKey\n     * @param {String} hmacKey\n     */\n    var _computeHmac = function (input, applicationKey, hmacKey) {\n        var jsonInput = (typeof input === 'object') ? JSON.stringify(input) : input;\n        return CryptoJS.HmacSHA512(jsonInput, applicationKey + hmacKey).toString(CryptoJS.enc.Hex);\n    };\n\n    var _filterStrokes = function (components, precision) {\n        components.forEach(function (currentValue) {\n            if (currentValue instanceof scope.StrokeComponent) {\n                currentValue.toFixed(precision);\n            }\n        });\n    };\n\n    // Export\n    scope.AbstractWSRecognizer = AbstractWSRecognizer;\n})(MyScript, CryptoJS);\n\n\n\n(function (scope) {\n    /**\n     * Text recognizer interface\n     *\n     * @class TextRecognizer\n     * @extends AbstractRecognizer\n     * @param {String} [host='cloud.myscript.com'] Recognition service host\n     * @constructor\n     */\n    function TextRecognizer(host) {\n        scope.AbstractRecognizer.call(this, host);\n        this.parameters = new scope.TextParameter();\n        this.parameters.setLanguage('en_US');\n        this.parameters.setInputMode('CURSIVE');\n    }\n\n    /**\n     * Inheritance property\n     */\n    TextRecognizer.prototype = new scope.AbstractRecognizer();\n\n    /**\n     * Constructor property\n     */\n    TextRecognizer.prototype.constructor = TextRecognizer;\n\n    /**\n     * Do text recognition\n     *\n     * @method doSimpleRecognition\n     * @param {String} applicationKey\n     * @param {String} instanceId\n     * @param {AbstractComponent[]|TextInputUnit[]} components\n     * @param {String} hmacKey\n     * @param {TextParameter} [parameters]\n     * @returns {Promise}\n     */\n    TextRecognizer.prototype.doSimpleRecognition = function (applicationKey, instanceId, components, hmacKey, parameters) {\n        var params = this.getParameters();\n        if (parameters) {\n            params = parameters;\n        }\n        var inputUnits = [];\n        if (components && components.length > 0) {\n            if (components[0] instanceof scope.TextInputUnit) {\n                inputUnits = components;\n            } else {\n                var unit = new scope.TextInputUnit();\n                unit.setComponents(components);\n                inputUnits.push(unit);\n            }\n        }\n        var input = new scope.TextRecognitionInput();\n        input.setParameters(params);\n        input.setInputUnits(inputUnits);\n        return scope.AbstractRecognizer.prototype.doRestRecognition.call(this, input, applicationKey, hmacKey, instanceId); // super\n    };\n\n    // Export\n    scope.TextRecognizer = TextRecognizer;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * Text WebSocket recognizer interface\n     *\n     * @class TextWSRecognizer\n     * @extends AbstractWSRecognizer\n     * @param {Function} callback The WebSocket response callback\n     * @param {String} [host='cloud.myscript.com'] Recognition service host\n     * @constructor\n     */\n    function TextWSRecognizer(callback, host) {\n        scope.AbstractWSRecognizer.call(this);\n        this.parameters = new scope.TextParameter();\n        this.parameters.setLanguage('en_US');\n        this.parameters.setInputMode('CURSIVE');\n        this.setUrl(this.getProtocol() + 'cloud.myscript.com');\n        if (host) {\n            this.setUrl(this.getProtocol() + host);\n        }\n        this.setSSL(true);\n        this.setCallback(callback);\n    }\n\n    /**\n     * Inheritance property\n     */\n    TextWSRecognizer.prototype = new scope.AbstractWSRecognizer();\n\n    /**\n     * Constructor property\n     */\n    TextWSRecognizer.prototype.constructor = TextWSRecognizer;\n\n    /**\n     * Get parameters\n     *\n     * @method getParameters\n     * @returns {TextParameter}\n     */\n    TextWSRecognizer.prototype.getParameters = function () {\n        return this.parameters;\n    };\n\n    /**\n     * Set parameters\n     *\n     * @method setParameters\n     * @param {TextParameter} parameters\n     */\n    TextWSRecognizer.prototype.setParameters = function (parameters) {\n        this.parameters = parameters;\n    };\n\n    TextWSRecognizer.prototype.setUrl = function (url) {\n        if (url !== undefined) {\n            this._wsInterface.setUrl(url + '/api/v3.0/recognition/ws/text');\n        }\n    };\n\n    TextWSRecognizer.prototype.setCallback = function (callback) {\n        if (callback !== undefined) {\n            this._wsInterface.setCallback(function (message) {\n                switch (message.type) {\n                    case 'open':\n                        callback(message);\n                        break;\n                    case 'close':\n                        callback(message);\n                        break;\n                    case 'error':\n                        callback(undefined, message);\n                        break;\n                    default:\n                        switch (message.data.type) {\n                            case 'init':\n                                message.data = new scope.InitResponseWSMessage(message.data);\n                                callback(message.data);\n                                break;\n                            case 'reset':\n                                message.data = new scope.ResetResponseWSMessage(message.data);\n                                callback(message.data);\n                                break;\n                            case 'error':\n                                message.data = new scope.ErrorResponseWSMessage(message.data);\n                                callback(undefined, new Error(JSON.stringify(message.data.getError())));\n                                break;\n                            case 'hmacChallenge':\n                                message.data = new scope.ChallengeResponseWSMessage(message.data);\n                                callback(message.data);\n                                break;\n                            default:\n                                message.data = new scope.TextResponseWSMessage(message.data);\n                                callback(message.data);\n                                break;\n                        }\n                        break;\n                }\n            });\n        }\n    };\n\n    /**\n     * Start the WebSocket session\n     *\n     * @method startWSRecognition\n     * @param {AbstractComponent[]|TextInputUnit[]} components\n     * @param {TextParameter} [parameters]\n     */\n    TextWSRecognizer.prototype.startWSRecognition = function (components, parameters) {\n        var message = new scope.TextStartRequestWSMessage();\n        var params = this.getParameters();\n        if (parameters) {\n            params = parameters;\n        }\n        var inputUnits = [];\n        if (components && components.length > 0) {\n            if (components[0] instanceof scope.TextInputUnit) {\n                inputUnits = components;\n            } else {\n                var unit = new scope.TextInputUnit();\n                unit.setComponents(components);\n                inputUnits.push(unit);\n            }\n        }\n        message.setParameters(params);\n        message.setInputUnits(inputUnits);\n        this.sendMessage(message);\n    };\n\n    /**\n     * Continue the recognition\n     *\n     * @method continueWSRecognition\n     * @param {AbstractComponent[]|TextInputUnit[]} components\n     * @param {String} instanceId\n     */\n    TextWSRecognizer.prototype.continueWSRecognition = function (components, instanceId) {\n        var message = new scope.TextContinueRequestWSMessage();\n        var inputUnits = [];\n        if (components && components.length > 0) {\n            if (components[0] instanceof scope.TextInputUnit) {\n                inputUnits = components;\n            } else {\n                var unit = new scope.TextInputUnit();\n                unit.setComponents(components);\n                inputUnits.push(unit);\n            }\n        }\n        message.setInputUnits(inputUnits);\n        message.setInstanceId(instanceId);\n        this.sendMessage(message);\n    };\n\n    // Export\n    scope.TextWSRecognizer = TextWSRecognizer;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * Shape recognizer interface\n     *\n     * @class ShapeRecognizer\n     * @extends AbstractRecognizer\n     * @param {String} [host='cloud.myscript.com'] Recognition service host\n     * @constructor\n     */\n    function ShapeRecognizer(host) {\n        scope.AbstractRecognizer.call(this, host);\n        this.parameters = new scope.ShapeParameter();\n    }\n\n    /**\n     * Inheritance property\n     */\n    ShapeRecognizer.prototype = new scope.AbstractRecognizer();\n\n    /**\n     * Constructor property\n     */\n    ShapeRecognizer.prototype.constructor = ShapeRecognizer;\n\n    /**\n     * Do shape recognition\n     *\n     * @method doSimpleRecognition\n     * @param {String} applicationKey\n     * @param {String} instanceId\n     * @param {AbstractComponent[]} components\n     * @param {String} hmacKey\n     * @param {ShapeParameter} [parameters]\n     * @returns {Promise}\n     */\n    ShapeRecognizer.prototype.doSimpleRecognition = function (applicationKey, instanceId, components, hmacKey, parameters) {\n        var params = this.getParameters();\n        if (parameters) {\n            params = parameters;\n        }\n        var input = new scope.ShapeRecognitionInput();\n        input.setParameters(params);\n        input.setComponents(components);\n        return scope.AbstractRecognizer.prototype.doRestRecognition.call(this, input, applicationKey, hmacKey, instanceId); // super\n    };\n\n    /**\n     * Clear shape recognition session\n     *\n     * @method clearShapeRecognitionSession\n     * @param {String} applicationKey\n     * @param {String} instanceId\n     * @returns {Promise}\n     */\n    ShapeRecognizer.prototype.clearShapeRecognitionSession = function (applicationKey, instanceId) {\n        return scope.AbstractRecognizer.prototype.clearRestRecognition.call(this, instanceId); // super\n    };\n\n    // Export\n    scope.ShapeRecognizer = ShapeRecognizer;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * Math recognizer interface\n     *\n     * @class MathRecognizer\n     * @extends AbstractRecognizer\n     * @param {String} [host='cloud.myscript.com'] Recognition service host\n     * @constructor\n     */\n    function MathRecognizer(host) {\n        scope.AbstractRecognizer.call(this, host);\n        this.parameters = new scope.MathParameter();\n    }\n\n    /**\n     * Inheritance property\n     */\n    MathRecognizer.prototype = new scope.AbstractRecognizer();\n\n    /**\n     * Constructor property\n     */\n    MathRecognizer.prototype.constructor = MathRecognizer;\n\n    /**\n     * Do math recognition\n     *\n     * @method doSimpleRecognition\n     * @param {String} applicationKey\n     * @param {String} instanceId\n     * @param {AbstractComponent[]} components\n     * @param {String} hmacKey\n     * @param {MathParameter} [parameters]\n     * @returns {Promise}\n     */\n    MathRecognizer.prototype.doSimpleRecognition = function (applicationKey, instanceId, components, hmacKey, parameters) {\n        var params = this.getParameters();\n        if (parameters) {\n            params = parameters;\n        }\n        var input = new scope.MathRecognitionInput();\n        input.setParameters(params);\n        input.setComponents(components);\n        return scope.AbstractRecognizer.prototype.doRestRecognition.call(this, input, applicationKey, hmacKey, instanceId); // super\n    };\n\n    // Export\n    scope.MathRecognizer = MathRecognizer;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * Math WebSocket recognizer interface\n     *\n     * @class MathWSRecognizer\n     * @extends AbstractWSRecognizer\n     * @param {Function} callback The WebSocket response callback\n     * @param {String} [host='cloud.myscript.com'] Recognition service host\n     * @constructor\n     */\n    function MathWSRecognizer(callback, host) {\n        scope.AbstractWSRecognizer.call(this);\n        this.parameters = new scope.MathParameter();\n        this.setUrl(this.getProtocol() + 'cloud.myscript.com');\n        if (host) {\n            this.setUrl(this.getProtocol() + host);\n        }\n        this.setSSL(true);\n        this.setCallback(callback);\n    }\n\n    /**\n     * Inheritance property\n     */\n    MathWSRecognizer.prototype = new scope.AbstractWSRecognizer();\n\n    /**\n     * Constructor property\n     */\n    MathWSRecognizer.prototype.constructor = MathWSRecognizer;\n\n    /**\n     * Get parameters\n     *\n     * @method getParameters\n     * @returns {MathParameter}\n     */\n    MathWSRecognizer.prototype.getParameters = function () {\n        return this.parameters;\n    };\n\n    /**\n     * Set parameters\n     *\n     * @method setParameters\n     * @param {MathParameter} parameters\n     */\n    MathWSRecognizer.prototype.setParameters = function (parameters) {\n        this.parameters = parameters;\n    };\n\n    MathWSRecognizer.prototype.setUrl = function (url) {\n        if (url !== undefined) {\n            this._wsInterface.setUrl(url + '/api/v3.0/recognition/ws/math');\n        }\n    };\n\n    MathWSRecognizer.prototype.setCallback = function (callback) {\n        if (callback !== undefined) {\n            this._wsInterface.setCallback(function (message) {\n                switch (message.type) {\n                    case 'open':\n                        callback(message);\n                        break;\n                    case 'close':\n                        callback(message);\n                        break;\n                    case 'error':\n                        callback(undefined, message);\n                        break;\n                    default:\n                        switch (message.data.type) {\n                            case 'init':\n                                message.data = new scope.InitResponseWSMessage(message.data);\n                                callback(message.data);\n                                break;\n                            case 'reset':\n                                message.data = new scope.ResetResponseWSMessage(message.data);\n                                callback(message.data);\n                                break;\n                            case 'error':\n                                message.data = new scope.ErrorResponseWSMessage(message.data);\n                                callback(undefined, new Error(JSON.stringify(message.data.getError())));\n                                break;\n                            case 'hmacChallenge':\n                                message.data = new scope.ChallengeResponseWSMessage(message.data);\n                                callback(message.data);\n                                break;\n                            default:\n                                message.data = new scope.MathResponseWSMessage(message.data);\n                                callback(message.data);\n                                break;\n                        }\n                        break;\n                }\n            });\n        }\n    };\n\n    /**\n     * Start the WebSocket session\n     *\n     * @method startWSRecognition\n     * @param {AbstractComponent[]} components\n     * @param {MathParameter} [parameters]\n     */\n    MathWSRecognizer.prototype.startWSRecognition = function (components, parameters) {\n        var message = new scope.MathStartRequestWSMessage();\n        var params = this.getParameters();\n        if (parameters) {\n            params = parameters;\n        }\n        message.setParameters(params);\n        message.setComponents(components);\n        this.sendMessage(message);\n    };\n\n    /**\n     * Continue the recognition\n     *\n     * @method continueWSRecognition\n     * @param {AbstractComponent[]} components\n     * @param {String} instanceId\n     */\n    MathWSRecognizer.prototype.continueWSRecognition = function (components, instanceId) {\n        var message = new scope.MathContinueRequestWSMessage();\n        message.setComponents(components);\n        message.setInstanceId(instanceId);\n        this.sendMessage(message);\n    };\n\n    // Export\n    scope.MathWSRecognizer = MathWSRecognizer;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * Music recognizer interface\n     *\n     * @class MusicRecognizer\n     * @extends AbstractRecognizer\n     * @param {String} [host='cloud.myscript.com'] Recognition service host\n     * @constructor\n     */\n    function MusicRecognizer(host) {\n        scope.AbstractRecognizer.call(this, host);\n        this.parameters = new scope.MusicParameter();\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicRecognizer.prototype = new scope.AbstractRecognizer();\n\n    /**\n     * Constructor property\n     */\n    MusicRecognizer.prototype.constructor = MusicRecognizer;\n\n    /**\n     * Do music recognition\n     *\n     * @method doSimpleRecognition\n     * @param {String} applicationKey\n     * @param {String} instanceId\n     * @param {AbstractComponent[]} components\n     * @param {String} hmacKey\n     * @param {MusicParameter} [parameters]\n     * @returns {Promise}\n     */\n    MusicRecognizer.prototype.doSimpleRecognition = function (applicationKey, instanceId, components, hmacKey, parameters) {\n        var params = this.getParameters();\n        if (parameters) {\n            params = parameters;\n        }\n        var input = new scope.MusicRecognitionInput();\n        input.setParameters(params);\n        input.setComponents(components);\n        return scope.AbstractRecognizer.prototype.doRestRecognition.call(this, input, applicationKey, hmacKey, instanceId); // super\n    };\n\n    // Export\n    scope.MusicRecognizer = MusicRecognizer;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * Analyzer recognizer interface\n     *\n     * @class AnalyzerRecognizer\n     * @extends AbstractRecognizer\n     * @param {String} [host='cloud.myscript.com'] Recognition service host\n     * @constructor\n     */\n    function AnalyzerRecognizer(host) {\n        scope.AbstractRecognizer.call(this, host);\n        this.parameters = new scope.AnalyzerParameter();\n    }\n\n    /**\n     * Inheritance property\n     */\n    AnalyzerRecognizer.prototype = new scope.AbstractRecognizer();\n\n    /**\n     * Constructor property\n     */\n    AnalyzerRecognizer.prototype.constructor = AnalyzerRecognizer;\n\n    /**\n     * Do analyzer recognition\n     *\n     * @method doSimpleRecognition\n     * @param {String} applicationKey\n     * @param {String} instanceId\n     * @param {AbstractComponent[]} components\n     * @param {String} hmacKey\n     * @param {AnalyzerParameter} [parameters]\n     * @returns {Promise}\n     */\n    AnalyzerRecognizer.prototype.doSimpleRecognition = function (applicationKey, instanceId, components, hmacKey, parameters) {\n        var params = this.getParameters();\n        if (parameters) {\n            params = parameters;\n        }\n        var input = new scope.AnalyzerRecognitionInput();\n        input.setParameters(params);\n        input.setComponents(components);\n        return scope.AbstractRecognizer.prototype.doRestRecognition.call(this, input, applicationKey, hmacKey, instanceId); // super\n    };\n\n    // Export\n    scope.AnalyzerRecognizer = AnalyzerRecognizer;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * Represent the Abstract Renderer. It's used to calculate the ink rendering in HTML5 canvas\n     *\n     * @class AbstractRenderer\n     * @param {Object} context\n     * @constructor\n     */\n    function AbstractRenderer(context) {\n        this.penParameters = new scope.PenParameters();\n        this.showBoundingBoxes = false;\n        this.typeset = true;\n        this.context = context;\n    }\n\n    /**\n     * Get the context\n     *\n     * @returns {Object}\n     */\n    AbstractRenderer.prototype.getContext = function () {\n        return this.context;\n    };\n\n    /**\n     * This property is use to show or not show the bounding box\n     *\n     * @method getShowBoundingBoxes\n     * @returns {Boolean}\n     */\n    AbstractRenderer.prototype.getShowBoundingBoxes = function () {\n        return this.showBoundingBoxes;\n    };\n\n    /**\n     * Set the show state of bounding box\n     *\n     * @method setShowBoundingBoxes\n     * @param {Boolean} showBoundingBoxes\n     */\n    AbstractRenderer.prototype.setShowBoundingBoxes = function (showBoundingBoxes) {\n        this.showBoundingBoxes = showBoundingBoxes;\n    };\n\n    /**\n     * Get the default pen parameters\n     *\n     * @returns {PenParameters}\n     */\n    AbstractRenderer.prototype.getParameters = function () {\n        return this.penParameters;\n    };\n\n    /**\n     * Set the default pen parameters\n     *\n     * @param {PenParameters} penParameters\n     */\n    AbstractRenderer.prototype.setParameters = function (penParameters) {\n        this.penParameters = penParameters;\n    };\n\n    /**\n     * Is typesetting\n     *\n     * @returns {Boolean}\n     */\n    AbstractRenderer.prototype.isTypesetting = function () {\n        return this.typeset;\n    };\n\n    /**\n     * Enable / disable typesetting\n     *\n     * @param {Boolean} typeset\n     */\n    AbstractRenderer.prototype.setTypeset = function (typeset) {\n        this.typeset = typeset;\n    };\n\n    /**\n     * Clear the recognition context\n     *\n     * @method clear\n     */\n    AbstractRenderer.prototype.clear = function () {\n        this.getContext().clearRect(0, 0, this.getContext().canvas.width, this.getContext().canvas.height);\n    };\n\n    /**\n     * Draw recognition result on HTML5 canvas.\n     *\n     * @method drawRecognitionResult\n     * @param {AbstractComponent[]} components\n     * @param {Object} recognitionResult\n     */\n    AbstractRenderer.prototype.drawRecognitionResult = function (components, recognitionResult) { // jshint ignore:line\n        throw new Error('not implemented');\n    };\n\n    /**\n     * Draw input components\n     *\n     * @method drawComponents\n     * @param {AbstractComponent[]} components\n     */\n    AbstractRenderer.prototype.drawComponents = function (components) { // jshint ignore:line\n        throw new Error('not implemented');\n    };\n\n    /**\n     * Draw component\n     *\n     * @method drawComponent\n     * @param {AbstractComponent} component\n     */\n    AbstractRenderer.prototype.drawComponent = function (component) {\n        if (component instanceof scope.StrokeComponent) {\n            _drawStroke(component, this.getContext(), this.getParameters());\n        } else if (component instanceof scope.CharacterInputComponent) {\n            _drawCharacter(component, this.getContext(), this.getParameters());\n        } else {\n            throw new Error('Component not implemented: ' + component.getType());\n        }\n    };\n\n    /**\n     * Draw stroke component\n     *\n     * @private\n     * @method _drawStroke\n     * @param {StrokeComponent} stroke\n     * @param {Object} context\n     * @param {PenParameters} parameters\n     */\n    var _drawStroke = function (stroke, context, parameters) { // jshint ignore:line\n        if (stroke && stroke.getLength() > 0) {\n            _renderStroke(stroke, context);\n        }\n    };\n\n    /**\n     * Draw character component\n     *\n     * @private\n     * @method _drawCharacter\n     * @param {CharacterInputComponent} character\n     * @param {Object} context\n     * @param {PenParameters} parameters\n     */\n    var _drawCharacter = function (character, context, parameters) { // jshint ignore:line\n        throw new Error('not implemented');\n    };\n\n    /**\n     * Draw a rectangle on context\n     *\n     * @private\n     * @method _drawRectangle\n     * @param {Rectangle} rectangle\n     * @param {Object} context\n     * @param {PenParameters} parameters\n     */\n    var _drawRectangle = function (rectangle, context, parameters) {\n        context.save();\n        try {\n            context.fillStyle = parameters.getRectColor();\n            context.strokeStyle = parameters.getColor();\n            context.lineWidth = 0.5 * parameters.getWidth();\n            context.fillRect(rectangle.getX(), rectangle.getY(), rectangle.getWidth(), rectangle.getHeight());\n        } finally {\n            context.restore();\n        }\n    };\n\n    /*******************************************************************************************************************\n     * Algorithm methods to compute rendering\n     ******************************************************************************************************************/\n\n    function _computeLinksPoints(point, angle, width) {\n        var radius = point.p * width;\n        return [{\n            x: (point.x - Math.sin(angle) * radius),\n            y: (point.y + Math.cos(angle) * radius)\n        }, {\n            x: (point.x + Math.sin(angle) * radius),\n            y: (point.y - Math.cos(angle) * radius)\n        }\n        ];\n    }\n\n    function _computeMiddlePoint(point1, point2) {\n        return {\n            x: ((point2.x + point1.x) / 2),\n            y: ((point2.y + point1.y) / 2),\n            p: ((point2.p + point1.p) / 2)\n        };\n    }\n\n    function _computeAxeAngle(begin, end) {\n        return Math.atan2(end.y - begin.y, end.x - begin.x);\n    }\n\n    function _fill(context, color) {\n        if (color !== undefined) {\n            context.fillStyle = color;\n            context.fill();\n        }\n    }\n\n    /**\n     *\n     * @param stroke\n     * @param context\n     * @param parameters\n     * @private\n     */\n    function _renderStroke(stroke, context) {\n        context.beginPath();\n        var length = stroke.getLength();\n        var width = stroke.getWidth();\n        var firstPoint = stroke.getPointByIndex(0);\n        if (length < 3) {\n            context.arc(firstPoint.x, firstPoint.y, width * 0.6, 0, Math.PI * 2, true);\n        } else {\n            context.arc(firstPoint.x, firstPoint.y, width * firstPoint.p, 0, Math.PI * 2, true);\n            _renderLine(context, firstPoint, _computeMiddlePoint(firstPoint, stroke.getPointByIndex(1)), width);\n\n            // Possibility to try this (the start looks better when the ink is large)\n            //var first = _computeMiddlePoint(stroke[0], stroke[1]);\n            //context.arc(first.x, first.y, width * first.p, 0, Math.PI * 2, true);\n\n            var nbquadratics = length - 2;\n            for (var i = 0; i < nbquadratics; i++) {\n                _renderQuadratic(context, _computeMiddlePoint(stroke.getPointByIndex(i), stroke.getPointByIndex(i + 1)), _computeMiddlePoint(stroke.getPointByIndex(i + 1), stroke.getPointByIndex(i + 2)), stroke.getPointByIndex(i + 1), width);\n            }\n            _renderLine(context, _computeMiddlePoint(stroke.getPointByIndex(length - 2), stroke.getPointByIndex(length - 1)), stroke.getPointByIndex(length - 1), width);\n            _renderFinal(context, stroke.getPointByIndex(length - 2), stroke.getPointByIndex(length - 1), width);\n        }\n        context.closePath();\n        _fill(context, stroke.getColor());\n    }\n\n    function _renderFinal(context, begin, end, width) {\n        var ARCSPLIT = 6;\n        var angle = _computeAxeAngle(begin, end);\n        var linkPoints = _computeLinksPoints(end, angle, width);\n        context.moveTo(linkPoints[0].x, linkPoints[0].y);\n        for (var i = 1; i <= ARCSPLIT; i++) {\n            var newAngle = angle - i * Math.PI / ARCSPLIT;\n            context.lineTo(end.x - end.p * width * Math.sin(newAngle), end.y + end.p * width * Math.cos(newAngle));\n        }\n    }\n\n    function _renderLine(context, begin, end, width) {\n        var linkPoints1 = _computeLinksPoints(begin, _computeAxeAngle(begin, end), width);\n        var linkPoints2 = _computeLinksPoints(end, _computeAxeAngle(begin, end), width);\n\n        context.moveTo(linkPoints1[0].x, linkPoints1[0].y);\n        context.lineTo(linkPoints2[0].x, linkPoints2[0].y);\n        context.lineTo(linkPoints2[1].x, linkPoints2[1].y);\n        context.lineTo(linkPoints1[1].x, linkPoints1[1].y);\n    }\n\n    function _renderQuadratic(context, begin, end, ctrl, width) {\n        var linkPoints1 = _computeLinksPoints(begin, _computeAxeAngle(begin, ctrl), width);\n        var linkPoints2 = _computeLinksPoints(end, _computeAxeAngle(ctrl, end), width);\n        var linkPoints3 = _computeLinksPoints(ctrl, _computeAxeAngle(begin, end), width);\n\n        context.moveTo(linkPoints1[0].x, linkPoints1[0].y);\n        context.quadraticCurveTo(linkPoints3[0].x, linkPoints3[0].y, linkPoints2[0].x, linkPoints2[0].y);\n        context.lineTo(linkPoints2[1].x, linkPoints2[1].y);\n        context.quadraticCurveTo(linkPoints3[1].x, linkPoints3[1].y, linkPoints1[1].x, linkPoints1[1].y);\n    }\n\n    // Export\n    scope.AbstractRenderer = AbstractRenderer;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * Represent the Text Renderer. It's used to calculate the text ink rendering in HTML5 canvas\n     *\n     * @class TextRenderer\n     * @extends AbstractRenderer\n     * @param {Object} context\n     * @constructor\n     */\n    function TextRenderer(context) {\n        scope.AbstractRenderer.call(this, context);\n    }\n\n    /**\n     * Inheritance property\n     */\n    TextRenderer.prototype = new scope.AbstractRenderer();\n\n    /**\n     * Constructor property\n     */\n    TextRenderer.prototype.constructor = TextRenderer;\n\n    /**\n     * Draw text recognition result on HTML5 canvas. Scratch out results are use to redraw HTML5 Canvas\n     *\n     * @method drawRecognitionResult\n     * @param {AbstractComponent[]} components\n     * @param {TextDocument} recognitionResult\n     */\n    TextRenderer.prototype.drawRecognitionResult = function (components, recognitionResult) {\n        this.clear();\n        if (recognitionResult) {\n            this.drawComponents(components);\n        } else {\n            this.drawComponents(components);\n        }\n    };\n\n    /**\n     * Draw components\n     *\n     * @method drawComponents\n     * @param {AbstractComponent[]} components\n     */\n    TextRenderer.prototype.drawComponents = function (components) {\n        for (var i in components) {\n            var component = components[i];\n            if (component instanceof scope.TextInputUnit) {\n                this.drawComponents(component.getComponents());\n            } else if (component instanceof scope.AbstractTextInputComponent) {\n                _drawTextComponent(component, this.getContext(), this.getParameters());\n            } else if (component instanceof scope.AbstractComponent) {\n                scope.AbstractRenderer.prototype.drawComponent.call(this, component); // super\n            } else {\n                throw new Error('not implemented');\n            }\n        }\n    };\n\n    /**\n     * Draw text component\n     *\n     * @private\n     * @method _drawTextComponent\n     * @param {AbstractTextInputComponent} component\n     * @param {Object} context\n     * @param {PenParameters} parameters\n     */\n    var _drawTextComponent = function (component, context, parameters) {\n        if (component instanceof scope.CharInputComponent) {\n            _drawChar(component, context, parameters);\n        } else if (component instanceof scope.StringInputComponent) {\n            _drawString(component, context, parameters);\n        } else {\n            throw new Error('Component not implemented: ' + component.getType());\n        }\n    };\n\n    /**\n     * Draw char\n     *\n     * @private\n     * @method _drawChar\n     * @param {CharInputComponent} char\n     * @param {Object} context The canvas 2d context\n     * @param {PenParameters} parameters\n     */\n    var _drawChar = function (char, context, parameters) { // jshint ignore:line\n        throw new Error('not implemented');\n    };\n\n    /**\n     * Draw string\n     *\n     * @private\n     * @method _drawString\n     * @param {StringInputComponent} string\n     * @param {Object} context The canvas 2d context\n     * @param {PenParameters} parameters\n     */\n    var _drawString = function (string, context, parameters) { // jshint ignore:line\n        throw new Error('not implemented');\n    };\n\n    // Export\n    scope.TextRenderer = TextRenderer;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * Represent the Shape Renderer. It's used to calculate the shape ink rendering in HTML5 canvas\n     *\n     * @class ShapeRenderer\n     * @extends AbstractRenderer\n     * @param {Object} context\n     * @constructor\n     */\n    function ShapeRenderer(context) {\n        scope.AbstractRenderer.call(this, context);\n    }\n\n    /**\n     * Inheritance property\n     */\n    ShapeRenderer.prototype = new scope.AbstractRenderer();\n\n    /**\n     * Constructor property\n     */\n    ShapeRenderer.prototype.constructor = ShapeRenderer;\n\n    /**\n     * Draw shape recognition result on HTML5 canvas\n     *\n     * @method drawRecognitionResult\n     * @param {AbstractComponent[]} components\n     * @param {ShapeDocument} document\n     */\n    ShapeRenderer.prototype.drawRecognitionResult = function (components, document) {\n        this.clear();\n        if (document && (document instanceof scope.ShapeDocument)) {\n            this.drawShapes(components, document.getSegments());\n            var lastComponents = [];\n            var processedComponents = _extractComponents(components, document.getInkRanges());\n\n            for (var i in components) {\n                var component = components[i];\n                if (processedComponents.indexOf(component) !== -1) {\n                    lastComponents.push(component);\n                }\n            }\n            this.drawComponents(lastComponents);\n        } else {\n            this.drawComponents(components);\n        }\n        return {components : components, document : document}\n    };\n\n    /**\n     * Draw components\n     *\n     * @method drawComponents\n     * @param {AbstractComponent[]} components\n     */\n    ShapeRenderer.prototype.drawComponents = function (components) {\n        for (var i in components) {\n            var component = components[i];\n            if (component instanceof scope.AbstractShapePrimitive) {\n                _drawShapePrimitive(component, this.getContext(), this.getParameters());\n            } else if (component instanceof scope.AbstractComponent) {\n                scope.AbstractRenderer.prototype.drawComponent.call(this, component); // super\n            } else {\n                throw new Error('not implemented');\n            }\n        }\n    };\n\n    /**\n     * Draw the shapes\n     *\n     * @method drawShapes\n     * @param {AbstractComponent[]} components\n     * @param {ShapeSegment[]} shapes\n     */\n    ShapeRenderer.prototype.drawShapes = function (components, shapes) {\n        for (var i in shapes) {\n            this.drawShapeSegment(components, shapes[i]);\n        }\n    };\n\n    /**\n     * Draw shape segment\n     *\n     * @method drawShapeSegment\n     * @param {AbstractComponent[]} components\n     * @param {ShapeSegment} segment\n     */\n    ShapeRenderer.prototype.drawShapeSegment = function (components, segment) {\n        var candidate = segment.getSelectedCandidate();\n        if (candidate instanceof scope.ShapeRecognized) {\n            _drawShapeRecognized(candidate, this.getContext(), this.getParameters());\n        } else if (candidate instanceof scope.ShapeNotRecognized) {\n            this.drawComponents(_extractComponents(components, segment.getInkRanges()));\n        } else {\n            throw new Error('not implemented');\n        }\n    };\n\n    /**\n     * This method allow you to draw not recognized shape\n     *\n     * @method drawShapeNotRecognized\n     * @param {AbstractComponent[]} components\n     * @param {ShapeInkRange[]} inkRanges\n     */\n    ShapeRenderer.prototype.drawShapeNotRecognized = function (components, inkRanges) {\n        this.drawComponents(_extractComponents(components, inkRanges));\n    };\n\n    /**\n     * Draw shape primitive\n     *\n     * @method drawShapePrimitive\n     * @param {AbstractShapePrimitive} primitive\n     */\n    ShapeRenderer.prototype.drawShapePrimitive = function (primitive) {\n        _drawShapePrimitive(primitive, this.getContext(), this.getParameters());\n    };\n\n    /**\n     * This method allow you to draw recognized shape\n     *\n     * @private\n     * @method _drawShapeRecognized\n     * @param {ShapeRecognized} shapeRecognized\n     * @param {Object} context\n     * @param {PenParameters} parameters\n     */\n    var _drawShapeRecognized = function (shapeRecognized, context, parameters) {\n        for (var i in shapeRecognized.getPrimitives()) {\n            _drawShapePrimitive(shapeRecognized.getPrimitives()[i], context, parameters);\n        }\n    };\n\n    /**\n     * Draw shape primitive\n     *\n     * @private\n     * @method _drawShapePrimitive\n     * @param {AbstractShapePrimitive} primitive\n     * @param {Object} context\n     * @param {PenParameters} parameters\n     */\n    var _drawShapePrimitive = function (primitive, context, parameters) {\n        if (primitive instanceof scope.ShapeEllipse) {\n            _drawShapeEllipse(primitive, context, parameters);\n        } else if (primitive instanceof scope.ShapeLine) {\n            _drawShapeLine(primitive, context, parameters);\n        } else {\n            throw new Error('Primitive not implemented: ' + primitive.getType());\n        }\n    };\n\n    /**\n     * Draw shape line\n     *\n     * @private\n     * @method _drawShapeLine\n     * @param {ShapeLine} shapeLine\n     * @param {Object} context\n     * @param {PenParameters} parameters\n     */\n    var _drawShapeLine = function (shapeLine, context, parameters) {\n        _drawLine(shapeLine.getFirstPoint(), shapeLine.getLastPoint(), context, parameters);\n        if (shapeLine.hasBeginDecoration() && shapeLine.getBeginDecoration() === 'ARROW_HEAD') {\n            _drawArrowHead(shapeLine.getFirstPoint(), shapeLine.getBeginTangentAngle(), 12.0, context, parameters);\n        }\n        if (shapeLine.hasEndDecoration() && shapeLine.getEndDecoration() === 'ARROW_HEAD') {\n            _drawArrowHead(shapeLine.getLastPoint(), shapeLine.getEndTangentAngle(), 12.0, context, parameters);\n        }\n    };\n\n    /**\n     * Draw shape ellipse\n     *\n     * @private\n     * @method _drawShapeEllipse\n     * @param {ShapeEllipse} shapeEllipse\n     * @param {Object} context\n     * @param {PenParameters} parameters\n     */\n    var _drawShapeEllipse = function (shapeEllipse, context, parameters) {\n        var points = _drawEllipseArc(\n            shapeEllipse.getCenter(),\n            shapeEllipse.getMaxRadius(),\n            shapeEllipse.getMinRadius(),\n            shapeEllipse.getOrientation(),\n            shapeEllipse.getStartAngle(),\n            shapeEllipse.getSweepAngle(),\n            context, parameters);\n\n        if (shapeEllipse.hasBeginDecoration() && shapeEllipse.getBeginDecoration() === 'ARROW_HEAD') {\n            _drawArrowHead(points[0], shapeEllipse.getBeginTangentAngle(), 12.0, context, parameters);\n        }\n        if (shapeEllipse.hasEndDecoration() && shapeEllipse.getEndDecoration() === 'ARROW_HEAD') {\n            _drawArrowHead(points[1], shapeEllipse.getEndTangentAngle(), 12.0, context, parameters);\n        }\n    };\n\n    /**\n     * Draw an ellipse arc on context\n     *\n     * @private\n     * @method _drawEllipseArc\n     * @param {Point} centerPoint\n     * @param {Number} maxRadius\n     * @param {Number} minRadius\n     * @param {String} orientation\n     * @param {Number} startAngle\n     * @param {Number} sweepAngle\n     * @param {Object} context The canvas 2d context\n     * @param {PenParameters} parameters\n     * @returns {Point[]}\n     */\n    var _drawEllipseArc = function (centerPoint, maxRadius, minRadius, orientation, startAngle, sweepAngle, context, parameters) {\n\n        var angleStep = 0.02; // angle delta between interpolated\n\n        var z1 = Math.cos(orientation);\n        var z3 = Math.sin(orientation);\n        var z2 = z1;\n        var z4 = z3;\n        z1 *= maxRadius;\n        z2 *= minRadius;\n        z3 *= maxRadius;\n        z4 *= minRadius;\n\n        var n = Math.floor(Math.abs(sweepAngle) / angleStep);\n\n        var boundariesPoints = [];\n\n        context.save();\n        try {\n            context.fillStyle = parameters.getColor();\n            context.strokeStyle = parameters.getColor();\n            context.lineWidth = 0.5 * parameters.getWidth();\n\n            context.beginPath();\n\n            for (var i = 0; i <= n; i++) {\n\n                var angle = startAngle + (i / n) * sweepAngle; // points on the arc, in radian\n                var alpha = Math.atan2(Math.sin(angle) / minRadius, Math.cos(angle) / maxRadius);\n\n                var cosAlpha = Math.cos(alpha);\n                var sinAlpha = Math.sin(alpha);\n\n                // current point\n                var x = centerPoint.x + z1 * cosAlpha - z4 * sinAlpha;\n                var y = centerPoint.y + z2 * sinAlpha + z3 * cosAlpha;\n                if (i === 0) {\n                    context.moveTo(x, y);\n                } else {\n                    context.lineTo(x, y);\n                }\n\n                if (i === 0 || i === n) {\n                    boundariesPoints.push(new scope.Point({x: x, y: y}));\n                }\n            }\n\n            context.stroke();\n\n        } finally {\n            context.restore();\n        }\n\n        return boundariesPoints;\n    };\n\n    /**\n     * Draw a line on context\n     *\n     * @private\n     * @method _drawLine\n     * @param {Point} p1\n     * @param {Point} p2\n     * @param {Object} context The canvas 2d context\n     * @param {PenParameters} parameters\n     */\n    var _drawLine = function (p1, p2, context, parameters) {\n        context.save();\n        try {\n            context.fillStyle = parameters.getColor();\n            context.strokeStyle = parameters.getColor();\n            context.lineWidth = 0.5 * parameters.getWidth();\n\n            context.beginPath();\n            context.moveTo(p1.getX(), p1.getY());\n            context.lineTo(p2.getX(), p2.getY());\n            context.stroke();\n        } finally {\n            context.restore();\n        }\n    };\n\n    /**\n     * Clamp an angle into the range [-PI, +PI]\n     *\n     * @private\n     * @method _phi\n     * @param {Number} angle\n     * @returns {Number}\n     */\n    var _phi = function (angle) {\n        angle = ((angle + Math.PI) % (Math.PI * 2)) - Math.PI;\n        if (angle < -Math.PI) {\n            angle += Math.PI * 2;\n        }\n        return angle;\n    };\n\n    /**\n     * Draw an arrow head on context\n     *\n     * @private\n     * @method _drawArrowHead\n     * @param {Point} headPoint\n     * @param {Number} angle\n     * @param {Number} length\n     * @param {Object} context The canvas 2d context\n     * @param {PenParameters} parameters\n     */\n    var _drawArrowHead = function (headPoint, angle, length, context, parameters) {\n        var alpha = _phi(angle + Math.PI - (Math.PI / 8)),\n            beta = _phi(angle - Math.PI + (Math.PI / 8));\n\n        context.save();\n        try {\n            context.fillStyle = parameters.getColor();\n            context.strokeStyle = parameters.getColor();\n            context.lineWidth = 0.5 * parameters.getWidth();\n\n            context.moveTo(headPoint.getX(), headPoint.getY());\n            context.beginPath();\n            context.lineTo(headPoint.getX() + (length * Math.cos(alpha)), headPoint.getY() + (length * Math.sin(alpha)));\n            context.lineTo(headPoint.getX() + (length * Math.cos(beta)), headPoint.getY() + (length * Math.sin(beta)));\n            context.lineTo(headPoint.getX(), headPoint.getY());\n            context.fill();\n\n        } finally {\n            context.restore();\n        }\n\n    };\n\n    /**\n     * Return components from ink ranges\n     *\n     * @private\n     * @param components\n     * @param inkRanges\n     * @returns {AbstractComponent[]}\n     */\n    var _extractComponents = function (components, inkRanges) {\n        var result = [];\n\n        for (var i in inkRanges) {\n            var inkRange = inkRanges[i];\n\n            var firstPointIndex = Math.floor(inkRange.getFirstPoint());\n            var lastPointIndex = Math.ceil(inkRange.getLastPoint());\n\n            for (var strokeIndex = inkRange.getFirstStroke(); strokeIndex <= inkRange.getLastStroke(); strokeIndex++) {\n                var currentStroke = components[strokeIndex];\n                var currentStrokePointCount = currentStroke.getX().length;\n\n                var newStroke = new scope.StrokeComponent();\n                newStroke.setColor(currentStroke.getColor());\n                newStroke.setWidth(currentStroke.getWidth());\n\n                for (var pointIndex = firstPointIndex; (strokeIndex === inkRange.getLastStroke() && pointIndex <= lastPointIndex && pointIndex < currentStrokePointCount) || (strokeIndex !== inkRange.getLastStroke() && pointIndex < currentStrokePointCount); pointIndex++) {\n                    newStroke.addPoint(currentStroke.getX()[pointIndex], currentStroke.getY()[pointIndex], currentStroke.getT()[pointIndex]);\n                }\n                result.push(newStroke);\n            }\n        }\n        return result;\n\n    };\n\n    // Export\n    scope.ShapeRenderer = ShapeRenderer;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * Represent the Math Renderer. It's used to calculate the math ink rendering in HTML5 canvas\n     *\n     * @class MathRenderer\n     * @extends AbstractRenderer\n     * @param {Object} context\n     * @constructor\n     */\n    function MathRenderer(context) {\n        scope.AbstractRenderer.call(this, context);\n    }\n\n    /**\n     * Inheritance property\n     */\n    MathRenderer.prototype = new scope.AbstractRenderer();\n\n    /**\n     * Constructor property\n     */\n    MathRenderer.prototype.constructor = MathRenderer;\n\n    /**\n     * Draw math recognition result on HTML5 canvas. Scratch out results are use to redraw HTML5 Canvas\n     *\n     * @method drawRecognitionResult\n     * @param {AbstractComponent[]} components\n     * @param {MathDocument} recognitionResult\n     */\n    MathRenderer.prototype.drawRecognitionResult = function (components, recognitionResult) {\n        this.clear();\n        if (recognitionResult) {\n            var notScratchOutComponents = _filterScratchOut(components, recognitionResult.getScratchOutResults());\n            this.drawComponents(notScratchOutComponents);\n        } else {\n            this.drawComponents(components);\n        }\n    };\n\n    /**\n     * Draw components\n     *\n     * @method drawComponents\n     * @param {AbstractComponent[]} components\n     */\n    MathRenderer.prototype.drawComponents = function (components) {\n        for (var i in components) {\n            var component = components[i];\n            if (component instanceof scope.AbstractComponent) {\n                if(!component.scratchedStroke){\n                    scope.AbstractRenderer.prototype.drawComponent.call(this, component); // super\n                }\n            } else {\n                throw new Error('not implemented');\n            }\n        }\n    };\n\n\n    /**\n     * Return non-scratched out components\n     *\n     * @private\n     * @param components\n     * @param scratchOutResults\n     * @returns {*}\n     */\n    var _filterScratchOut = function (components, scratchOutResults) {\n        if (!scratchOutResults || scratchOutResults.length === 0) {\n            return components;\n        }\n        for (var k in scratchOutResults) {\n            for (var n in scratchOutResults[k].getErasedInkRanges()) {\n                components[scratchOutResults[k].getErasedInkRanges()[n].getComponent()].scratchedStroke = true;\n            }\n            for (var p in scratchOutResults[k].getInkRanges()) {\n                components[scratchOutResults[k].getInkRanges()[p].getComponent()].scratchedStroke = true;;\n            }\n        }\n        return components;\n    };\n\n    // Export\n    scope.MathRenderer = MathRenderer;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * Represent the Music Renderer. It's used to calculate the music ink rendering in HTML5 canvas\n     *\n     * @class MusicRenderer\n     * @extends AbstractRenderer\n     * @param {Object} context\n     * @constructor\n     */\n    function MusicRenderer(context) {\n        scope.AbstractRenderer.call(this, context);\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicRenderer.prototype = new scope.AbstractRenderer();\n\n    /**\n     * Constructor property\n     */\n    MusicRenderer.prototype.constructor = MusicRenderer;\n\n    /**\n     * Draw music recognition result on HTML5 canvas. Scratch out results are use to redraw HTML5 Canvas\n     *\n     * @method drawRecognitionResult\n     * @param {AbstractComponent[]} components\n     * @param {MusicDocument} recognitionResult\n     */\n    MusicRenderer.prototype.drawRecognitionResult = function (components, recognitionResult) {\n        this.clear();\n        if (recognitionResult) {\n            var notScratchOutComponents = _removeMusicScratchOut(components, recognitionResult.getScratchOutResults());\n            this.drawComponents(notScratchOutComponents);\n        } else {\n            this.drawComponents(components);\n        }\n    };\n\n    /**\n     * Draw staff on the HTML5 canvas\n     *\n     * @method drawStaff\n     * @param {MusicStaff} staff\n     */\n    MusicRenderer.prototype.drawStaff = function (staff) {\n        _drawStaff(staff, this.getContext(), this.getParameters());\n    };\n\n    /**\n     * Draw components\n     *\n     * @method drawComponents\n     * @param {AbstractComponent[]} components\n     */\n    MusicRenderer.prototype.drawComponents = function (components) {\n        for (var i in components) {\n            var component = components[i];\n            if (component instanceof scope.AbstractMusicInputComponent) {\n                _drawMusicNode(component, this.getContext(), this.getParameters());\n            } else if (component instanceof scope.AbstractComponent) {\n                scope.AbstractRenderer.prototype.drawComponent.call(this, component); // super\n            } else {\n                throw new Error('not implemented');\n            }\n        }\n    };\n\n    /**\n     * Draw staff on the HTML5 canvas\n     *\n     * @private\n     * @method _drawStaff\n     * @param {MusicStaff} staff\n     * @param {Object} context\n     * @param {PenParameters} parameters\n     */\n    var _drawStaff = function (staff, context, parameters) {\n        var staffHeight = staff.getTop() + ((staff.getCount() - 1) * staff.getGap());\n//            var staves = Math.floor(context.canvas.clientHeight / staff.height);\n        var staves = 1;\n\n        context.beginPath();\n\n        // Drawing horizontal staff lines\n        for (var i = 0; i < staves; i++) {\n            var offset = staffHeight * i;\n            for (var j = 0; j < staff.getCount(); j++) {\n                context.moveTo(0, (staff.getTop() + offset) + j * staff.getGap());\n                context.lineTo(context.canvas.clientWidth, (staff.getTop() + offset) + j * staff.getGap());\n            }\n        }\n\n        context.stroke();\n    };\n\n    /**\n     * Draw music node\n     *\n     * @private\n     * @method _drawMusicNode\n     * @param {AbstractMusicInputComponent} component\n     * @param {Object} context\n     * @param {PenParameters} parameters\n     */\n    var _drawMusicNode = function (component, context, parameters) {\n        if (component instanceof scope.MusicAccidentalInputComponent) {\n            _drawAccidental(component, context, parameters);\n        } else if (component instanceof scope.MusicArpeggiateInputComponent) {\n            _drawArpeggiate(component, context, parameters);\n        } else if (component instanceof scope.MusicBarInputComponent) {\n            _drawBar(component, context, parameters);\n        } else if (component instanceof scope.MusicBeamInputComponent) {\n            _drawBeam(component, context, parameters);\n        } else if (component instanceof scope.MusicClefInputComponent) {\n            _drawClef(component, context, parameters);\n        } else if (component instanceof scope.MusicDecorationInputComponent) {\n            _drawDecoration(component, context, parameters);\n        } else if (component instanceof scope.MusicDotsInputComponent) {\n            _drawDots(component, context, parameters);\n        } else if (component instanceof scope.MusicHeadInputComponent) {\n            _drawHead(component, context, parameters);\n        } else if (component instanceof scope.MusicLedgerLineInputComponent) {\n            _drawLedgerLine(component, context, parameters);\n        } else if (component instanceof scope.MusicRestInputComponent) {\n            _drawRest(component, context, parameters);\n        } else if (component instanceof scope.MusicStemInputComponent) {\n            _drawStem(component, context, parameters);\n        } else if (component instanceof scope.MusicTieOrSlurInputComponent) {\n            _drawTieOrSlur(component, context, parameters);\n        } else if (component instanceof scope.MusicTimeSignatureInputComponent) {\n            _drawTimeSignature(component, context, parameters);\n        } else {\n            throw new Error('Node not implemented: ' + component.getType());\n        }\n    };\n\n    /**\n     * Draw accidental\n     *\n     * @private\n     * @method _drawAccidental\n     * @param {MusicAccidentalInputComponent} accidental\n     * @param {Object} context The canvas 2d context\n     * @param {PenParameters} parameters Rendering parameters\n     */\n    var _drawAccidental = function (accidental, context, parameters) { // jshint ignore:line\n        throw new Error('not implemented');\n    };\n\n    /**\n     * Draw arpeggiate\n     *\n     * @private\n     * @method _drawArpeggiate\n     * @param {MusicArpeggiateInputComponent} arpeggiate\n     * @param {Object} context The canvas 2d context\n     * @param {PenParameters} parameters Rendering parameters\n     */\n    var _drawArpeggiate = function (arpeggiate, context, parameters) { // jshint ignore:line\n        throw new Error('not implemented');\n    };\n\n    /**\n     * Draw bar\n     *\n     * @private\n     * @method _drawBar\n     * @param {MusicBarInputComponent} bar\n     * @param {Object} context The canvas 2d context\n     * @param {PenParameters} parameters Rendering parameters\n     */\n    var _drawBar = function (bar, context, parameters) { // jshint ignore:line\n        throw new Error('not implemented');\n    };\n\n    /**\n     * Draw beam\n     *\n     * @private\n     * @method _drawBeam\n     * @param {MusicBeamInputComponent} beam\n     * @param {Object} context The canvas 2d context\n     * @param {PenParameters} parameters Rendering parameters\n     */\n    var _drawBeam = function (beam, context, parameters) { // jshint ignore:line\n        throw new Error('not implemented');\n    };\n\n    /**\n     * Draw clef\n     *\n     * @private\n     * @method _drawClef\n     * @param {MusicClefInputComponent} clef\n     * @param {Object} context The canvas 2d context\n     * @param {PenParameters} parameters Rendering parameters\n     */\n    var _drawClef = function (clef, context, parameters) { // jshint ignore:line\n        var src = 'data:image/svg+xml,';\n        switch (clef.getValue().getSymbol()) {\n            case 'F':\n                src = src + '<svg xmlns:svg=\"http://www.w3.org/2000/svg\" xmlns=\"http://www.w3.org/2000/svg\" version=\"1.0\" x=\"0\" y=\"0\" width=\"18\" height=\"20\"><defs/><g transform=\"translate(6.600000e-3,3.125356e-3)\"><g><path d=\"M17.3 3.1 C17.3 3.5 17.1 3.8 16.8 4.1 C16.5 4.4 15.9 4.5 15.5 4.3 C15 4.1 14.7 3.7 14.7 3.2 C14.6 2.8 14.8 2.5 15 2.2 C15.3 1.9 15.7 1.8 16 1.8 C16.4 1.8 16.8 2 17 2.3 C17.2 2.5 17.3 2.8 17.3 3.1 z\"/></g><g><path d=\"M17.3 8.9 C17.3 9.3 17.1 9.7 16.8 9.9 C16.5 10.3 15.9 10.3 15.5 10.2 C15 10 14.7 9.5 14.7 9.1 C14.6 8.7 14.8 8.3 15 8 C15.3 7.8 15.7 7.6 16 7.6 C16.5 7.7 17 8 17.2 8.4 C17.2 8.6 17.3 8.8 17.3 8.9 z\"/></g><g><path d=\"M13 7.2 C13 10 11.8 12.7 9.8 14.7 C7.3 17.2 4 18.8 0.7 19.8 C0.3 20.1 -0.4 19.8 0.3 19.4 C1.6 18.8 3 18.3 4.2 17.5 C7 15.8 9.3 13.1 9.8 9.9 C10.1 8 10.1 5.9 9.6 4 C9.2 2.6 8.2 1.1 6.7 0.9 C5.3 0.7 3.7 1.2 2.7 2.2 C2.5 2.4 2 3.2 2 4 C2.6 3.6 2.6 3.6 3.1 3.4 C4.2 2.9 5.7 3.6 6 4.9 C6.3 6 6.1 7.5 5 8.1 C3.8 8.7 2 8.5 1.4 7.2 C0.3 5.3 0.9 2.6 2.6 1.2 C4.4 -0.3 7.1 -0.3 9.2 0.4 C11.4 1.3 12.7 3.5 12.9 5.8 C13 6.2 13 6.7 13 7.2 z\"/></g></g></svg>';\n                break;\n            case 'C':\n                src = src + '<svg xmlns:svg=\"http://www.w3.org/2000/svg\" xmlns=\"http://www.w3.org/2000/svg\" version=\"1.0\" width=\"18\" height=\"25\"><defs/><g><g transform=\"matrix(1,0,0,1.030698,-309.364,-543.8647)\"><path d=\"M 325.9 546.8 C 325.8 548.7 324.7 550.7 322.8 551.5 C 321.1 552.1 319.1 552.2 317.6 551 C 316.6 550.2 316.2 548.4 317.3 547.5 C 318.3 546.5 320.4 547.4 320.3 548.9 C 320.7 549.9 318.5 550.5 319.7 551.3 C 321 551.6 322.3 550.5 322.6 549.3 C 323.1 547.5 323.1 545.6 322.7 543.8 C 322.4 542.9 321.9 541.5 320.7 541.9 C 319.2 542.2 318.3 543.8 317.9 545.1 C 317.6 543.2 316.4 541.5 315 540.2 C 315 544.1 315 548 315 551.9 L 314.1 551.9 C 314.1 543.9 314.1 535.7 314.1 527.7 L 315 527.7 C 315 531.5 315 535.5 315 539.4 C 316.4 538.1 317.6 536.4 317.8 534.5 C 318.3 535.9 319.3 537.5 321 537.8 C 322.2 537.8 322.5 536.3 322.8 535.4 C 323.1 533.7 323.1 531.8 322.6 530.1 C 322.2 529 320.9 528 319.6 528.3 C 318.6 529 320.6 529.6 320.3 530.6 C 320.5 532 318.8 533 317.6 532.3 C 316.3 531.6 316.4 529.7 317.4 528.8 C 318 528.1 319.3 527.7 320.3 527.7 C 321.2 527.7 321.8 527.7 322.6 528 C 324.6 528.7 325.7 530.7 325.9 532.7 C 326.2 534.9 324.9 537.3 322.8 538.2 C 321.5 538.7 319.9 538.3 318.8 537.3 C 318.7 538.3 318.2 539.2 317.7 539.9 C 318.1 540.6 318.6 541.8 318.8 542.1 C 320.1 540.9 322.5 540.8 323.8 542 C 325.2 543.1 326.1 545 325.9 546.8 z \"/></g><g transform=\"matrix(1,0,0,1.030928,-309.364,-543.9805)\"><path d=\"M 312.2 551.9 L 309.4 551.9 L 309.4 527.7 L 312.2 527.7 L 312.2 551.9 z \"/></g></g></svg>';\n                break;\n            case 'G':\n                src = src + '<svg xmlns:svg=\"http://www.w3.org/2000/svg\" xmlns=\"http://www.w3.org/2000/svg\" version=\"1.0\" width=\"15\" height=\"40\"><defs/><path d=\"m 12 3.4 c 0.3 3.1 -2 5.6 -4.1 7.6 -0.9 0.9 -0.2 0.1 -0.6 0.6 -0.1 -0.5 -0.3 -1.7 -0.3 -2.1 0.1 -2.6 2.3 -6.5 4.2 -7.9 0.3 0.6 0.6 0.6 0.8 1.8 z m 0.7 15.9 c -1.2 -0.9 -2.8 -1.1 -4.3 -0.9 -0.2 -1.2 -0.4 -2.5 -0.6 -3.7 2.4 -2.3 4.9 -4.9 5 -8.4 0.1 -2.2 -0.3 -4.6 -1.7 -6.4 C 9.5 0.1 8.3 2.1 7.4 3.3 c -1.5 2.6 -1.1 5.8 -0.6 8.6 -0.8 0.9 -1.9 1.7 -2.7 2.7 -2.4 2.3 -4.4 5.3 -4 8.7 0.2 3.3 2.6 6.3 5.9 7.1 1.2 0.3 2.6 0.3 3.8 0.1 0.2 2.2 1 4.5 0.1 6.7 -0.7 1.6 -2.8 2.9 -4.3 2.2 -0.6 -0.3 -0.1 -0.1 -0.5 -0.2 1.1 -0.3 2 -1 2.3 -1.5 0.8 -1.4 -0.4 -3.6 -2.2 -3.3 -2.3 0 -3.2 3.1 -1.7 4.6 1.3 1.5 3.8 1.3 5.4 0.3 1.8 -1.2 2 -3.5 1.8 -5.5 -0.1 -0.7 -0.4 -2.6 -0.4 -3.3 0.7 -0.2 0.2 -0.1 1.2 -0.4 2.7 -1 4.4 -4.2 3.6 -7 -0.3 -1.4 -1 -2.9 -2.3 -3.7 z m 0.6 5.7 c 0.2 2 -1.1 4.2 -3.1 4.9 -0.1 -0.8 -0.2 -1 -0.3 -1.4 -0.5 -2.4 -0.7 -4.9 -1.1 -7.3 1.6 -0.2 3.5 0.5 4 2.1 0.2 0.6 0.3 1.2 0.4 1.8 z m -5.1 5.1 c -2.5 0.1 -5 -1.6 -5.6 -4 -0.7 -2.1 -0.5 -4.5 0.8 -6.4 1.1 -1.7 2.6 -3 4 -4.5 0.2 1.1 0.4 2.2 0.5 3.3 -3 0.8 -5 4.6 -3.2 7.3 0.5 0.8 2 2.2 2.8 1.6 -1.1 -0.7 -2 -1.8 -1.8 -3.2 -0.1 -1.3 1.4 -2.9 2.7 -3.1 0.4 2.8 0.9 6 1.4 8.8 -0.5 0.1 -1 0.1 -1.5 0.1 z\"/></svg>';\n                break;\n            default:\n                throw new Error('Unknown music clef symbol');\n        }\n\n        var imageObj = new Image();\n        imageObj.onload = function () {\n            var ratio = clef.getBoundingBox().getHeight() / this.height;\n            clef.getBoundingBox().setWidth(this.width * ratio);\n            context.drawImage(imageObj, clef.getBoundingBox().getX(), clef.getBoundingBox().getY(), clef.getBoundingBox().getWidth(), clef.getBoundingBox().getHeight());\n        };\n        imageObj.src = src;\n    };\n\n    /**\n     * Draw decoration\n     *\n     * @private\n     * @method _drawDecoration\n     * @param {MusicDecorationInputComponent} decoration\n     * @param {Object} context The canvas 2d context\n     * @param {PenParameters} parameters Rendering parameters\n     */\n    var _drawDecoration = function (decoration, context, parameters) { // jshint ignore:line\n        throw new Error('not implemented');\n    };\n\n    /**\n     * Draw dots\n     *\n     * @private\n     * @method _drawDots\n     * @param {MusicDotsInputComponent} dots\n     * @param {Object} context The canvas 2d context\n     * @param {PenParameters} parameters Rendering parameters\n     */\n    var _drawDots = function (dots, context, parameters) { // jshint ignore:line\n        throw new Error('not implemented');\n    };\n\n    /**\n     * Draw head\n     *\n     * @private\n     * @method _drawHead\n     * @param {MusicHeadInputComponent} head\n     * @param {Object} context The canvas 2d context\n     * @param {PenParameters} parameters Rendering parameters\n     */\n    var _drawHead = function (head, context, parameters) { // jshint ignore:line\n        throw new Error('not implemented');\n    };\n\n    /**\n     * Draw ledgerLine\n     *\n     * @private\n     * @method _drawLedgerLine\n     * @param {MusicLedgerLineInputComponent} ledgerLine\n     * @param {Object} context The canvas 2d context\n     * @param {PenParameters} parameters Rendering parameters\n     */\n    var _drawLedgerLine = function (ledgerLine, context, parameters) { // jshint ignore:line\n        throw new Error('not implemented');\n    };\n\n    /**\n     * Draw rest\n     *\n     * @private\n     * @method _drawRest\n     * @param {MusicRestInputComponent} rest\n     * @param {Object} context The canvas 2d context\n     * @param {PenParameters} parameters Rendering parameters\n     */\n    var _drawRest = function (rest, context, parameters) { // jshint ignore:line\n        throw new Error('not implemented');\n    };\n\n    /**\n     * Draw stem\n     *\n     * @private\n     * @method _drawStem\n     * @param {MusicStemInputComponent} stem\n     * @param {Object} context The canvas 2d context\n     * @param {PenParameters} parameters Rendering parameters\n     */\n    var _drawStem = function (stem, context, parameters) { // jshint ignore:line\n        throw new Error('not implemented');\n    };\n\n    /**\n     * Draw tieOrSlur\n     *\n     * @private\n     * @method _drawTieOrSlur\n     * @param {MusicTieOrSlurInputComponent} tieOrSlur\n     * @param {Object} context The canvas 2d context\n     * @param {PenParameters} parameters Rendering parameters\n     */\n    var _drawTieOrSlur = function (tieOrSlur, context, parameters) { // jshint ignore:line\n        throw new Error('not implemented');\n    };\n\n    /**\n     * Draw timeSignature\n     *\n     * @private\n     * @method _drawTimeSignature\n     * @param {MusicTimeSignatureInputComponent} timeSignature\n     * @param {Object} context The canvas 2d context\n     * @param {PenParameters} parameters Rendering parameters\n     */\n    var _drawTimeSignature = function (timeSignature, context, parameters) { // jshint ignore:line\n        throw new Error('not implemented');\n    };\n\n    /**\n     * Return non-scratched out components\n     *\n     * @private\n     * @param components\n     * @param scratchOutResults\n     * @returns {*}\n     */\n    var _removeMusicScratchOut = function (components, scratchOutResults) {\n        if (!scratchOutResults || scratchOutResults.length === 0) {\n            return components;\n        }\n\n        var cloneComponents = components.slice(0);\n        var componentsToRemove = [];\n\n        for (var k in scratchOutResults) {\n            if (scratchOutResults[k].getErasedInputRanges()) {\n                for (var n in scratchOutResults[k].getErasedInputRanges()) {\n                    componentsToRemove.push(scratchOutResults[k].getErasedInputRanges()[n].getComponent());\n                }\n                for (var p in scratchOutResults[k].getInputRanges()) {\n                    componentsToRemove.push(scratchOutResults[k].getInputRanges()[p].getComponent());\n                }\n            }\n        }\n\n        componentsToRemove.sort(function (a, b) {\n            return b - a;\n        });\n\n        for (var z in componentsToRemove) {\n            cloneComponents.splice(componentsToRemove[z], 1);\n        }\n        return cloneComponents;\n    };\n\n    // Export\n    scope.MusicRenderer = MusicRenderer;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * Represent the Analyzer Renderer. It's used to calculate the analyzer ink rendering in HTML5 canvas\n     *\n     * @class AnalyzerRenderer\n     * @extends AbstractRenderer\n     * @param {Object} context\n     * @constructor\n     */\n    function AnalyzerRenderer(context) {\n        scope.AbstractRenderer.call(this, context);\n        this.shapeRenderer = new scope.ShapeRenderer(context);\n    }\n\n    /**\n     * Inheritance property\n     */\n    AnalyzerRenderer.prototype = new scope.AbstractRenderer();\n\n    /**\n     * Constructor property\n     */\n    AnalyzerRenderer.prototype.constructor = AnalyzerRenderer;\n\n    /**\n     * Get shape renderer\n     *\n     * @method getShapeRenderer\n     * @returns {ShapeRenderer}\n     */\n    AnalyzerRenderer.prototype.getShapeRenderer = function () {\n        return this.shapeRenderer;\n    };\n\n    /**\n     * Set shape renderer\n     *\n     * @method setShapeRenderer\n     * @param {ShapeRenderer} shapeRenderer\n     */\n    AnalyzerRenderer.prototype.setShapeRenderer = function (shapeRenderer) {\n        this.shapeRenderer = shapeRenderer;\n    };\n\n    /**\n     * Draw shape recognition result on HTML5 canvas\n     *\n     * @method drawRecognitionResult\n     * @param {AbstractComponent[]} components\n     * @param {AnalyzerDocument} recognitionResult\n     */\n    AnalyzerRenderer.prototype.drawRecognitionResult = function (components, recognitionResult) {\n        this.clear();\n        if (recognitionResult) {\n            this.shapeRenderer.drawShapes(components, recognitionResult.getShapes());\n            _drawTables(components, recognitionResult.getTables(), this.getContext(), this.getParameters());\n            _drawTextLines(components, recognitionResult.getTextLines(), this.getContext(), this.getParameters());\n            //_drawGroups(components, recognitionResult.getGroups(), this.getContext(), this.getParameters()); // TODO: not implemented\n        } else {\n            this.drawComponents(components);\n        }\n    };\n\n    /**\n     * Draw components\n     *\n     * @method drawComponents\n     * @param {AbstractComponent[]} components\n     */\n    AnalyzerRenderer.prototype.drawComponents = function (components) {\n        for (var i in components) {\n            var component = components[i];\n            if (component instanceof scope.AbstractShapePrimitive) {\n                this.shapeRenderer.drawShapePrimitive(component);\n            } else if (component instanceof scope.AbstractComponent) {\n                scope.AbstractRenderer.prototype.drawComponent.call(this, component); // super\n            } else {\n                throw new Error('not implemented');\n            }\n        }\n    };\n\n    /**\n     * Draw table\n     *\n     * @private\n     * @method _drawTables\n     * @param {AbstractComponent[]} components\n     * @param {AnalyzerTable[]} tables\n     * @param {Object} context\n     * @param {PenParameters} parameters\n     */\n    var _drawTables = function (components, tables, context, parameters) {\n        for (var i in tables) {\n            for (var k in tables[i].getLines()) {\n                var data = tables[i].getLines()[k].getData();\n                _drawLine(data.getP1(), data.getP2(), context, parameters);\n            }\n        }\n    };\n\n    /**\n     * Draw the text line\n     *\n     * @private\n     * @method _drawTextLines\n     * @param {AbstractComponent[]} components\n     * @param {AnalyzerTextLine[]} textLines\n     * @param {Object} context\n     * @param {PenParameters} parameters\n     */\n    var _drawTextLines = function (components, textLines, context, parameters) {\n        for (var i in textLines) {\n            var textLine = textLines[i];\n            var data = textLine.getData();\n            if (data) {\n                var text = textLine.getTextDocument().getTextSegment().getSelectedCandidate().getLabel();\n                _drawText(data.getBoundingBox(), text, data.getJustificationType(), data.getTextHeight(), data.getBaselinePos(), context, parameters);\n\n                var underlines = textLine.getUnderlineList();\n                for (var j in underlines) {\n                    _drawUnderline(data.getBoundingBox(), underlines[j], text, data.getTextHeight(), data.getBaselinePos() + data.getTextHeight() / 10, context, parameters);\n                }\n            }\n        }\n    };\n\n    /**\n     * Draw text on analyser\n     *\n     * @private\n     * @method _drawText\n     * @param {Rectangle} boundingBox\n     * @param {String} text\n     * @param {String} justificationType\n     * @param {Number} textHeight\n     * @param {Number} baseline\n     * @param {Object} context\n     * @param {PenParameters} parameters\n     */\n    var _drawText = function (boundingBox, text, justificationType, textHeight, baseline, context, parameters) {\n        context.save();\n        try {\n            context.fillStyle = parameters.getColor();\n            context.strokeStyle = parameters.getColor();\n            context.lineWidth = 0.5 * parameters.getWidth();\n            context.font = parameters.getDecoration() + ' ' + textHeight + 'px' + ' ' + parameters.getFont();\n            context.textAlign = (justificationType === 'CENTER') ? 'center' : 'left';\n\n            context.fillText(text, boundingBox.getX(), baseline);\n\n        } finally {\n            context.restore();\n        }\n    };\n\n    /**\n     * Draw Groups\n     *\n     * @private\n     * @method _drawGroups\n     * @param {AbstractComponent[]} components\n     * @param {AnalyzerGroup[]} groups\n     * @param {Object} context\n     * @param {PenParameters} parameters\n     */\n    var _drawGroups = function (components, groups, context, parameters) { // jshint ignore:line\n        throw new Error('not implemented');\n    };\n\n\n    /**\n     * Draw Underline\n     *\n     * @private\n     * @method _drawUnderline\n     * @param {Rectangle} boundingBox\n     * @param {AnalyzerUnderline} underline\n     * @param {String} text\n     * @param {Number} textHeight\n     * @param {Object} context\n     * @param {PenParameters} parameters\n     */\n    var _drawUnderline = function (boundingBox, underline, text, textHeight, baseline, context, parameters) {\n        var topLeft = boundingBox.getTopLeftPoint();\n        var firstCharacter = underline.getData().getFirstCharacter();\n        var lastCharacter = underline.getData().getLastCharacter();\n\n        context.font = parameters.getDecoration() + ' ' + textHeight + 'px' + ' ' + parameters.getFont();\n\n        var textMetrics = context.measureText(text.substring(0, firstCharacter));\n        var x1 = topLeft.x + textMetrics.width;\n\n        textMetrics = context.measureText(text.substring(firstCharacter, lastCharacter + 1));\n        var x2 = x1 + textMetrics.width;\n        _drawLine(new scope.Point({x: x1, y: baseline}), new scope.Point({x: x2, y: baseline}), context, parameters);\n    };\n\n    /**\n     * Draw a cell\n     *\n     * @private\n     * @method _drawCell\n     * @param {AnalyzerCell} cell\n     * @param {Object} context\n     * @param {PenParameters} parameters\n     */\n    var _drawCell = function (cell, context, parameters) {\n        if (cell.getData()) {\n            var rectangle = cell.getData().getBoundingBox();\n            context.save();\n            try {\n                context.fillStyle = parameters.getRectColor();\n                context.strokeStyle = parameters.getColor();\n                context.lineWidth = 0.5 * parameters.getWidth();\n                context.fillRect(rectangle.getX(), rectangle.getY(), rectangle.getWidth(), rectangle.getHeight());\n            } finally {\n                context.restore();\n            }\n        }\n    };\n\n    /**\n     * Draw a line on context\n     *\n     * @private\n     * @method _drawLine\n     * @param {Point} p1\n     * @param {Point} p2\n     * @param {Object} context\n     * @param {PenParameters} parameters\n     */\n    var _drawLine = function (p1, p2, context, parameters) {\n        context.save();\n        try {\n            context.fillStyle = parameters.getColor();\n            context.strokeStyle = parameters.getColor();\n            context.lineWidth = 0.5 * parameters.getWidth();\n\n            context.beginPath();\n            context.moveTo(p1.getX(), p1.getY());\n            context.lineTo(p2.getX(), p2.getY());\n            context.stroke();\n        } finally {\n            context.restore();\n        }\n    };\n\n    // Export\n    scope.AnalyzerRenderer = AnalyzerRenderer;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * Represent the Image Renderer. It's used to calculate the Image ink rendering in HTML5 canvas\n     *\n     * @class ImageRenderer\n     * @extends AbstractRenderer\n     * @param {Object} context\n     * @constructor\n     */\n    function ImageRenderer(context) {\n        scope.AbstractRenderer.call(this, context);\n    }\n\n    /**\n     * Inheritance property\n     */\n    ImageRenderer.prototype = new scope.AbstractRenderer();\n\n    /**\n     * Constructor property\n     */\n    ImageRenderer.prototype.constructor = ImageRenderer;\n\n\n    /**\n     * Draw components\n     *\n     * @method drawComponents\n     * @param {AbstractComponent[]} components\n     */\n    ImageRenderer.prototype.drawComponents = function (components) {\n        for (var i in components) {\n            var component = components[i];\n            if (component instanceof scope.AbstractComponent) {\n                scope.AbstractRenderer.prototype.drawComponent.call(this, component); // super\n            } else {\n                console.log(components);\n                console.log(typeof component);\n                throw new Error('not implemented');\n            }\n        }\n    };\n\n    // Export\n    scope.ImageRenderer = ImageRenderer;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * The InkGrabber class that render, capture and build strokes\n     *\n     * @class InkGrabber\n     * @extends AbstractRenderer\n     * @param {Object} context\n     * @constructor\n     */\n    function InkGrabber(context) {\n        scope.AbstractRenderer.call(this, context);\n        this.stroke = undefined;\n        this.writing = false;\n    }\n\n    /**\n     * Inheritance property\n     */\n    InkGrabber.prototype = new scope.AbstractRenderer();\n\n    /**\n     * Constructor property\n     */\n    InkGrabber.prototype.constructor = InkGrabber;\n\n    /**\n     * Is Writing a stroke\n     *\n     * @method isWriting\n     * @returns {Boolean}\n     */\n    InkGrabber.prototype.isWriting = function () {\n        return this.writing;\n    };\n\n    /**\n     * Get the last wrote stroke\n     *\n     * @method getStroke\n     * @returns {StrokeComponent}\n     */\n    InkGrabber.prototype.getStroke = function () {\n        return this.stroke;\n    };\n\n    InkGrabber.prototype.startCapture = function (x, y, t) {\n        if (!this.writing) {\n            this.writing = true;\n            this.stroke = new scope.StrokeComponent();\n            this.stroke.setColor(this.penParameters.getColor());\n            this.stroke.setWidth(this.penParameters.getWidth());\n            this.stroke.addPoint(x, y, t);\n            this.clear();\n            this.drawComponent(this.stroke);\n        } else {\n            throw new Error('StrokeComponent capture already running');\n        }\n    };\n\n    InkGrabber.prototype.continueCapture = function (x, y, t) {\n        if (this.writing) {\n            this.stroke.addPoint(x, y, t);\n            this.clear();\n            this.drawComponent(this.stroke);\n        } else {\n            throw new Error('Missing startInkCapture');\n        }\n    };\n\n    InkGrabber.prototype.endCapture = function (x, y, t) {\n        if (this.writing) {\n            this.stroke.addPoint(x, y, t);\n            this.clear();\n            this.drawComponent(this.stroke);\n            this.writing = false;\n        } else {\n            throw new Error('Missing startInkCapture');\n        }\n    };\n\n    // Export\n    scope.InkGrabber = InkGrabber;\n})(MyScript);\n\n\n\n\n(function (scope) {\n    /**\n     * InkPaper\n     *\n     * @class InkPaper\n     * @param {Element} element\n     * @param {Object} [options]\n     * @param {Function} [callback] callback function\n     * @param {Object} callback.data The recognition result\n     * @param {Object} callback.err The err to the callback\n     * @constructor\n     */\n    function InkPaper(element, options, callback) {\n        this._element = element;\n        this._instanceId = undefined;\n        this._timerId = undefined;\n        this._initialized = false;\n        this._lastSentComponentIndex = 0;\n        this._components = [];\n        this._redoComponents = [];\n        this.isStarted = false;\n        this.resultCallback = callback;\n        this.changeCallback = undefined;\n\n\n        // Capture\n        var tempCanvas = _createCanvas(element, 'ms-temp-canvas');\n        this.canvasRatio = _getCanvasRatio(tempCanvas);\n        element.removeChild(tempCanvas);\n        //this.canvasRatio = 1;\n\n        this._captureCanvas = _createCanvas(element, 'ms-capture-canvas');\n\n        this._inkGrabber = new scope.InkGrabber(this._captureCanvas.getContext('2d'));\n\n        // Rendering\n        this._renderingCanvas = _createCanvas(element, 'ms-rendering-canvas');\n\n\n        this._textRenderer = new scope.TextRenderer(this._renderingCanvas.getContext('2d'));\n        this._mathRenderer = new scope.MathRenderer(this._renderingCanvas.getContext('2d'));\n        this._shapeRenderer = new scope.ShapeRenderer(this._renderingCanvas.getContext('2d'));\n        this._musicRenderer = new scope.MusicRenderer(this._renderingCanvas.getContext('2d'));\n        this._analyzerRenderer = new scope.AnalyzerRenderer(this._renderingCanvas.getContext('2d'));\n\n        // Recognition\n        this._textRecognizer = new scope.TextRecognizer();\n        this._mathRecognizer = new scope.MathRecognizer();\n        this._shapeRecognizer = new scope.ShapeRecognizer();\n        this._musicRecognizer = new scope.MusicRecognizer();\n        this._analyzerRecognizer = new scope.AnalyzerRecognizer();\n\n        this._textWSRecognizer = new scope.TextWSRecognizer(this._handleMessage.bind(this));\n        this._mathWSRecognizer = new scope.MathWSRecognizer(this._handleMessage.bind(this));\n\n        this._attachListeners(element);\n\n        this.options = { // Default options\n            type: scope.RecognitionType.TEXT,\n            protocol: scope.Protocol.REST,\n            ssl: true,\n            width: 400,\n            height: 300,\n            timeout: 2000,\n            typeset: false,\n            components: [],\n            textParameters: new scope.TextParameter(),\n            mathParameters: new scope.MathParameter(),\n            shapeParameters: new scope.ShapeParameter(),\n            musicParameters: new scope.MusicParameter(),\n            analyzerParameters: new scope.AnalyzerParameter()\n        };\n\n        if (options) {\n            for (var idx in options) {\n                if (options[idx] !== undefined) {\n                    this.options[idx] = options[idx]; // Override current options\n                }\n            }\n        }\n\n        // Recognition type\n        this.setType(this.options.type);\n\n        this.setHost(this.options.host);\n        this.setSSL(this.options.ssl);\n\n        this.setTextParameters(this.options.textParameters); // jshint ignore:line\n        this.setMathParameters(this.options.mathParameters); // jshint ignore:line\n        this.setShapeParameters(this.options.shapeParameters); // jshint ignore:line\n        this.setMusicParameters(this.options.musicParameters); // jshint ignore:line\n        this.setAnalyzerParameters(this.options.analyzerParameters); // jshint ignore:line\n\n        this.setProtocol(this.options.protocol);\n        this.setTimeout(this.options.timeout);\n        this.setApplicationKey(this.options.applicationKey);\n        this.setHmacKey(this.options.hmacKey);\n\n        this.setPenParameters(this.options.penParameters);\n\n        this.setPrecision(this.options.precision);\n        this.setTypeset(this.options.typeset);\n        this.setComponents(this.options.components);\n\n        this.setWidth(this.options.width);\n        this.setHeight(this.options.height);\n    }\n\n    /**\n     * Set the width\n     *\n     * @method setWidth\n     * @param {Number} width\n     */\n    InkPaper.prototype.setWidth = function (width) {\n        if (width > 0) {\n            this._captureCanvas.width = width * this.canvasRatio;\n            this._captureCanvas.style.width = width + 'px';\n            this._captureCanvas.getContext('2d').scale(this.canvasRatio, this.canvasRatio);\n\n            this._renderingCanvas.width = width * this.canvasRatio;\n            this._renderingCanvas.style.width = width + 'px';\n            this._renderingCanvas.getContext('2d').scale(this.canvasRatio, this.canvasRatio);\n        }\n        this._initRenderingCanvas();\n    };\n\n    /**\n     * Set the height\n     *\n     * @method setHeight\n     * @param {Number} height\n     */\n    InkPaper.prototype.setHeight = function (height) {\n        if (height > 0) {\n            this._captureCanvas.height = height * this.canvasRatio;\n            this._captureCanvas.style.height = height + 'px';\n            this._captureCanvas.getContext('2d').scale(this.canvasRatio, this.canvasRatio);\n\n            this._renderingCanvas.height = height * this.canvasRatio;\n            this._renderingCanvas.style.height = height + 'px';\n\n            this._renderingCanvas.getContext('2d').scale(this.canvasRatio, this.canvasRatio);\n        }\n        this._initRenderingCanvas();\n    };\n\n    /**\n     * Set the network protocol (REST or WebSocket)\n     *\n     * @param {'REST'|'WebSocket'} protocol\n     */\n    InkPaper.prototype.setProtocol = function (protocol) {\n        switch (protocol) {\n            case scope.Protocol.REST:\n                this._selectedRecognizer = this._selectedRESTRecognizer;\n                break;\n            case scope.Protocol.WS:\n                this.setTimeout(-1); // FIXME hack to avoid border issues\n                this._selectedRecognizer = this._selectedWSRecognizer;\n                break;\n            default:\n                throw new Error('Unknown protocol: ' + protocol);\n        }\n        this._instanceId = undefined;\n        this._initialized = false;\n        this._lastSentComponentIndex = 0;\n    };\n\n    /**\n     * Get the network protocol (REST or WebSocket)\n     *\n     * @returns {'REST'|'WebSocket'}\n     */\n    InkPaper.prototype.getProtocol = function () {\n        if (this._selectedRecognizer instanceof scope.AbstractWSRecognizer) {\n            return scope.Protocol.WS;\n        } else {\n            return scope.Protocol.REST;\n        }\n    };\n\n    /**\n     * Set recognition type\n     *\n     * @method setType\n     * @param {'TEXT'|'MATH'|'SHAPE'|'MUSIC'|'ANALYZER'} type\n     */\n    InkPaper.prototype.setType = function (type) {\n        switch (type) {\n            case scope.RecognitionType.TEXT:\n                this._selectedRenderer = this._textRenderer;\n                this._selectedRESTRecognizer = this._textRecognizer;\n                this._selectedWSRecognizer = this._textWSRecognizer;\n                break;\n            case scope.RecognitionType.MATH:\n                this._selectedRenderer = this._mathRenderer;\n                this._selectedRESTRecognizer = this._mathRecognizer;\n                this._selectedWSRecognizer = this._mathWSRecognizer;\n                break;\n            case scope.RecognitionType.SHAPE:\n                this._selectedRenderer = this._shapeRenderer;\n                this._selectedRESTRecognizer = this._shapeRecognizer;\n                break;\n            case scope.RecognitionType.MUSIC:\n                this._selectedRenderer = this._musicRenderer;\n                this._selectedRESTRecognizer = this._musicRecognizer;\n                break;\n            case scope.RecognitionType.ANALYZER:\n                this._selectedRenderer = this._analyzerRenderer;\n                this._selectedRESTRecognizer = this._analyzerRecognizer;\n                break;\n            default:\n                throw new Error('Unknown type: ' + type);\n        }\n        this._instanceId = undefined;\n        this._initialized = false;\n        this._lastSentComponentIndex = 0;\n    };\n\n    /**\n     * Get recognition type\n     *\n     * @method getType\n     * @returns {'TEXT'|'MATH'|'SHAPE'|'MUSIC'|'ANALYZER'} type\n     */\n    InkPaper.prototype.getType = function () {\n        if (this._selectedRenderer instanceof scope.TextRenderer) {\n            return scope.RecognitionType.TEXT;\n        }\n        if (this._selectedRenderer instanceof scope.MathRenderer) {\n            return scope.RecognitionType.MATH;\n        }\n        if (this._selectedRenderer instanceof scope.ShapeRenderer) {\n            return scope.RecognitionType.SHAPE;\n        }\n        if (this._selectedRenderer instanceof scope.MusicRenderer) {\n            return scope.RecognitionType.MUSIC;\n        }\n        if (this._selectedRenderer instanceof scope.AnalyzerRenderer) {\n            return scope.RecognitionType.ANALYZER;\n        }\n        throw new Error('Unknown type');\n    };\n\n    /**\n     * Get the recognition timeout\n     *\n     * @method getTimeout\n     * @returns {Number}\n     */\n    InkPaper.prototype.getTimeout = function () {\n        return this.timeout;\n    };\n\n    /**\n     * Set the recognition timeout\n     *\n     * @method setTimeout\n     * @param {Number} timeout\n     */\n    InkPaper.prototype.setTimeout = function (timeout) {\n        this.timeout = timeout;\n    };\n\n    /**\n     * Set the recognition precision\n     *\n     * @method setPrecision\n     * @param {Number} precision\n     */\n    InkPaper.prototype.setPrecision = function (precision) {\n        this._textRecognizer.setPrecision(precision);\n        this._textWSRecognizer.setPrecision(precision);\n        this._mathRecognizer.setPrecision(precision);\n        this._mathWSRecognizer.setPrecision(precision);\n        this._shapeRecognizer.setPrecision(precision);\n        this._musicRecognizer.setPrecision(precision);\n        this._analyzerRecognizer.setPrecision(precision);\n    };\n\n    /**\n     * Get the default components\n     *\n     * @method getComponents\n     * @return {Array} components\n     */\n    InkPaper.prototype.getComponents = function () {\n        return this.options.components;\n    };\n\n    /**\n     * Set the default components\n     *\n     * @method setComponents\n     * @param {Array} components\n     */\n    InkPaper.prototype.setComponents = function (components) {\n        this.options.components = components;\n        this._initRenderingCanvas();\n    };\n\n\n    /**\n     * Get the application key\n     *\n     * @method getApplicationKey\n     * @returns {String}\n     */\n    InkPaper.prototype.getApplicationKey = function () {\n        return this.applicationKey;\n    };\n\n    /**\n     * Set the application key\n     *\n     * @method setApplicationKey\n     * @param {String} applicationKey\n     */\n    InkPaper.prototype.setApplicationKey = function (applicationKey) {\n        this.applicationKey = applicationKey;\n    };\n\n    /**\n     * Get the HMAC key\n     *\n     * @method getHmacKey\n     * @returns {String}\n     */\n    InkPaper.prototype.getHmacKey = function () {\n        return this.hmacKey;\n    };\n\n    /**\n     * Set the HMAC key\n     *\n     * @method setHmacKey\n     * @param {String} hmacKey\n     */\n    InkPaper.prototype.setHmacKey = function (hmacKey) {\n        this.hmacKey = hmacKey;\n    };\n\n    /**\n     * Set text recognition parameters\n     *\n     * @method setTextParameters\n     * @param {TextParameter} textParameters\n     */\n    InkPaper.prototype.setTextParameters = function (textParameters) {\n        if (textParameters) {\n            if (this._selectedRecognizer instanceof scope.AbstractWSRecognizer) {\n                this.isStarted = false;\n                this._selectedRecognizer.resetWSRecognition();\n            }\n            for (var i in textParameters) {\n                if (textParameters[i] !== undefined) {\n                    this._textRecognizer.getParameters()[i] = textParameters[i]; // Override options\n                    this._textWSRecognizer.getParameters()[i] = textParameters[i]; // Override options\n                    this._analyzerRecognizer.getParameters().getTextParameters()[i] = textParameters[i]; // Override options\n                }\n            }\n        }\n    };\n\n    /**\n     * Get text recognition parameters\n     *\n     * @method getTextParameters\n     * @returns {TextParameter} textParameters\n     */\n    InkPaper.prototype.getTextParameters = function () {\n        return this._textRecognizer.getParameters();\n    };\n\n    /**\n     * Set math recognition parameters\n     *\n     * @method setMathParameters\n     * @param {MathParameter} mathParameters\n     */\n    InkPaper.prototype.setMathParameters = function (mathParameters) {\n        if (mathParameters) {\n            if (this._selectedRecognizer instanceof scope.AbstractWSRecognizer) {\n                this.isStarted = false;\n                this._selectedRecognizer.resetWSRecognition();\n            }\n            for (var i in mathParameters) {\n                if (mathParameters[i] !== undefined) {\n                    this._mathRecognizer.getParameters()[i] = mathParameters[i]; // Override options\n                    this._mathWSRecognizer.getParameters()[i] = mathParameters[i]; // Override options\n                }\n            }\n        }\n    };\n\n    /**\n     * Get math recognition parameters\n     *\n     * @method getMathParameters\n     * @returns {MathParameter} mathParameters\n     */\n    InkPaper.prototype.getMathParameters = function () {\n        return this._mathRecognizer.getParameters();\n    };\n\n    /**\n     * Set shape recognition parameters\n     *\n     * @method setShapeParameters\n     * @param {ShapeParameter} shapeParameters\n     */\n    InkPaper.prototype.setShapeParameters = function (shapeParameters) {\n        if (shapeParameters) {\n            if (this._selectedRecognizer instanceof scope.AbstractWSRecognizer) {\n                this.isStarted = false;\n                this._selectedRecognizer.resetWSRecognition();\n            }\n            for (var i in shapeParameters) {\n                if (shapeParameters[i] !== undefined) {\n                    this._shapeRecognizer.getParameters()[i] = shapeParameters[i]; // Override options\n                }\n            }\n        }\n    };\n\n    /**\n     * Get shape recognition parameters\n     *\n     * @method getShapeParameters\n     * @returns {ShapeParameter} shapeParameters\n     */\n    InkPaper.prototype.getShapeParameters = function () {\n        return this._shapeRecognizer.getParameters();\n    };\n\n    /**\n     * Set music recognition parameters\n     *\n     * @method setMusicParameters\n     * @param {MusicParameter} musicParameters\n     */\n    InkPaper.prototype.setMusicParameters = function (musicParameters) {\n        if (musicParameters) {\n            if (this._selectedRecognizer instanceof scope.AbstractWSRecognizer) {\n                this.isStarted = false;\n                this._selectedRecognizer.resetWSRecognition();\n            }\n            for (var i in musicParameters) {\n                if (musicParameters[i] !== undefined) {\n                    this._musicRecognizer.getParameters()[i] = musicParameters[i]; // Override options\n                }\n            }\n            this._initRenderingCanvas();\n        }\n    };\n\n    /**\n     * Get music recognition parameters\n     *\n     * @method getMusicParameters\n     * @returns {MusicParameter} musicParameters\n     */\n    InkPaper.prototype.getMusicParameters = function () {\n        return this._musicRecognizer.getParameters();\n    };\n\n    /**\n     * Set analyzer recognition parameters\n     *\n     * @method setAnalyzerParameters\n     * @param {AnalyzerParameter} analyzerParameters\n     */\n    InkPaper.prototype.setAnalyzerParameters = function (analyzerParameters) {\n        if (analyzerParameters) {\n            if (this._selectedRecognizer instanceof scope.AbstractWSRecognizer) {\n                this.isStarted = false;\n                this._selectedRecognizer.resetWSRecognition();\n            }\n            for (var i in analyzerParameters) {\n                if (analyzerParameters[i] !== undefined) {\n                    this._analyzerRecognizer.getParameters()[i] = analyzerParameters[i]; // Override options\n                }\n            }\n        }\n    };\n\n    /**\n     * Get analyzer recognition parameters\n     *\n     * @method getAnalyzerParameters\n     * @returns {AnalyzerParameter} analyzerParameters\n     */\n    InkPaper.prototype.getAnalyzerParameters = function () {\n        return this._analyzerRecognizer.getParameters();\n    };\n\n    /**\n     * Set pen parameters\n     *\n     * @method setPenParameters\n     * @param {PenParameters} penParameters\n     */\n    InkPaper.prototype.setPenParameters = function (penParameters) {\n        if (penParameters) {\n            for (var i in penParameters) {\n                if (penParameters[i] !== undefined) {\n                    this._selectedRenderer.getParameters()[i] = penParameters[i]; // Override options\n                }\n            }\n            var params = this._selectedRenderer.getParameters();\n            this._inkGrabber.setParameters(params); // Override options\n            this._textRenderer.setParameters(params); // Override options\n            this._mathRenderer.setParameters(params); // Override options\n            this._shapeRenderer.setParameters(params); // Override options\n            this._musicRenderer.setParameters(params); // Override options\n            this._analyzerRenderer.setParameters(params); // Override options\n        }\n    };\n\n    /**\n     * Get pen parameters\n     *\n     * @method getPenParameters\n     * @returns {PenParameters} penParameters\n     */\n    InkPaper.prototype.getPenParameters = function () {\n        return this._selectedRenderer.getParameters();\n    };\n\n    /**\n     * Enable / disable typeset\n     *\n     * @method setTypeset\n     * @param {Boolean} typeset\n     */\n    InkPaper.prototype.setTypeset = function (typeset) {\n        this._textRenderer.setTypeset(typeset);\n        this._mathRenderer.setTypeset(typeset);\n        this._shapeRenderer.setTypeset(typeset);\n        this._musicRenderer.setTypeset(typeset);\n        this._analyzerRenderer.setTypeset(typeset);\n    };\n\n    /**\n     * Get available languages\n     *\n     * @method getAvailableLanguages\n     * @param {String} [inputMode] input mode\n     */\n    InkPaper.prototype.getAvailableLanguages = function (inputMode) {\n        this._selectedRESTRecognizer.getAvailableLanguageList(\n            this.getApplicationKey(),\n            inputMode ? inputMode : this._textRecognizer.getParameters().getInputMode()\n        ).then(\n            function (data) {\n                this._onResult(data);\n            }.bind(this),\n            function (error) {\n                this._onResult(undefined, error);\n            }.bind(this)\n        );\n    };\n\n    /**\n     * Get the renderer\n     *\n     * @method getRenderer\n     * @returns {AbstractRenderer}\n     */\n    InkPaper.prototype.getRenderer = function () {\n        return this._selectedRenderer;\n    };\n\n    /**\n     * Get the ink capturer\n     *\n     * @method getInkGrabber\n     * @returns {InkGrabber}\n     */\n    InkPaper.prototype.getInkGrabber = function () {\n        return this._inkGrabber;\n    };\n\n    /**\n     * Get the recognizer\n     *\n     * @method getRecognizer\n     * @returns {AbstractRecognizer}\n     */\n    InkPaper.prototype.getRecognizer = function () {\n        return this._selectedRecognizer;\n    };\n\n    /**\n     * Set the change callback\n     *\n     * @method setChangeCallback\n     * @param {Function} callback callback function\n     * @param {Object} callback.data The inkPaper state\n     */\n    InkPaper.prototype.setChangeCallback = function (changeCallback) {\n        this.changeCallback = changeCallback;\n    };\n\n    /**\n     * Set the recognition result callback\n     *\n     * @method setResultCallback\n     * @param {Function} callback callback function\n     * @param {Object} callback.data The recognition result\n     */\n    InkPaper.prototype.setResultCallback = function (callback) {\n        this.resultCallback = callback;\n    };\n\n    /**\n     * Recognize\n     *\n     * @method recognize\n     * @returns {Promise}\n     */\n    InkPaper.prototype.recognize = function () {\n        var input = this.getComponents().concat(this._components);\n        if (this._selectedRecognizer instanceof scope.AbstractWSRecognizer) {\n            if (this._initialized) {\n                var lastInput = input.slice(this._lastSentComponentIndex);\n\n                if (lastInput.length > 0) {\n                    this._lastSentComponentIndex = input.length;\n                    if (!this.isStarted) {\n                        this.isStarted = true;\n                        this._selectedRecognizer.startWSRecognition(lastInput);\n                    } else {\n                        this._selectedRecognizer.continueWSRecognition(lastInput, this._instanceId);\n                    }\n                } else {\n                    this._renderResult();\n                }\n            }\n        } else {\n            if (this._selectedRecognizer instanceof scope.ShapeRecognizer) {\n                this._instanceId = undefined;\n            }\n\n            if (input.length > 0) {\n                if (!this.isStarted) {\n                    this._startRESTRecognition(input);\n                } else {\n                    this._continueRESTRecognition(input, this._instanceId);\n                }\n            } else {\n                this._renderResult();\n            }\n        }\n    };\n\n    InkPaper.prototype._startRESTRecognition = function (components) {\n\n        this._instanceId = undefined;\n        this._selectedRecognizer.doSimpleRecognition(\n            this.getApplicationKey(),\n            this._instanceId,\n            components,\n            this.getHmacKey()\n        ).then(\n            function (data) {\n                if (!this.isStarted) {\n                    this.isStarted = true;\n                    this._lastSentComponentIndex = components.length;\n                    this._instanceId = data.getInstanceId();\n                    this._renderResult(data);\n                }\n            }.bind(this),\n            function (error) {\n                this._onResult(undefined, error);\n            }.bind(this)\n        );\n    };\n\n    InkPaper.prototype._continueRESTRecognition = function (components, instanceId) {\n\n        this._selectedRecognizer.doSimpleRecognition(\n            this.getApplicationKey(),\n            instanceId,\n            components,\n            this.getHmacKey()\n        ).then(\n            function (data) {\n                this._lastSentComponentIndex = this._lastSentComponentIndex + components.length;\n                this._renderResult(data);\n            }.bind(this),\n            function (error) {\n                this._onResult(undefined, error);\n            }.bind(this)\n        );\n    };\n\n    InkPaper.prototype._clearRESTRecognition = function (instanceId) {\n\n        if (this._selectedRecognizer instanceof scope.ShapeRecognizer) {\n            this.isStarted = false;\n            this._lastSentComponentIndex = 0;\n            this._selectedRecognizer.clearShapeRecognitionSession(\n                this.getApplicationKey(),\n                instanceId\n            ).then(\n                function (data) {\n                    this._instanceId = undefined;\n                    this._onResult(data);\n                }.bind(this),\n                function (error) {\n                    this._onResult(undefined, error);\n                }.bind(this)\n            );\n        } else {\n            this._onResult();\n        }\n    };\n\n    /**\n     * Return true if you can undo\n     *\n     * @method canUndo\n     * @returns {Boolean}\n     */\n    InkPaper.prototype.canUndo = function () {\n        return this._components.length > 0;\n    };\n\n    /**\n     * Undo\n     *\n     * @method undo\n     */\n    InkPaper.prototype.undo = function () {\n        if (this.canUndo()) {\n            //Remove the scratched state for Math strokes\n            this._components.forEach(function(stroke){\n                stroke.scratchedStroke = false;\n            });\n            //Remove the latsModel used for Shape\n            this.updatedModel = undefined;\n\n            this._redoComponents.push(this._components.pop());\n\n            this._clearRESTRecognition(this._instanceId);\n\n            this._initRenderingCanvas();\n            this._onChange();\n\n            this.isStarted = false;\n            if (this._selectedRecognizer instanceof scope.AbstractWSRecognizer) {\n                this._selectedRecognizer.resetWSRecognition();\n            } else {\n                clearTimeout(this._timerId);\n                if (this.getTimeout() > -1) {\n                    this._timerId = setTimeout(this.recognize.bind(this), this.getTimeout());\n                } else {\n                    this._onResult();\n                }\n            }\n        }\n    };\n\n    /**\n     * Return true if you can redo\n     *\n     * @method canRedo\n     * @returns {Boolean}\n     */\n    InkPaper.prototype.canRedo = function () {\n        return this._redoComponents.length > 0;\n    };\n\n    /**\n     * Redo\n     *\n     * @method redo\n     */\n    InkPaper.prototype.redo = function () {\n        if (this.canRedo()) {\n            this._components.push(this._redoComponents.pop());\n\n            this._clearRESTRecognition(this._instanceId);\n\n            this._initRenderingCanvas();\n            this._onChange();\n\n            if (this._selectedRecognizer instanceof scope.AbstractWSRecognizer) {\n                this.recognize();\n            } else {\n                clearTimeout(this._timerId);\n                this.isStarted = false;\n                if (this.getTimeout() > -1) {\n                    this._timerId = setTimeout(this.recognize.bind(this), this.getTimeout());\n                } else {\n                    this._onResult();\n                }\n            }\n        }\n    };\n\n    /**\n     * Clear the ink paper\n     *\n     * @method clear\n     */\n    InkPaper.prototype.clear = function () {\n        this._components = [];\n        this._redoComponents = [];\n\n        this._clearRESTRecognition(this._instanceId);\n\n        this._initRenderingCanvas();\n        this._onChange();\n\n        if (this._selectedRecognizer instanceof scope.AbstractWSRecognizer) {\n            this.isStarted = false;\n            this._selectedRecognizer.resetWSRecognition();\n        } else {\n            clearTimeout(this._timerId);\n            if (this.getTimeout() > -1) {\n                this._timerId = setTimeout(this.recognize.bind(this), this.getTimeout());\n            } else {\n                this._onResult();\n            }\n        }\n    };\n\n    InkPaper.event = {\n        'addDomListener': function (element, useCapture, myfunction) {\n            element.addEventListener(useCapture, myfunction);\n        }\n    };\n\n    /**\n     *\n     * @private\n     * @method _down\n     * @param {Number} x X coordinate\n     * @param {Number} y Y coordinate\n     * @param {Date} [t] timeStamp\n     */\n    InkPaper.prototype._down = function (x, y, t) {\n        clearTimeout(this._timerId);\n        var sizeChanged = false;\n        if (this._captureCanvas.clientHeight * this.canvasRatio !== this._captureCanvas.height) {\n            this._captureCanvas.height = this._captureCanvas.clientHeight * this.canvasRatio;\n            this._renderingCanvas.height = this._renderingCanvas.clientHeight * this.canvasRatio;\n            sizeChanged = true;\n        }\n\n        if (this._captureCanvas.clientWidth * this.canvasRatio !== this._captureCanvas.width) {\n            this._captureCanvas.width = this._captureCanvas.clientWidth * this.canvasRatio;\n            this._renderingCanvas.width = this._renderingCanvas.clientWidth * this.canvasRatio;\n            sizeChanged = true;\n        }\n\n        //Safari trash the canvas content when heigth or width are modified.\n        if (sizeChanged) {\n\n            this._captureCanvas.getContext('2d').scale(this.canvasRatio, this.canvasRatio);\n            this._renderingCanvas.getContext('2d').scale(this.canvasRatio, this.canvasRatio);\n            this._initRenderingCanvas();\n        }\n\n        if (this.canRedo()) {\n            this._redoComponents = [];\n            this._onChange();\n        }\n\n        this._inkGrabber.startCapture(x, y, t);\n\n\n    };\n\n    /**\n     *\n     * @private\n     * @method _move\n     * @param {Number} x X coordinate\n     * @param {Number} y Y coordinate\n     * @param {Date} [t] timeStamp\n     */\n    InkPaper.prototype._move = function (x, y, t) {\n        this._inkGrabber.continueCapture(x, y, t);\n    };\n\n    /**\n     *\n     * @private\n     * @method _move\n     * @param {Number} x X coordinate\n     * @param {Number} y Y coordinate\n     * @param {Date} [t] timeStamp\n     */\n    InkPaper.prototype._up = function (x, y, t) {\n        this._inkGrabber.endCapture(x, y, t);\n\n        var stroke = this._inkGrabber.getStroke();\n\n        this._inkGrabber.clear();\n        this._selectedRenderer.drawComponent(stroke);\n\n        this._components.push(stroke);\n        this._onChange();\n\n        if (this._selectedRecognizer instanceof scope.AbstractWSRecognizer) {\n            if (!this._selectedRecognizer.isOpen() && !this._selectedRecognizer.isConnecting()) {\n                this._selectedRecognizer.open();\n            } else {\n                this.recognize();\n            }\n        } else {\n            clearTimeout(this._timerId);\n            if (this.getTimeout() > -1) {\n                this._timerId = setTimeout(this.recognize.bind(this), this.getTimeout());\n            }\n        }\n    };\n\n    InkPaper.prototype._onResult = function (data, err) {\n        if (this.resultCallback) {\n            this.resultCallback(data, err);\n        }\n        if (err) {\n            this._element.dispatchEvent(new CustomEvent('error', {detail: err}));\n        } else {\n            this._element.dispatchEvent(new CustomEvent('success', {detail: data}));\n        }\n    };\n\n    InkPaper.prototype._onChange = function () {\n        var data = {\n            canUndo: this.canUndo(),\n            undoLength: this._components.length,\n            canRedo: this.canRedo(),\n            redoLength: this._redoComponents.length\n        };\n\n        if (this.changeCallback) {\n            this.changeCallback(data)\n        }\n        this._element.dispatchEvent(new CustomEvent('changed', {detail: data}));\n    };\n\n    InkPaper.prototype._renderResult = function (data) {\n        this.updatedModel = this._selectedRenderer.drawRecognitionResult(this.getComponents().concat(this._components), data? data.getDocument(): undefined);\n        if (this._selectedRecognizer instanceof scope.MusicRecognizer) {\n            if (this._selectedRecognizer.getParameters().getStaff() instanceof scope.MusicStaff) {\n                this._selectedRenderer.drawStaff(this._selectedRecognizer.getParameters().getStaff());\n            }\n        }\n        this._onResult(data);\n        return data;\n    };\n\n    /**\n     * Set recognition service url\n     *\n     * @param {String} host\n     */\n    InkPaper.prototype.setHost = function (host) {\n        this._textRecognizer.setHost(host);\n        this._textWSRecognizer.setHost(host);\n        this._mathRecognizer.setHost(host);\n        this._mathWSRecognizer.setHost(host);\n        this._shapeRecognizer.setHost(host);\n        this._musicRecognizer.setHost(host);\n        this._analyzerRecognizer.setHost(host);\n    };\n\n    /**\n     * @private\n     */\n    InkPaper.prototype.setSSL = function (ssl) {\n        this._textRecognizer.setSSL(ssl);\n        this._textWSRecognizer.setSSL(ssl);\n        this._mathRecognizer.setSSL(ssl);\n        this._mathWSRecognizer.setSSL(ssl);\n        this._shapeRecognizer.setSSL(ssl);\n        this._musicRecognizer.setSSL(ssl);\n        this._analyzerRecognizer.setSSL(ssl);\n    };\n\n    /**\n     * Tool to attach touch events\n     *\n     * @private\n     * @param {Element} element\n     */\n    InkPaper.prototype._attachListeners = function (element) {\n        var self = this;\n        var pointerId;\n\n        //Desactivation of contextmenu to prevent safari to fire pointerdown only once\n        element.addEventListener(\"contextmenu\", function (e) {\n                                     e.preventDefault();\n                                     e.stopPropagation();\n                                     return false;\n                                 }\n        );\n\n        element.addEventListener('pointerdown', function (e) {\n            if (!pointerId) {\n                pointerId = e.pointerId;\n                e.preventDefault();pointerId\n                var coord = _getCoordinates(e, element);\n                self._down(coord.x, coord.y, coord.t);\n            }\n        }, false);\n\n        element.addEventListener('pointermove', function (e) {\n            if (pointerId === e.pointerId) {\n                e.preventDefault();\n\n                var coord = _getCoordinates(e, element);\n                self._move(coord.x, coord.y, coord.t);\n            }\n        }, false);\n\n        element.addEventListener('pointerup', function (e) {\n            if (pointerId === e.pointerId) {\n                e.preventDefault();\n\n                var coord = _getCoordinates(e, element);\n                self._up(coord.x, coord.y, coord.t);\n\n                pointerId = undefined;\n            }\n        }, false);\n\n        element.addEventListener('pointerleave', function (e) {\n            if (pointerId === e.pointerId) {\n                e.preventDefault();\n\n                var point = self._inkGrabber.getStroke().getPointByIndex(self._inkGrabber.getStroke().getLastIndexPoint());\n                self._up(point.x, point.y, point.t);\n                pointerId = undefined;\n            }\n        }, false);\n\n        element.addEventListener('pointerout', function (e) {\n            if (pointerId === e.pointerId) {\n                e.preventDefault();\n\n                var point = self._inkGrabber.getStroke().getPointByIndex(self._inkGrabber.getStroke().getLastIndexPoint());\n                self._up(point.x, point.y, point.t);\n                pointerId = undefined;\n            }\n        }, false);\n    };\n\n    InkPaper.prototype._initRenderingCanvas = function () {\n        this._selectedRenderer.clear();\n\n        if (this._selectedRecognizer instanceof scope.MusicRecognizer) {\n            if (this._selectedRecognizer.getParameters().getStaff() instanceof scope.MusicStaff) {\n                this._selectedRenderer.drawStaff(this._selectedRecognizer.getParameters().getStaff());\n            }\n        }\n        if(this._selectedRecognizer instanceof scope.ShapeRecognizer && this.updatedModel){\n            this._selectedRenderer.drawRecognitionResult(this.updatedModel.components, this.updatedModel.document);\n        } else {\n            this._selectedRenderer.drawComponents(this.getComponents().concat(this._components));\n        }\n    };\n\n    /**\n     *\n     * @param message\n     * @param error\n     * @returns {boolean} false no immediate replay needed, true when the call need to be replay ASAP\n     * @private\n     */\n    InkPaper.prototype._handleMessage = function (message, error) {\n        var replayNeeded = false;\n        if (error) {\n            replayNeeded = true;\n            this._instanceId = undefined;\n            this.isStarted = false;\n            this._lastSentComponentIndex = 0;\n            this._onResult(undefined, error);\n        }\n\n        if (message) {\n            switch (message.type) {\n                case 'open':\n                    this._selectedWSRecognizer.initWSRecognition(this.getApplicationKey());\n                    break;\n                case 'hmacChallenge':\n                    this._selectedWSRecognizer.takeUpHmacChallenge(this.getApplicationKey(), message.getChallenge(), this.getHmacKey());\n                    break;\n                case 'init':\n                    this.isStarted = false;\n                    this._initialized = true;\n                    this._instanceId = undefined;\n                    this._lastSentComponentIndex = 0;\n                    this.recognize();\n                    break;\n                case 'reset':\n                    this.isStarted = false;\n                    this._instanceId = undefined;\n                    this._lastSentComponentIndex = 0;\n                    this.recognize();\n                    break;\n                case 'close':\n                    this._initialized = false;\n                    this._instanceId = undefined;\n                    this._lastSentComponentIndex = 0;\n                    break;\n                default:\n                    this.isStarted = true;\n                    if (!this._instanceId) {\n                        this._instanceId = message.getInstanceId();\n                    }\n                    this._renderResult(message);\n                    break;\n            }\n        }\n        return replayNeeded;\n    };\n\n    /**\n     * Return the stats allowing to monitor what ink size is send to the server.\n     * @returns Stats objects format {strokesCount : 0, pointsCount : 0, byteSize : 0, humanSize : 0, humanUnit : 'BYTE'} humanUnit could have the values BYTE, BYTES, KiB, MiB\n     */\n    InkPaper.prototype.getStats = function () {\n        var stats = {strokesCount: 0, pointsCount: 0, byteSize: 0, humanSize: 0, humanUnit: 'BYTE'};\n        if (this._components) {\n            stats.strokesCount = this._components.length;\n            var pointsCount = 0;\n            for (var strokeNb = 0; strokeNb < this._components.length; strokeNb++) {\n                pointsCount = pointsCount + this._components[strokeNb].x.length;\n            }\n            stats.strokesCount = this._components.length;\n            stats.pointsCount = pointsCount;\n            //We start with 270 as it is the size in bytes. Make a real computation implies to recode a doRecogntion\n            var byteSize = 270;\n            byteSize = JSON.stringify(this._components).length;\n            stats.byteSize = byteSize;\n            if (byteSize < 270) {\n                stats.humanUnit = 'BYTE';\n                stats.byteSize = 0;\n                stats.humanSize = 0;\n            } else if (byteSize < 2048) {\n                stats.humanUnit = 'BYTES';\n                stats.humanSize = byteSize;\n            } else if (byteSize < 1024 * 1024) {\n                stats.humanUnit = 'KiB';\n                stats.humanSize = (byteSize / 1024).toFixed(2);\n            } else {\n                stats.humanUnit = 'MiB';\n                stats.humanSize = (byteSize / 1024 / 1024).toFixed(2);\n            }\n        }\n        return stats;\n    };\n\n    /**\n     *\n     * @param marginX the horizontal margin to apply (by default 10)\n     * @param marginY the vertical margin to apply (by default 10)\n     * @returns {ImageData} Build an ImageData object with content shrink to border of strokes.\n     * @private\n     */\n    InkPaper.prototype.getInkAsImageData = function (marginX, marginY) {\n        //Remove the scratched strokes\n        var componentCopy = [];\n        this._components.forEach(function(stroke) {\n                                     if (stroke.scratchedStroke !== true) {\n                                         componentCopy.push(stroke);\n                                     }\n                                 }\n        );\n\n        if (!marginX) {\n            marginX = 10;\n        }\n        if (!marginY) {\n            marginY = 10;\n        }\n\n        if (componentCopy && componentCopy.length > 0) {\n            var updatedStrokes;\n            var strokesCount = componentCopy.length;\n            //Initializing min and max\n            var minX = componentCopy[0].x[0];\n            var maxX = componentCopy[0].x[0];\n            var minY = componentCopy[0].y[0];\n            var maxY = componentCopy[0].y[0];\n\n            // Computing the min and max for x and y\n            for (var strokeNb = 0; strokeNb < componentCopy.length; strokeNb++) {\n                var pointCount = componentCopy[strokeNb].x.length;\n                for (var pointNb = 0; pointNb < pointCount; pointNb++) {\n                    var currentX = componentCopy[strokeNb].x[pointNb];\n                    var currentY = componentCopy[strokeNb].y[pointNb];\n                    if (currentX < minX) {\n                        minX = currentX;\n                    }\n                    if (currentX > maxX) {\n                        maxX = currentX;\n                    }\n                    if (currentY < minY) {\n                        minY = currentY;\n                    }\n                    if (currentY > maxY) {\n                        maxY = currentY;\n                    }\n                }\n            }\n            var nonDisplayCanvas = document.createElement('canvas');\n            nonDisplayCanvas.width = (maxX ) + (2 * marginX);\n            nonDisplayCanvas.height = (maxY ) + (2 * marginY)\n\n            var ctx = nonDisplayCanvas.getContext(\"2d\");\n\n            var imageRendered = new scope.ImageRenderer(ctx);\n            imageRendered.drawComponents(componentCopy, ctx);\n\n            // https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/getImageData\n            return ctx.getImageData(minX - marginX, minY - marginY, (maxX - minX ) + (2 * marginX), (maxY - minY ) + (2 * marginY));\n        }\n    };\n\n    /**\n     *\n     * @param marginX the horizontal margin to apply (by default 10)\n     * @param marginY the vertical margin to apply (by default 10)\n     * @returns {String} Build an String containg dataUrl with content shrink to border of strokes.\n     * @private\n     */\n    InkPaper.prototype.getInkAsPng = function (marginX, marginY) {\n        var imageRenderingCanvas = document.createElement('canvas');\n        imageRenderingCanvas.style.display = 'none';\n\n        var imageDataToRender = this.getInkAsImageData();\n        imageRenderingCanvas.width = imageDataToRender.width;\n        imageRenderingCanvas.style.width = imageDataToRender.width + 'px';\n        imageRenderingCanvas.height = imageDataToRender.height;\n        imageRenderingCanvas.style.height = imageDataToRender.height + 'px';\n        var ctx = imageRenderingCanvas.getContext('2d');\n        ctx.putImageData(imageDataToRender, 0, 0);\n        return imageRenderingCanvas.toDataURL(\"image/png\");\n    };\n\n    /**\n     * Tool to create canvas\n     *\n     * @private\n     * @param {Element} parent\n     * @param {String} id\n     * @returns {Element}\n     */\n    function _createCanvas(parent, id) {\n        var count = document.querySelectorAll('canvas[id^=' + id + ']').length;\n        var canvas = document.createElement('canvas');\n        canvas.id = id + '-' + count;\n        parent.appendChild(canvas);\n        return canvas;\n    }\n\n    /**\n     * Tool to get canvas ratio (retina display)\n     *\n     * @private\n     * @param {Element} canvas\n     * @returns {Number}\n     */\n    function _getCanvasRatio(canvas) {\n        if (canvas) {\n            var context = canvas.getContext('2d'),\n                devicePixelRatio = window.devicePixelRatio || 1,\n                backingStoreRatio = context.webkitBackingStorePixelRatio ||\n                    context.mozBackingStorePixelRatio ||\n                    context.msBackingStorePixelRatio ||\n                    context.oBackingStorePixelRatio ||\n                    context.backingStorePixelRatio || 1;\n            return devicePixelRatio / backingStoreRatio;\n        }\n        return 1;\n    }\n\n\n    /**\n     * Tool to get proper coordinates\n     *\n     * @private\n     * @param {Event} e\n     * @param {Element} element\n     * @returns {Object}\n     */\n    function _getCoordinates(e, container) {\n        if (e.changedTouches) e = e.changedTouches[0];\n        var rect = container.getBoundingClientRect();\n        return {\n            x: e.clientX - rect.left - container.clientLeft,\n            y: e.clientY - rect.top - container.clientTop,\n            t: e.timeStamp\n        };\n    }\n\n    // Export\n    scope.InkPaper = InkPaper;\n})(MyScript);\n","/**\n * Polyfills\n */\n(function () {\n    /**\n     * CustomEvent\n     */\n    function CustomEvent ( event, params ) {    // jshint ignore:line\n        params = params || { bubbles: false, cancelable: false, detail: undefined };\n        var evt = document.createEvent( 'CustomEvent' );\n        evt.initCustomEvent( event, params.bubbles, params.cancelable, params.detail );\n        return evt;\n    }\n\n    CustomEvent.prototype = window.Event.prototype;\n\n    window.CustomEvent = CustomEvent;\n\n    /**\n     * bind()\n     */\n    if (!Function.prototype.bind) {\n        Function.prototype.bind = function(oThis) {\n            if (typeof this !== 'function') {\n                // closest thing possible to the ECMAScript 5\n                // internal IsCallable function\n                throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable');\n            }\n\n            var aArgs   = Array.prototype.slice.call(arguments, 1),\n                fToBind = this,\n                fNOP    = function() {},\n                fBound  = function() {\n                    return fToBind.apply(this instanceof fNOP ? this : oThis,\n                        aArgs.concat(Array.prototype.slice.call(arguments)));\n                };\n\n            fNOP.prototype = this.prototype;\n            fBound.prototype = new fNOP(); // jshint ignore:line\n\n            return fBound;\n        };\n    }\n})();\n\n/**\n * MyScript javascript library\n *\n * @module MyScript\n * @requires Q\n * @requires CryptoJS\n */\n/*global MyScript:true */\nMyScript = {\n    RecognitionType: {\n        TEXT: 'TEXT',\n        MATH: 'MATH',\n        SHAPE: 'SHAPE',\n        MUSIC: 'MUSIC',\n        ANALYZER: 'ANALYZER'\n    },\n    InputMode: {\n        CURSIVE: 'CURSIVE',\n        ISOLATED: 'ISOLATED',\n        SUPERIMPOSED: 'SUPERIMPOSED',\n        VERTICAL: 'VERTICAL'\n    },\n    InputType: {\n        CHAR: 'CHAR',\n        WORD: 'WORD',\n        SINGLE_LINE_TEXT: 'SINGLE_LINE_TEXT',\n        MULTI_LINE_TEXT: 'MULTI_LINE_TEXT'\n    },\n    ResultDetail: {\n        TEXT: 'TEXT',\n        WORD: 'WORD',\n        CHARACTER: 'CHARACTER'\n    },\n    ResultType: {\n        Math: {\n            LATEX: 'LATEX',\n            MATHML: 'MATHML',\n            SYMBOLTREE: 'SYMBOLTREE',\n            OFFICEOPENXMLMATH : 'OFFICEOPENXMLMATH'\n        },\n        Music: {\n            MUSICXML: 'MUSICXML',\n            SCORETREE: 'SCORETREE'\n        }\n    },\n    Protocol: {\n        WS: 'WebSocket',\n        REST: 'REST'\n    }\n};\n","'use strict';\n\n(function (scope) {\n    /**\n     * Point\n     *\n     * @class Point\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function Point(obj) {\n        if (obj) {\n            this.x = obj.x;\n            this.y = obj.y;\n        }\n    }\n\n    /**\n     * Get x\n     *\n     * @method getX\n     * @returns {Number}\n     */\n    Point.prototype.getX = function () {\n        return this.x;\n    };\n\n    /**\n     * Set x\n     *\n     * @method setX\n     * @param {Number} x\n     */\n    Point.prototype.setX = function (x) {\n        this.x = x;\n    };\n\n    /**\n     * Get y\n     *\n     * @method getY\n     * @returns {Number}\n     */\n    Point.prototype.getY = function () {\n        return this.y;\n    };\n\n    /**\n     * Set y\n     *\n     * @method setY\n     * @param {Number} y\n     */\n    Point.prototype.setY = function (y) {\n        this.y = y;\n    };\n\n    // Export\n    scope.Point = Point;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Rectangle\n     *\n     * @class Rectangle\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function Rectangle(obj) {\n        if (obj) {\n            this.x = obj.x;\n            this.y = obj.y;\n            this.width = obj.width;\n            this.height = obj.height;\n        }\n    }\n\n    /**\n     * Get top-left x\n     *\n     * @method getX\n     * @returns {Number}\n     */\n    Rectangle.prototype.getX = function () {\n        return this.x;\n    };\n\n    /**\n     * Set top-left x\n     *\n     * @method setX\n     * @param {Number} x\n     */\n    Rectangle.prototype.setX = function (x) {\n        this.x = x;\n    };\n\n    /**\n     * Get top-left y\n     *\n     * @method getY\n     * @returns {Number}\n     */\n    Rectangle.prototype.getY = function () {\n        return this.y;\n    };\n\n    /**\n     * Set top-left y\n     *\n     * @method setY\n     * @param {Number} y\n     */\n    Rectangle.prototype.setY = function (y) {\n        this.y = y;\n    };\n\n    /**\n     * Get top-left point\n     *\n     * @method getTopLeftPoint\n     * @returns {Point}\n     */\n    Rectangle.prototype.getTopLeftPoint = function () {\n        var point = new scope.Point();\n        point.setX(this.x);\n        point.setY(this.y);\n        return point;\n    };\n\n    /**\n     * Set top-left point\n     *\n     * @method setTopLeftPoint\n     * @param {Point} topLeftPoint\n     */\n    Rectangle.prototype.setTopLeftPoint = function (topLeftPoint) {\n        this.x = topLeftPoint.getX();\n        this.y = topLeftPoint.getY();\n    };\n\n    /**\n     * Get width\n     *\n     * @method getWidth\n     * @returns {Number}\n     */\n    Rectangle.prototype.getWidth = function () {\n        return this.width;\n    };\n\n    /**\n     * Set width\n     *\n     * @method setWidth\n     * @param {Number} width\n     */\n    Rectangle.prototype.setWidth = function (width) {\n        this.width = width;\n    };\n\n    /**\n     * Get height\n     *\n     * @method getHeight\n     * @returns {Number}\n     */\n    Rectangle.prototype.getHeight = function () {\n        return this.height;\n    };\n\n    /**\n     * Set height\n     *\n     * @method setHeight\n     * @param {Number} height\n     */\n    Rectangle.prototype.setHeight = function (height) {\n        this.height = height;\n    };\n\n    // Export\n    scope.Rectangle = Rectangle;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Parameters used for both input and output canvas draw.\n     *\n     * @class PenParameters\n     * @constructor\n     */\n    function PenParameters(obj) {\n        this.color = 'rgba(0, 0, 0, 0.9)';\n        this.rectColor = 'rgba(0, 0, 0, 0.2)';\n        this.font = 'Times New Roman';\n        this.decoration = 'normal';\n        this.width = 4;\n        this.pressureType = 'SIMULATED';\n        this.alpha = '1.0';\n        if (obj) {\n            this.color = obj.color;\n            this.rectColor = obj.rectColor;\n            this.font = obj.font;\n            this.decoration = obj.decoration;\n            this.width = obj.width;\n            this.pressureType = obj.pressureType;\n            this.alpha = obj.alpha;\n        }\n    }\n\n    /**\n     * Get the color renderer parameter\n     *\n     * @method getColor\n     * @returns {String} The color of the ink\n     */\n    PenParameters.prototype.getColor = function () {\n        return this.color;\n    };\n\n    /**\n     * Set the color renderer parameter\n     *\n     * @method setColor\n     * @param {String} color\n     */\n    PenParameters.prototype.setColor = function (color) {\n        this.color = color;\n    };\n\n    /**\n     * Get the rect renderer parameter\n     *\n     * @method getRectColor\n     * @returns {String} the rectangle color\n     */\n    PenParameters.prototype.getRectColor = function () {\n        return this.rectColor;\n    };\n\n    /**\n     * Set the rect renderer parameter\n     *\n     * @method setRectColor\n     * @param {String} rectColor\n     */\n    PenParameters.prototype.setRectColor = function (rectColor) {\n        this.rectColor = rectColor;\n    };\n\n    /**\n     * Get the font renderer parameter\n     *\n     * @method getFont\n     * @returns {String} The font\n     */\n    PenParameters.prototype.getFont = function () {\n        return this.font;\n    };\n\n    /**\n     * Set the font renderer parameter\n     *\n     * @method setFont\n     * @param {String} font\n     */\n    PenParameters.prototype.setFont = function (font) {\n        this.font = font;\n    };\n\n    /**\n     * Get the decoration renderer parameter\n     *\n     * @method getDecoration\n     * @returns {String} The decoration\n     */\n    PenParameters.prototype.getDecoration = function () {\n        return this.decoration;\n    };\n\n    /**\n     * Set the decoration renderer parameter\n     *\n     * @method setDecoration\n     * @param {String} decoration\n     */\n    PenParameters.prototype.setDecoration = function (decoration) {\n        this.decoration = decoration;\n    };\n\n    /**\n     * Get the width renderer parameter\n     *\n     * @method getWidth\n     * @returns {Number} The ink width\n     */\n    PenParameters.prototype.getWidth = function () {\n        return this.width;\n    };\n\n    /**\n     * Set the width renderer parameter\n     *\n     * @method setWidth\n     * @param {Number} width\n     */\n    PenParameters.prototype.setWidth = function (width) {\n        this.width = width;\n    };\n\n    // Export\n    scope.PenParameters = PenParameters;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * The mathUtil class is use to calculate lines\n     *\n     * @class MathUtil\n     * @constructor\n     */\n    function MathUtils() {\n    }\n\n    /**\n     * This method is use to calculate the size of the rectangle that contains an ellipse arc.\n     *\n     * @method getEllipseArcRect\n     * @param {Point} center\n     * @param {Number} maxRadius\n     * @param {Number} minRadius\n     * @param {Number} orientation\n     * @param {Number} startAngle\n     * @param {Number} sweepAngle\n     * @returns {Rectangle}\n     */\n    MathUtils.getEllipseArcRect = function (center, maxRadius, minRadius, orientation, startAngle, sweepAngle) {\n\n        var angleStep = 0.02, // angle delta between interpolated points on the arc, in radian\n            angle, // angle\n            alpha, // angle\n            z1,\n            z2,\n            z3,\n            z4,\n            cosAlpha,\n            sinAlpha,\n            n,\n            xList,\n            yList,\n            i,\n            x,\n            y,\n            xMin,\n            xMax,\n            yMin,\n            yMax,\n            sortFloat = function (a, b) {\n                return a - b;\n            };\n\n        z1 = z2 = Math.cos(orientation);\n        z3 = z4 = Math.sin(orientation);\n        z1 *= maxRadius;\n        z2 *= minRadius;\n        z3 *= maxRadius;\n        z4 *= minRadius;\n\n        n = Math.abs(sweepAngle) / angleStep;\n\n        xList = [];\n        yList = [];\n\n        for (i = 0; i <= n; i++) {\n\n            angle = startAngle + (i / n) * sweepAngle;\n            alpha = Math.atan2(Math.sin(angle) / minRadius, Math.cos(angle) / maxRadius);\n\n            cosAlpha = Math.cos(alpha);\n            sinAlpha = Math.sin(alpha);\n\n            // current point\n            x = center.x + z1 * cosAlpha - z4 * sinAlpha;\n            y = center.y + z2 * sinAlpha + z3 * cosAlpha;\n\n            xList.push(x);\n            yList.push(y);\n        }\n\n        xList.sort(sortFloat);\n        yList.sort(sortFloat);\n\n        xMin = xList[0];\n        xMax = xList[xList.length - 1];\n        yMin = yList[0];\n        yMax = yList[yList.length - 1];\n\n        return new scope.Rectangle({x: xMin, y: yMin, width: xMax - xMin, height: yMax - yMin});\n    };\n\n    /**\n     * This method is use to calculate the size of the rectangle that contains a line.\n     *\n     * @method getLineRect\n     * @param {Point} firstPoint\n     * @param {Point} lastPoint\n     * @returns {Rectangle}\n     */\n    MathUtils.getLineRect = function (firstPoint, lastPoint) {\n\n        var xFirst = firstPoint.x,\n            xLast = lastPoint.x,\n            xMin = Math.min(xFirst, xLast),\n            xMax = Math.max(xFirst, xLast),\n\n            yFirst = firstPoint.y,\n            yLast = lastPoint.y,\n            yMin = Math.min(yFirst, yLast),\n            yMax = Math.max(yFirst, yLast);\n\n        return new scope.Rectangle({x: xMin, y: yMin, width: xMax - xMin, height: yMax - yMin});\n    };\n\n    /**\n     * This method is use to calculate the size of the rectangle that contains bounding boxes.\n     *\n     * @method getBoundingRect\n     * @param {Rectangle[]} boundingBoxes List of bounding box\n     * @returns {Rectangle}\n     */\n    MathUtils.getBoundingRect = function (boundingBoxes) {\n\n        var xList = [],\n            yList = [];\n\n        for (var i in boundingBoxes) {\n            var rectangle = boundingBoxes[i];\n            xList.push(rectangle.getX());\n            xList.push(rectangle.getX() + rectangle.getWidth());\n            yList.push(rectangle.getY());\n            yList.push(rectangle.getY() + rectangle.getHeight());\n        }\n\n        var xMin = Math.min.apply(Math, xList);\n        var xMax = Math.max.apply(Math, xList);\n        var yMin = Math.min.apply(Math, yList);\n        var yMax = Math.max.apply(Math, yList);\n\n        return new scope.Rectangle({x: xMin, y: yMin, width: xMax - xMin, height: yMax - yMin});\n    };\n\n    // Export\n    scope.MathUtils = MathUtils;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * Abstract WebSocket recognition message\n     *\n     * @class AbstractWSMessage\n     * @param {Object} [obj] Recognition WebSocket message\n     * @constructor\n     */\n    function AbstractWSMessage(obj) {\n        if (obj) {\n            this.type = obj.type;\n        }\n    }\n\n    /**\n     * Get the message type\n     *\n     * @method getType\n     * @returns {String}\n     */\n    AbstractWSMessage.prototype.getType = function () {\n        return this.type;\n    };\n\n    // Export\n    scope.AbstractWSMessage = AbstractWSMessage;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Represent an abstract input component\n     *\n     * @class AbstractComponent\n     * @constructor\n     */\n    function AbstractComponent() {\n    }\n\n    /**\n     * Get the type of the input component\n     *\n     * @method getType\n     * @returns {String}\n     */\n    AbstractComponent.prototype.getType = function () {\n        return this.type;\n    };\n\n    /**\n     * Set the type of the input component\n     *\n     * @method setType\n     * @param {String} type\n     */\n    AbstractComponent.prototype.setType = function (type) {\n        this.type = type;\n    };\n\n    /**\n     * Get input component bounding-box\n     *\n     * @method getBoundingBox\n     * @returns {Rectangle}\n     */\n    AbstractComponent.prototype.getBoundingBox = function () {\n        throw new Error('not implemented');\n    };\n\n    /**\n     * Set input component bounding-box\n     *\n     * @method setBoundingBox\n     * @param {Rectangle} boundingBox\n     */\n    AbstractComponent.prototype.setBoundingBox = function (boundingBox) { // jshint ignore:line\n        throw new Error('not implemented');\n    };\n\n    // Export\n    scope.AbstractComponent = AbstractComponent;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Represent a simple StrokeComponent input component\n     *\n     * @class StrokeComponent\n     * @extends AbstractComponent\n     * @constructor\n     */\n    function StrokeComponent(obj) {\n        scope.AbstractComponent.call(this);\n        this.type = 'stroke';\n        this.x = [];\n        this.y = [];\n        this.t = [];\n        this.p = [];\n        this.d = [];\n        this.l = [];\n        this.color = undefined;\n        this.alpha = undefined;\n        this.width = 0;\n        if (obj) {\n            if (obj.x) {\n                this.x = obj.x;\n            }\n            if (obj.y) {\n                this.y = obj.y;\n            }\n            if (obj.t) {\n                this.t = obj.t;\n            }\n            if (obj.p) {\n                this.p = obj.p;\n            }\n            if (obj.d) {\n                this.d = obj.d;\n            }\n            if (obj.l) {\n                this.l = obj.l;\n            }\n            if (obj.color) {\n                this.color = obj.color;\n            }\n            if (obj.alpha) {\n                this.alpha = obj.alpha;\n            }\n            if (obj.width) {\n                this.width = obj.width;\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    StrokeComponent.prototype = new scope.AbstractComponent();\n\n    /**\n     * Constructor property\n     */\n    StrokeComponent.prototype.constructor = StrokeComponent;\n\n    /**\n     * @method toJSON\n     * @returns {Object}\n     */\n    StrokeComponent.prototype.toJSON = function () {\n        return {type: this.type, x: this.x, y: this.y, t: this.t};\n    };\n\n    /**\n     * Get the list of x coordinates\n     *\n     * @method getX\n     * @returns {Number[]}\n     */\n    StrokeComponent.prototype.getX = function () {\n        return this.x;\n    };\n\n    /**\n     * Set the list of x coordinates\n     *\n     * @method setX\n     * @param {Number[]} x\n     */\n    StrokeComponent.prototype.setX = function (x) {\n        this.x = x;\n    };\n\n    /**\n     * Add a x to the list of x coordinates\n     *\n     * @method addX\n     * @param {Number} x\n     */\n    StrokeComponent.prototype.addX = function (x) {\n        if ((x !== null) && (x !== undefined)) {\n            this.x.push(x);\n        }\n    };\n\n    /**\n     * Get the list of y coordinates\n     *\n     * @method getY\n     * @returns {Number[]}\n     */\n    StrokeComponent.prototype.getY = function () {\n        return this.y;\n    };\n\n    /**\n     * Set the list of y coordinates\n     *\n     * @method setY\n     * @param {Number[]} y\n     */\n    StrokeComponent.prototype.setY = function (y) {\n        this.y = y;\n    };\n\n    /**\n     * Add a y to the list of y coordinates\n     *\n     * @method addY\n     * @param {Number} y\n     */\n    StrokeComponent.prototype.addY = function (y) {\n        if ((y !== null) && (y !== undefined)) {\n            this.y.push(y);\n        }\n    };\n\n    /**\n     * Get the list of timestamps\n     *\n     * @method getT\n     * @returns {Number[]}\n     */\n    StrokeComponent.prototype.getT = function () {\n        return this.t;\n    };\n\n    /**\n     * Set the list of timestamps\n     *\n     * @method setT\n     * @param {Number[]} t\n     */\n    StrokeComponent.prototype.setT = function (t) {\n        this.t = t;\n    };\n\n    /**\n     * Add a timestamp to the list\n     *\n     * @method addT\n     * @param {Number} t\n     */\n    StrokeComponent.prototype.addT = function (t) {\n        if ((t !== null) && (t !== undefined)) {\n            this.t.push(t);\n        }\n    };\n\n    StrokeComponent.prototype.getLength = function () {\n        return this.x.length;\n    };\n\n    /**\n     * Get the boundingBox\n     *\n     * @method getBoundingBox\n     * @returns {Rectangle}\n     */\n    StrokeComponent.prototype.getBoundingBox = function () {\n        var boundingBox = new scope.Rectangle();\n        boundingBox.setX(Math.min.apply(Math, this.getX()));\n        boundingBox.setY(Math.min.apply(Math, this.getY()));\n        boundingBox.setWidth(Math.max.apply(Math, this.getX()) - boundingBox.getX());\n        boundingBox.setHeight(Math.max.apply(Math, this.getY()) - boundingBox.getY());\n        return boundingBox;\n    };\n\n    StrokeComponent.prototype.toFixed = function (precision) {\n        if (precision !== undefined) {\n            for (var i in this.x) {\n                this.x[i] = this.x[i].toFixed(precision);\n                this.y[i] = this.y[i].toFixed(precision);\n            }\n        }\n    };\n\n    StrokeComponent.prototype.getP = function () {\n        return this.p;\n    };\n\n    StrokeComponent.prototype.setP = function (p) {\n        this.p = p;\n    };\n\n    StrokeComponent.prototype.addP = function (p) {\n        if ((p !== null) && (p !== undefined)) {\n            this.p.push(p);\n        }\n    };\n\n    StrokeComponent.prototype.getD = function () {\n        return this.d;\n    };\n\n    StrokeComponent.prototype.setD = function (d) {\n        this.d = d;\n    };\n\n    StrokeComponent.prototype.addD = function (d) {\n        if ((d !== null) && (d !== undefined)) {\n            this.d.push(d);\n        }\n    };\n\n    StrokeComponent.prototype.getL = function () {\n        return this.l;\n    };\n\n    StrokeComponent.prototype.setL = function (l) {\n        this.l = l;\n    };\n\n    StrokeComponent.prototype.addL = function (l) {\n        if ((l !== null) && (l !== undefined)) {\n            this.l.push(l);\n        }\n    };\n\n    StrokeComponent.prototype.getColor = function () {\n        return this.color;\n    };\n\n    StrokeComponent.prototype.setColor = function (color) {\n        this.color = color;\n    };\n\n    StrokeComponent.prototype.getWidth = function () {\n        return this.width;\n    };\n\n    StrokeComponent.prototype.setWidth = function (width) {\n        this.width = width;\n    };\n\n    StrokeComponent.prototype.addPoint = function (x, y, t) {\n        if (_filterPointByAcquisitionDelta(x, y, this.getX(), this.getY(), this.getLastIndexPoint(), this.getWidth(), this.getLength())) {\n            this.addX(x);\n            this.addY(y);\n            this.addT(t);\n            this.addP(_computePressure(x, y, this.getX(), this.getY(), this.getL(), this.getLastIndexPoint()));\n            this.addD(_computeDistance(x, y, this.getX(), this.getY(), this.getLastIndexPoint()));\n            this.addL(_computeLength(x, y, this.getX(), this.getY(), this.getL(), this.getLastIndexPoint()));\n        }\n    };\n\n    StrokeComponent.prototype.getLastIndexPoint = function () {\n        return this.x.length - 1;\n    };\n\n    StrokeComponent.prototype.getPointByIndex = function (index) {\n        var point;\n        if (index !== undefined && index >= 0 && index < this.getLength()) {\n            point = {\n                x: this.getX()[index],\n                y: this.getY()[index],\n                t: this.getT()[index],\n                p: this.getP()[index],\n                d: this.getD()[index],\n                l: this.getL()[index]\n            };\n        }\n        return point;\n    };\n\n    function _computeDistance(x, y, xArray, yArray, lastIndexPoint) {\n        var distance = Math.sqrt(Math.pow((y - yArray[lastIndexPoint - 1]), 2) + Math.pow((x - xArray[lastIndexPoint - 1]), 2));\n\n        if (isNaN(distance)) {\n            distance = 0;\n        }\n\n        return distance;\n    }\n\n    function _computeLength(x, y, xArray, yArray, lArray, lastIndexPoint) {\n        var length = lArray[lastIndexPoint - 1] + _computeDistance(x, y, xArray, yArray, lastIndexPoint);\n\n        if (isNaN(length)) {\n            length = 0;\n        }\n\n        return length;\n    }\n\n    function _computePressure(x, y, xArray, yArray, lArray, lastIndexPoint) {\n        var ratio = 1.0;\n        var distance = _computeDistance(x, y, xArray, yArray, lastIndexPoint);\n        var length = _computeLength(x, y, xArray, yArray, lArray, lastIndexPoint);\n\n        if(length === 0) {\n            ratio = 0.5;\n        } else if(distance == length){\n            ratio = 1.0;\n        } else  if (distance < 10) {\n            ratio = 0.2 + Math.pow(0.1 * distance, 0.4);\n        } else if (distance > length - 10) {\n            ratio = 0.2 + Math.pow(0.1 * (length - distance), 0.4);\n        }\n        var pressure = ratio * Math.max(0.1, 1.0 - 0.1 * Math.sqrt(distance));\n        if (isNaN(parseFloat(pressure))) {\n            pressure = 0.5;\n        }\n        return pressure;\n    }\n\n    function _filterPointByAcquisitionDelta(x, y, xArray, yArray, lastIndexPoint, width, length) {\n        var delta = (2 + (width / 4));\n        var ret = false;\n        if (length === 0 || Math.abs(xArray[lastIndexPoint] - x) >= delta || Math.abs(yArray[lastIndexPoint] - y) >= delta) {\n            ret = true;\n        }\n        return ret;\n    }\n\n    // Export\n    scope.StrokeComponent = StrokeComponent;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * Char input component\n     *\n     * @class CharacterInputComponent\n     * @extends AbstractComponent\n     * @constructor\n     */\n    function CharacterInputComponent(obj) {\n        scope.AbstractComponent.call(this);\n        this.type = 'inputCharacter';\n        this.alternates = [];\n        if (obj) {\n            if (obj.alternates) {\n                for (var i in obj.alternates) {\n                    this.alternates.push(new scope.CharacterInputComponentAlternate(obj.alternates[i]));\n                }\n            }\n            if (obj.boundingBox) {\n                this.boundingBox = new scope.Rectangle(obj.boundingBox);\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    CharacterInputComponent.prototype = new scope.AbstractComponent();\n\n    /**\n     * Constructor property\n     */\n    CharacterInputComponent.prototype.constructor = CharacterInputComponent;\n\n    /**\n     * Get character input alternates\n     *\n     * @method getAlternates\n     * @returns {CharacterInputComponentAlternate[]}\n     */\n    CharacterInputComponent.prototype.getAlternates = function () {\n        return this.alternates;\n    };\n\n    /**\n     * Set character input alternates\n     *\n     * @method setAlternates\n     * @param {CharacterInputComponentAlternate[]} alternates\n     */\n    CharacterInputComponent.prototype.setAlternates = function (alternates) {\n        this.alternates = alternates;\n    };\n\n    /**\n     * Add a character input alternate\n     *\n     * @method addAlternate\n     * @param {CharacterInputComponent} alternate\n     */\n    CharacterInputComponent.prototype.addAlternate = function (alternate) {\n        this.alternates.push(alternate);\n    };\n\n    /**\n     * Get input component bounding-box\n     *\n     * @method getBoundingBox\n     * @returns {Rectangle}\n     */\n    CharacterInputComponent.prototype.getBoundingBox = function () {\n        return this.boundingBox;\n    };\n\n    /**\n     * Set input component bounding-box\n     *\n     * @method setBoundingBox\n     * @param {Rectangle} boundingBox\n     */\n    CharacterInputComponent.prototype.setBoundingBox = function (boundingBox) {\n        this.boundingBox = boundingBox;\n    };\n\n    // Export\n    scope.CharacterInputComponent = CharacterInputComponent;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * Character input component alternate\n     *\n     * @class CharacterInputComponentAlternate\n     * @constructor\n     */\n    function CharacterInputComponentAlternate(obj) {\n        if (obj) {\n            if (obj.alternate) {\n                this.alternate = obj.alternate;\n            }\n            if (obj.probability) {\n                this.probability = obj.probability;\n            }\n        }\n    }\n\n    /**\n     * Get alternate\n     *\n     * @method getAlternate\n     * @returns {String}\n     */\n    CharacterInputComponentAlternate.prototype.getAlternate = function () {\n        return this.alternate;\n    };\n\n    /**\n     * Set alternate\n     *\n     * @method setAlternate\n     * @param {String} alternate\n     */\n    CharacterInputComponentAlternate.prototype.setAlternate = function (alternate) {\n        this.alternate = alternate;\n    };\n\n    /**\n     * Get probability\n     *\n     * @method getProbability\n     * @returns {Number}\n     */\n    CharacterInputComponentAlternate.prototype.getProbability = function () {\n        return this.probability;\n    };\n\n    /**\n     * Set probability\n     *\n     * @method setProbability\n     * @param {Number} probability\n     */\n    CharacterInputComponentAlternate.prototype.setProbability = function (probability) {\n        this.probability = probability;\n    };\n\n    // Export\n    scope.CharacterInputComponentAlternate = CharacterInputComponentAlternate;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * Abstract parameters used for recognition\n     *\n     * @class AbstractParameter\n     * @constructor\n     */\n    function AbstractParameter() {\n    }\n\n    // Export\n    scope.AbstractParameter = AbstractParameter;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Abstraction of recognizer input\n     *\n     * @class AbstractRecognitionInput\n     * @constructor\n     */\n    function AbstractRecognitionInput() {\n    }\n\n    // Export\n    scope.AbstractRecognitionInput = AbstractRecognitionInput;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Abstract input recognition data\n     *\n     * @class AbstractRecognitionData\n     * @constructor\n     */\n    function AbstractRecognitionData() {\n    }\n\n    /**\n     * Get the application key\n     *\n     * @method getApplicationKey\n     * @returns {String}\n     */\n    AbstractRecognitionData.prototype.getApplicationKey = function () {\n        return this.applicationKey;\n    };\n\n    /**\n     * Set the application key\n     *\n     * @method setApplicationKey\n     * @param {String} applicationKey\n     */\n    AbstractRecognitionData.prototype.setApplicationKey = function (applicationKey) {\n        this.applicationKey = applicationKey;\n    };\n\n    /**\n     * Get the instanceId\n     *\n     * @method getInstanceId\n     * @returns {String}\n     */\n    AbstractRecognitionData.prototype.getInstanceId = function () {\n        return this.instanceId;\n    };\n\n    /**\n     * Set the instanceId\n     *\n     * @method setInstanceId\n     * @param {String} instanceId\n     */\n    AbstractRecognitionData.prototype.setInstanceId = function (instanceId) {\n        this.instanceId = instanceId;\n    };\n\n    /**\n     * @returns {string}\n     */\n    AbstractRecognitionData.prototype.getHmac = function () {\n        return this.hmac;\n    };\n\n    /**\n     * @param {string} hmac\n     */\n    AbstractRecognitionData.prototype.setHmac = function (hmac) {\n        this.hmac = hmac;\n    };\n\n    /**\n     * Get recognition input\n     *\n     * @method getRecognitionInput\n     * @returns {AbstractRecognitionInput} input\n     */\n    AbstractRecognitionData.prototype.getRecognitionInput = function () {\n        throw new Error('not implemented');\n    };\n\n    /**\n     * Set text input\n     *\n     * @method setRecognitionInput\n     * @param {AbstractRecognitionInput} input\n     */\n    AbstractRecognitionData.prototype.setRecognitionInput = function (input) { // jshint ignore:line\n        throw new Error('not implemented');\n    };\n\n    // Export\n    scope.AbstractRecognitionData = AbstractRecognitionData;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * List of languages recognition input\n     *\n     * @class RecognitionLanguagesData\n     * @extends AbstractRecognitionData\n     * @constructor\n     */\n    function RecognitionLanguagesData() {\n    }\n\n    /**\n     * Inheritance property\n     */\n    RecognitionLanguagesData.prototype = new scope.AbstractRecognitionData();\n\n    /**\n     * Constructor property\n     */\n    RecognitionLanguagesData.prototype.constructor = RecognitionLanguagesData;\n\n    /**\n     * Get the recognition input mode\n     *\n     * @method getInputMode\n     * @returns {String} inputMode\n     */\n    RecognitionLanguagesData.prototype.getInputMode = function () {\n        return this.inputMode;\n    };\n\n    /**\n     * Set the recognition input mode\n     *\n     * @method setInputMode\n     * @param {String} inputMode\n     */\n    RecognitionLanguagesData.prototype.setInputMode = function (inputMode) {\n        this.inputMode = inputMode;\n    };\n\n    // Export\n    scope.RecognitionLanguagesData = RecognitionLanguagesData;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * WebSocket start math recognition message\n     *\n     * @class AbstractStartRequestWSMessage\n     * @extends AbstractWSMessage\n     * @param {Object} [obj] Recognition WebSocket message\n     * @constructor\n     */\n    function AbstractStartRequestWSMessage(obj) {\n        this.type = 'start';\n        scope.AbstractWSMessage.call(this, obj);\n    }\n\n    /**\n     * Inheritance property\n     */\n    AbstractStartRequestWSMessage.prototype = new scope.AbstractWSMessage();\n\n    /**\n     * Constructor property\n     */\n    AbstractStartRequestWSMessage.prototype.constructor = AbstractStartRequestWSMessage;\n\n    // Export\n    scope.AbstractStartRequestWSMessage = AbstractStartRequestWSMessage;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * WebSocket continue math recognition message\n     *\n     * @class AbstractContinueRequestWSMessage\n     * @extends AbstractWSMessage\n     * @param {Object} [obj] Recognition WebSocket message\n     * @constructor\n     */\n    function AbstractContinueRequestWSMessage(obj) {\n        this.type = 'continue';\n        scope.AbstractWSMessage.call(this, obj);\n    }\n\n    /**\n     * Inheritance property\n     */\n    AbstractContinueRequestWSMessage.prototype = new scope.AbstractWSMessage();\n\n    /**\n     * Constructor property\n     */\n    AbstractContinueRequestWSMessage.prototype.constructor = AbstractContinueRequestWSMessage;\n\n    /**\n     * Get instanceId\n     *\n     * @method getInstanceId\n     * @returns {String}\n     */\n    AbstractContinueRequestWSMessage.prototype.getInstanceId = function () {\n        return this.instanceId;\n    };\n\n    /**\n     * Set instanceId\n     *\n     * @method setInstanceId\n     * @param {String} instanceId\n     */\n    AbstractContinueRequestWSMessage.prototype.setInstanceId = function (instanceId) {\n        this.instanceId = instanceId;\n    };\n\n    // Export\n    scope.AbstractContinueRequestWSMessage = AbstractContinueRequestWSMessage;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * WebSocket recognition hmac challenge message\n     *\n     * @class ChallengeRequestWSMessage\n     * @extends AbstractWSMessage\n     * @param {Object} [obj] Recognition WebSocket message\n     * @constructor\n     */\n    function ChallengeRequestWSMessage(obj) {\n        this.type = 'hmac';\n        scope.AbstractWSMessage.call(this, obj);\n    }\n\n    /**\n     * Inheritance property\n     */\n    ChallengeRequestWSMessage.prototype = new scope.AbstractWSMessage();\n\n    /**\n     * Constructor property\n     */\n    ChallengeRequestWSMessage.prototype.constructor = ChallengeRequestWSMessage;\n\n    /**\n     * Get the challenge\n     *\n     * @method getChallenge\n     * @returns {String}\n     */\n    ChallengeRequestWSMessage.prototype.getChallenge = function () {\n        return this.challenge;\n    };\n\n    /**\n     * Set the challenge\n     *\n     * @method setChallenge\n     * @param {String} challenge\n     */\n    ChallengeRequestWSMessage.prototype.setChallenge = function (challenge) {\n        this.challenge = challenge;\n    };\n\n    /**\n     * Get the application key\n     *\n     * @method getApplicationKey\n     * @returns {String}\n     */\n    ChallengeRequestWSMessage.prototype.getApplicationKey = function () {\n        return this.applicationKey;\n    };\n\n    /**\n     * Set the application key\n     *\n     * @method setApplicationKey\n     * @param {String} applicationKey\n     */\n    ChallengeRequestWSMessage.prototype.setApplicationKey = function (applicationKey) {\n        this.applicationKey = applicationKey;\n    };\n\n    /**\n     * Get HMAC signature\n     *\n     * @method getHmacSignature\n     * @returns {String}\n     */\n    ChallengeRequestWSMessage.prototype.getHmacSignature = function () {\n        return this.hmac;\n    };\n\n    /**\n     * Set HMAC signature\n     *\n     * @method setHmacSignature\n     * @param {String} hmac\n     */\n    ChallengeRequestWSMessage.prototype.setHmacSignature = function (hmac) {\n        this.hmac = hmac;\n    };\n\n    // Export\n    scope.ChallengeRequestWSMessage = ChallengeRequestWSMessage;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * WebSocket recognition hmac challenge message\n     *\n     * @class InitRequestWSMessage\n     * @extends AbstractWSMessage\n     * @param {Object} [obj] Recognition WebSocket message\n     * @constructor\n     */\n    function InitRequestWSMessage(obj) {\n        this.type = 'applicationKey';\n        scope.AbstractWSMessage.call(this, obj);\n    }\n\n    /**\n     * Inheritance property\n     */\n    InitRequestWSMessage.prototype = new scope.AbstractWSMessage();\n\n    /**\n     * Constructor property\n     */\n    InitRequestWSMessage.prototype.constructor = InitRequestWSMessage;\n\n    /**\n     * Get the application key\n     *\n     * @method getApplicationKey\n     * @returns {String}\n     */\n    InitRequestWSMessage.prototype.getApplicationKey = function () {\n        return this.applicationKey;\n    };\n\n    /**\n     * Set the application key\n     *\n     * @method setApplicationKey\n     * @param {String} applicationKey\n     */\n    InitRequestWSMessage.prototype.setApplicationKey = function (applicationKey) {\n        this.applicationKey = applicationKey;\n    };\n\n    // Export\n    scope.InitRequestWSMessage = InitRequestWSMessage;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * WebSocket recognition hmac challenge message\n     *\n     * @class ResetRequestWSMessage\n     * @extends AbstractWSMessage\n     * @param {Object} [obj] Recognition WebSocket message\n     * @constructor\n     */\n    function ResetRequestWSMessage(obj) {\n        this.type = 'reset';\n        scope.AbstractWSMessage.call(this, obj);\n    }\n\n    /**\n     * Inheritance property\n     */\n    ResetRequestWSMessage.prototype = new scope.AbstractWSMessage();\n\n    /**\n     * Constructor property\n     */\n    ResetRequestWSMessage.prototype.constructor = ResetRequestWSMessage;\n\n    // Export\n    scope.ResetRequestWSMessage = ResetRequestWSMessage;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Abstract text input component\n     *\n     * @class AbstractTextInputComponent\n     * @extends AbstractComponent\n     * @constructor\n     */\n    function AbstractTextInputComponent(obj) {\n        scope.AbstractComponent.call(this);\n        if (obj) {\n            if (obj.boundingBox) {\n                this.boundingBox = new scope.Rectangle(obj.boundingBox);\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    AbstractTextInputComponent.prototype = new scope.AbstractComponent();\n\n    /**\n     * Constructor property\n     */\n    AbstractTextInputComponent.prototype.constructor = AbstractTextInputComponent;\n\n    /**\n     * Get input component bounding-box\n     *\n     * @method getBoundingBox\n     * @returns {Rectangle}\n     */\n    AbstractTextInputComponent.prototype.getBoundingBox = function () {\n        return this.boundingBox;\n    };\n\n    /**\n     * Set input component bounding-box\n     *\n     * @method setBoundingBox\n     * @param {Rectangle} boundingBox\n     */\n    AbstractTextInputComponent.prototype.setBoundingBox = function (boundingBox) {\n        this.boundingBox = boundingBox;\n    };\n\n    // Export\n    scope.AbstractTextInputComponent = AbstractTextInputComponent;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * Char input component\n     *\n     * @class CharInputComponent\n     * @extends AbstractTextInputComponent\n     * @constructor\n     */\n    function CharInputComponent(obj) {\n        scope.AbstractTextInputComponent.call(this, obj);\n        this.type = 'char';\n        if (obj) {\n            if (obj.character) {\n                this.character = obj.character;\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    CharInputComponent.prototype = new scope.AbstractTextInputComponent();\n\n    /**\n     * Constructor property\n     */\n    CharInputComponent.prototype.constructor = CharInputComponent;\n\n    /**\n     * Get label\n     *\n     * @method getLabel\n     * @returns {String}\n     */\n    CharInputComponent.prototype.getLabel = function () {\n        return this.character;\n    };\n\n    /**\n     * Set label\n     *\n     * @method setLabel\n     * @param {String} label\n     */\n    CharInputComponent.prototype.setLabel = function (label) {\n        this.character = label;\n    };\n\n    // Export\n    scope.CharInputComponent = CharInputComponent;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * String input component\n     *\n     * @class StringInputComponent\n     * @extends AbstractTextInputComponent\n     * @constructor\n     */\n    function StringInputComponent(obj) {\n        scope.AbstractTextInputComponent.call(this, obj);\n        this.type = 'string';\n        if (obj) {\n            if (obj.string) {\n                this.string = obj.string;\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    StringInputComponent.prototype = new scope.AbstractTextInputComponent();\n\n    /**\n     * Constructor property\n     */\n    StringInputComponent.prototype.constructor = StringInputComponent;\n\n    /**\n     * Get label\n     *\n     * @method getLabel\n     * @returns {String}\n     */\n    StringInputComponent.prototype.getLabel = function () {\n        return this.string;\n    };\n\n    /**\n     * Set label\n     *\n     * @method setLabel\n     * @param {String} label\n     */\n    StringInputComponent.prototype.setLabel = function (label) {\n        this.string = label;\n    };\n\n    // Export\n    scope.StringInputComponent = StringInputComponent;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * Input unit used for text recognition\n     *\n     * @class TextInputUnit\n     * @constructor\n     */\n    function TextInputUnit() {\n        this.textInputType = 'MULTI_LINE_TEXT';\n        this.components = [];\n    }\n\n    /**\n     * Get the input type\n     *\n     * @method getInputType\n     * @returns {String}\n     */\n    TextInputUnit.prototype.getInputType = function () {\n        return this.textInputType;\n    };\n\n    /**\n     * Set the input type\n     *\n     * @method setInputType\n     * @returns {String} inputType\n     */\n    TextInputUnit.prototype.setInputType = function (inputType) {\n        this.textInputType = inputType;\n    };\n\n    /**\n     * Get components for this input unit\n     *\n     * @method getComponents\n     * @param {TextInkRange} [inkRange]\n     * @returns {AbstractComponent[]}\n     */\n    TextInputUnit.prototype.getComponents = function (inkRange) {\n        if (inkRange && (inkRange instanceof scope.TextInkRange)) {\n            return this.components.slice(inkRange.getStartComponent(), inkRange.getEndComponent() + 1);\n        }\n        return this.components;\n    };\n\n    /**\n     * Set components for this input unit\n     *\n     * @method setComponents\n     * @param {AbstractComponent[]} components\n     */\n    TextInputUnit.prototype.setComponents = function (components) {\n        this.components = components;\n    };\n\n    // Export\n    scope.TextInputUnit = TextInputUnit;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Parameters used for text recognition\n     *\n     * @class TextParameter\n     * @extends AbstractParameter\n     * @constructor\n     */\n    function TextParameter(obj) {\n        scope.AbstractParameter.call(this, obj);\n        this.textProperties = new scope.TextProperties();\n        if (obj) {\n            if (obj.language) {\n                this.language = obj.language;\n            }\n            if (obj.textInputMode) {\n                this.textInputMode = obj.textInputMode;\n            }\n            if (obj.contentTypes) {\n                this.contentTypes = obj.contentTypes;\n            }\n            if (obj.subsetKnowledges) {\n                this.subsetKnowledges = obj.subsetKnowledges;\n            }\n            if (obj.userResources) {\n                this.userResources = obj.userResources;\n            }\n            if (obj.userLkWords) {\n                this.userLkWords = obj.userLkWords;\n            }\n            if (obj.resultDetail) {\n                this.resultDetail = obj.resultDetail;\n            }\n            if (obj.textProperties) {\n                this.textProperties = new scope.TextProperties(obj.textProperties);\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    TextParameter.prototype = new scope.AbstractParameter();\n\n    /**\n     * Constructor property\n     */\n    TextParameter.prototype.constructor = TextParameter;\n\n    /**\n     * Get recognition language\n     *\n     * @method getLanguage\n     * @returns {String}\n     */\n    TextParameter.prototype.getLanguage = function () {\n        return this.language;\n    };\n\n    /**\n     * Set recognition language\n     *\n     * @method getLanguage\n     * @param {String} language\n     */\n    TextParameter.prototype.setLanguage = function (language) {\n        this.language = language;\n    };\n\n    /**\n     * Get input mode\n     *\n     * @method getInputMode\n     * @returns {'CURSIVE'|'ISOLATED'|'SUPERIMPOSED'|'VERTICAL'}\n     */\n    TextParameter.prototype.getInputMode = function () {\n        return this.textInputMode;\n    };\n\n    /**\n     * Set input mode\n     *\n     * @method setInputMode\n     * @param {'CURSIVE'|'ISOLATED'|'SUPERIMPOSED'|'VERTICAL'} inputMode\n     */\n    TextParameter.prototype.setInputMode = function (inputMode) {\n        this.textInputMode = inputMode;\n    };\n\n    /**\n     * Get content types\n     *\n     * @method getContentTypes\n     * @returns {Array}\n     */\n    TextParameter.prototype.getContentTypes = function () {\n        return this.contentTypes;\n    };\n\n    /**\n     * Set content types\n     *\n     * @method setContentTypes\n     * @param {Array} contentTypes\n     */\n    TextParameter.prototype.setContentTypes = function (contentTypes) {\n        this.contentTypes = contentTypes;\n    };\n\n    /**\n     * Get SK\n     *\n     * @method getSubsetKnowledges\n     * @returns {Array}\n     */\n    TextParameter.prototype.getSubsetKnowledges = function () {\n        return this.subsetKnowledges;\n    };\n\n    /**\n     * Set SK\n     *\n     * @method setSubsetKnowledges\n     * @param {Array} subsetKnowledges\n     */\n    TextParameter.prototype.setSubsetKnowledges = function (subsetKnowledges) {\n        this.subsetKnowledges = subsetKnowledges;\n    };\n\n    /**\n     * Get user resources\n     *\n     * @method getUserResources\n     * @returns {Array}\n     */\n    TextParameter.prototype.getUserResources = function () {\n        return this.userResources;\n    };\n\n    /**\n     * Set user resources\n     *\n     * @method setUserResources\n     * @param {Array} userResources\n     */\n    TextParameter.prototype.setUserResources = function (userResources) {\n        this.userResources = userResources;\n    };\n\n    /**\n     * Get user LK words\n     *\n     * @method getUserLkWords\n     * @returns {Array}\n     */\n    TextParameter.prototype.getUserLkWords = function () {\n        return this.userLkWords;\n    };\n\n    /**\n     * Set user LK words\n     *\n     * @method setUserLkWords\n     * @param {Array} userLkWords\n     */\n    TextParameter.prototype.setUserLkWords = function (userLkWords) {\n        this.userLkWords = userLkWords;\n    };\n\n    /**\n     * Get result detail (e.g. TEXT, WORD ...)\n     *\n     * @method getResultDetail\n     * @returns {'TEXT'|'WORD'|'CHARACTER'}\n     */\n    TextParameter.prototype.getResultDetail = function () {\n        return this.resultDetail;\n    };\n\n    /**\n     * Set result detail (e.g. TEXT, WORD ...)\n     *\n     * @method setResultDetail\n     * @param {'TEXT'|'WORD'|'CHARACTER'} resultDetail\n     */\n    TextParameter.prototype.setResultDetail = function (resultDetail) {\n        this.resultDetail = resultDetail;\n    };\n\n    /**\n     * Get text properties\n     *\n     * @method getTextProperties\n     * @returns {TextProperties}\n     */\n    TextParameter.prototype.getTextProperties = function () {\n        return this.textProperties;\n    };\n\n    /**\n     * Set text properties\n     *\n     * @method setTextProperties\n     * @param {TextProperties} properties\n     */\n    TextParameter.prototype.setTextProperties = function (textProperties) {\n        this.textProperties = textProperties;\n    };\n\n    // Export\n    scope.TextParameter = TextParameter;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * Text recognition properties\n     *\n     * @class TextProperties\n     * @constructor\n     */\n    function TextProperties(obj) {\n        if (obj) {\n            if (obj.textCandidateListSize) {\n                this.textCandidateListSize = obj.textCandidateListSize;\n            }\n            if (obj.wordCandidateListSize) {\n                this.wordCandidateListSize = obj.wordCandidateListSize;\n            }\n            if (obj.wordPredictionListSize) {\n                this.wordPredictionListSize = obj.wordPredictionListSize;\n            }\n            if (obj.wordCompletionListSize) {\n                this.wordCompletionListSize = obj.wordCompletionListSize;\n            }\n            if (obj.characterCandidateListSize) {\n                this.characterCandidateListSize = obj.characterCandidateListSize;\n            }\n            if (obj.discardCaseVariations) {\n                this.discardCaseVariations = obj.discardCaseVariations;\n            }\n            if (obj.discardAccentuationVariations) {\n                this.discardAccentuationVariations = obj.discardAccentuationVariations;\n            }\n            if (obj.disableSpatialOrdering) {\n                this.disableSpatialOrdering = obj.disableSpatialOrdering;\n            }\n            if (obj.glyphDistortion) {\n                this.glyphDistortion = obj.glyphDistortion;\n            }\n            if (obj.enableOutOfLexicon) {\n                this.enableOutOfLexicon = obj.enableOutOfLexicon;\n            }\n            if (obj.spellingDistortion) {\n                this.spellingDistortion = obj.spellingDistortion;\n            }\n        }\n    }\n\n    /**\n     * Get the number of text candidates requested\n     *\n     * @method getTextCandidateListSize\n     * @returns {Number}\n     */\n    TextProperties.prototype.getTextCandidateListSize = function () {\n        return this.textCandidateListSize;\n    };\n\n    /**\n     * Set the number of text candidates requested\n     *\n     * @method setTextCandidateListSize\n     * @param {Number} textCandidateListSize\n     */\n    TextProperties.prototype.setTextCandidateListSize = function (textCandidateListSize) {\n        this.textCandidateListSize = textCandidateListSize;\n    };\n\n    /**\n     * Get the number of word candidates requested\n     *\n     * @method getWordCandidateListSize\n     * @returns {Number}\n     */\n    TextProperties.prototype.getWordCandidateListSize = function () {\n        return this.wordCandidateListSize;\n    };\n\n    /**\n     * Set the number of word candidates requested\n     *\n     * @method setWordCandidateListSize\n     * @param {Number} wordCandidateListSize\n     */\n    TextProperties.prototype.setWordCandidateListSize = function (wordCandidateListSize) {\n        this.wordCandidateListSize = wordCandidateListSize;\n    };\n\n    /**\n     * Get the number of word prediction candidates requested\n     *\n     * @method getWordPredictionListSize\n     * @returns {Number}\n     */\n    TextProperties.prototype.getWordPredictionListSize = function () {\n        return this.wordPredictionListSize;\n    };\n\n    /**\n     * Set the number of word prediction candidates requested\n     *\n     * @method setWordPredictionListSize\n     * @param {Number} wordPredictionListSize\n     */\n    TextProperties.prototype.setWordPredictionListSize = function (wordPredictionListSize) {\n        this.wordPredictionListSize = wordPredictionListSize;\n    };\n\n    /**\n     * Get the number of word completion candidates requested\n     *\n     * @method getWordCompletionListSize\n     * @returns {Number}\n     */\n    TextProperties.prototype.getWordCompletionListSize = function () {\n        return this.wordCompletionListSize;\n    };\n\n    /**\n     * Set the number of word completion candidates requested\n     *\n     * @method setWordCompletionListSize\n     * @param {Number} wordCompletionListSize\n     */\n    TextProperties.prototype.setWordCompletionListSize = function (wordCompletionListSize) {\n        this.wordCompletionListSize = wordCompletionListSize;\n    };\n\n    /**\n     * Get the number of character candidates requested\n     *\n     * @method getCharacterCandidateListSize\n     * @returns {Number}\n     */\n    TextProperties.prototype.getCharacterCandidateListSize = function () {\n        return this.characterCandidateListSize;\n    };\n\n    /**\n     * Set the number of character candidates requested\n     *\n     * @method setCharacterCandidateListSize\n     * @param {Number} characterCandidateListSize\n     */\n    TextProperties.prototype.setCharacterCandidateListSize = function (characterCandidateListSize) {\n        this.characterCandidateListSize = characterCandidateListSize;\n    };\n\n    /**\n     * Get the discard case variations\n     *\n     * @method getDiscardCaseVariations\n     * @returns {boolean}\n     */\n    TextProperties.prototype.getDiscardCaseVariations = function () {\n        return this.discardCaseVariations;\n    };\n\n    /**\n     * Set the discard case variations\n     *\n     * @method setDiscardCaseVariations\n     * @param {boolean} discardCaseVariations\n     */\n    TextProperties.prototype.setDiscardCaseVariations = function (discardCaseVariations) {\n        this.discardCaseVariations = discardCaseVariations;\n    };\n\n    /**\n     * Get the discard accentuation variations\n     *\n     * @method getDiscardAccentuationVariations\n     * @returns {boolean}\n     */\n    TextProperties.prototype.getDiscardAccentuationVariations = function () {\n        return this.discardAccentuationVariations;\n    };\n\n    /**\n     * Set the discard accentuation variations\n     *\n     * @method setDiscardAccentuationVariations\n     * @param {boolean} discardAccentuationVariations\n     */\n    TextProperties.prototype.setDiscardAccentuationVariations = function (discardAccentuationVariations) {\n        this.discardAccentuationVariations = discardAccentuationVariations;\n    };\n\n    /**\n     * Get disable spatial ordering\n     *\n     * @method getDisableSpatialOrdering\n     * @returns {Boolean}\n     */\n    TextProperties.prototype.getDisableSpatialOrdering = function () {\n        return this.disableSpatialOrdering;\n    };\n\n    /**\n     * Set disable spatial ordering\n     *\n     * @method setDisableSpatialOrdering\n     * @param {Boolean} disableSpatialOrdering\n     */\n    TextProperties.prototype.setDisableSpatialOrdering = function (disableSpatialOrdering) {\n        this.disableSpatialOrdering = disableSpatialOrdering;\n    };\n\n    /**\n     * Get glyph distortion\n     *\n     * @method getGlyphDistortion\n     * @returns {Number}\n     */\n    TextProperties.prototype.getGlyphDistortion = function () {\n        return this.glyphDistortion;\n    };\n\n    /**\n     * Set glyph distortion\n     *\n     * @method setGlyphDistortion\n     * @param {Number} glyphDistortion\n     */\n    TextProperties.prototype.setGlyphDistortion = function (glyphDistortion) {\n        this.glyphDistortion = glyphDistortion;\n    };\n\n    /**\n     * Get enable out of lexicon\n     *\n     * @method getEnableOutOfLexicon\n     * @returns {Boolean}\n     */\n    TextProperties.prototype.getEnableOutOfLexicon = function () {\n        return this.enableOutOfLexicon;\n    };\n\n    /**\n     * Set enable out of lexicon\n     *\n     * @method setEnableOutOfLexicon\n     * @param {Boolean} enableOutOfLexicon\n     */\n    TextProperties.prototype.setEnableOutOfLexicon = function (enableOutOfLexicon) {\n        this.enableOutOfLexicon = enableOutOfLexicon;\n    };\n\n    /**\n     * Get spelling distortion\n     *\n     * @method getSpellingDistortion\n     * @returns {Number}\n     */\n    TextProperties.prototype.getSpellingDistortion = function () {\n        return this.spellingDistortion;\n    };\n\n    /**\n     * Set spelling distortion\n     *\n     * @method setSpellingDistortion\n     * @param {Number} spellingDistortion\n     */\n    TextProperties.prototype.setSpellingDistortion = function (spellingDistortion) {\n        this.spellingDistortion = spellingDistortion;\n    };\n\n    // Export\n    scope.TextProperties = TextProperties;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * Recognition input object for text recognition\n     *\n     * @class TextRecognitionInput\n     * @extends AbstractRecognitionInput\n     * @constructor\n     */\n    function TextRecognitionInput() {\n    }\n\n    /**\n     * Inheritance property\n     */\n    TextRecognitionInput.prototype = new scope.AbstractRecognitionInput();\n\n    /**\n     * Constructor property\n     */\n    TextRecognitionInput.prototype.constructor = TextRecognitionInput;\n\n    /**\n     * Get parameters\n     *\n     * @method getParameters\n     * @returns {TextParameter}\n     */\n    TextRecognitionInput.prototype.getParameters = function () {\n        return this.textParameter;\n    };\n\n    /**\n     * Set parameters\n     *\n     * @method setParameters\n     * @param {TextParameter} parameters\n     */\n    TextRecognitionInput.prototype.setParameters = function (parameters) {\n        this.textParameter = parameters;\n    };\n\n    /**\n     * Get input units\n     *\n     * @method getInputUnits\n     * @param {TextInkRange} [inkRange]\n     * @returns {TextInputUnit[]}\n     */\n    TextRecognitionInput.prototype.getInputUnits = function (inkRange) {\n        if (inkRange && (inkRange instanceof scope.TextInkRange)) {\n            return this.inputUnits.slice(inkRange.getStartUnit(), inkRange.getEndUnit() + 1);\n        }\n        return this.inputUnits;\n    };\n\n    /**\n     * Set input units\n     *\n     * @method setInputUnits\n     * @param {TextInputUnit[]} inputUnits\n     */\n    TextRecognitionInput.prototype.setInputUnits = function (inputUnits) {\n        this.inputUnits = inputUnits;\n    };\n\n    // Export\n    scope.TextRecognitionInput = TextRecognitionInput;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Recognition data for text input\n     *\n     * @class TextRecognitionData\n     * @extends AbstractRecognitionData\n     * @constructor\n     */\n    function TextRecognitionData() {\n    }\n\n    /**\n     * Inheritance property\n     */\n    TextRecognitionData.prototype = new scope.AbstractRecognitionData();\n\n    /**\n     * Constructor property\n     */\n    TextRecognitionData.prototype.constructor = TextRecognitionData;\n\n    /**\n     * Get text input\n     *\n     * @method getRecognitionInput\n     * @returns {TextRecognitionInput} input\n     */\n    TextRecognitionData.prototype.getRecognitionInput = function () {\n        return this.textInput;\n    };\n\n    /**\n     * Set text input\n     *\n     * @method setRecognitionInput\n     * @param {TextRecognitionInput} input\n     */\n    TextRecognitionData.prototype.setRecognitionInput = function (input) {\n        this.textInput = JSON.stringify(input);\n    };\n\n    // Export\n    scope.TextRecognitionData = TextRecognitionData;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * WebSocket start text recognition message\n     *\n     * @class TextStartRequestWSMessage\n     * @extends AbstractStartRequestWSMessage\n     * @param {Object} [obj] Recognition WebSocket message\n     * @constructor\n     */\n    function TextStartRequestWSMessage(obj) {\n        scope.AbstractStartRequestWSMessage.call(this, obj);\n    }\n\n    /**\n     * Inheritance property\n     */\n    TextStartRequestWSMessage.prototype = new scope.AbstractStartRequestWSMessage();\n\n    /**\n     * Constructor property\n     */\n    TextStartRequestWSMessage.prototype.constructor = TextStartRequestWSMessage;\n\n    /**\n     * Get parameters\n     *\n     * @method getParameters\n     * @returns {TextParameter}\n     */\n    TextStartRequestWSMessage.prototype.getParameters = function () {\n        return this.textParameter;\n    };\n\n    /**\n     * Set parameters\n     *\n     * @method setParameters\n     * @param {TextParameter} parameters\n     */\n    TextStartRequestWSMessage.prototype.setParameters = function (parameters) {\n        this.textParameter = parameters;\n    };\n\n    /**\n     * Get input units\n     *\n     * @method getInputUnits\n     * @returns {TextInputUnit[]}\n     */\n    TextStartRequestWSMessage.prototype.getInputUnits = function () {\n        return this.inputUnits;\n    };\n\n    /**\n     * Set input units\n     *\n     * @method setInputUnits\n     * @param {TextInputUnit[]} inputUnits\n     */\n    TextStartRequestWSMessage.prototype.setInputUnits = function (inputUnits) {\n        this.inputUnits = inputUnits;\n    };\n\n    // Export\n    scope.TextStartRequestWSMessage = TextStartRequestWSMessage;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * WebSocket continue text recognition message\n     *\n     * @class TextContinueRequestWSMessage\n     * @extends AbstractContinueRequestWSMessage\n     * @param {Object} [obj] Recognition WebSocket message\n     * @constructor\n     */\n    function TextContinueRequestWSMessage(obj) {\n        scope.AbstractContinueRequestWSMessage.call(this, obj);\n    }\n\n    /**\n     * Inheritance property\n     */\n    TextContinueRequestWSMessage.prototype = new scope.AbstractContinueRequestWSMessage();\n\n    /**\n     * Constructor property\n     */\n    TextContinueRequestWSMessage.prototype.constructor = TextContinueRequestWSMessage;\n\n    /**\n     * Get input units\n     *\n     * @method getInputUnits\n     * @returns {TextInputUnit[]}\n     */\n    TextContinueRequestWSMessage.prototype.getInputUnits = function () {\n        return this.inputUnits;\n    };\n\n    /**\n     * Set input units\n     *\n     * @method setInputUnits\n     * @param {TextInputUnit[]} inputUnits\n     */\n    TextContinueRequestWSMessage.prototype.setInputUnits = function (inputUnits) {\n        this.inputUnits = inputUnits;\n    };\n\n    // Export\n    scope.TextContinueRequestWSMessage = TextContinueRequestWSMessage;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Parameters used for shape recognition\n     *\n     * @class ShapeParameter\n     * @extends AbstractParameter\n     * @constructor\n     */\n    function ShapeParameter(obj) {\n        scope.AbstractParameter.call(this, obj);\n        if (obj) {\n            if (obj.rejectDetectionSensitivity) {\n                this.rejectDetectionSensitivity = obj.rejectDetectionSensitivity;\n            }\n            if (obj.doBeautification) {\n                this.doBeautification = obj.doBeautification;\n            }\n            if (obj.userResources) {\n                this.userResources = obj.userResources;\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    ShapeParameter.prototype = new scope.AbstractParameter();\n\n    /**\n     * Constructor property\n     */\n    ShapeParameter.prototype.constructor = ShapeParameter;\n\n    /**\n     * Get the sensitivity of the reject detection\n     *\n     * @method getRejectDetectionSensitivity\n     * @returns {Boolean}\n     */\n    ShapeParameter.prototype.getRejectDetectionSensitivity = function () {\n        return this.rejectDetectionSensitivity;\n    };\n\n    /**\n     * Set the sensitivity of the reject detection\n     *\n     * @method setRejectDetectionSensitivity\n     * @param {Boolean} rejectDetectionSensitivity\n     */\n    ShapeParameter.prototype.setRejectDetectionSensitivity = function (rejectDetectionSensitivity) {\n        this.rejectDetectionSensitivity = rejectDetectionSensitivity;\n    };\n\n    /**\n     * Get the beautification\n     *\n     * @method hasBeautification\n     * @returns {Boolean}\n     */\n    ShapeParameter.prototype.hasBeautification = function () {\n        return this.doBeautification;\n    };\n\n    /**\n     * Set the beautification\n     *\n     * @method setBeautification\n     * @param {Boolean} doBeautification\n     */\n    ShapeParameter.prototype.setBeautification = function (doBeautification) {\n        this.doBeautification = doBeautification;\n    };\n\n    /**\n     * Get the user resources\n     *\n     * @method getUserResources\n     * @returns {Array}\n     */\n    ShapeParameter.prototype.getUserResources = function () {\n        return this.userResources;\n    };\n\n    /**\n     * Set the user resources\n     *\n     * @method setUserResources\n     * @param {Array} userResources\n     */\n    ShapeParameter.prototype.setUserResources = function (userResources) {\n        this.userResources = userResources;\n    };\n\n    // Export\n    scope.ShapeParameter = ShapeParameter;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * Recognition input object for shape recognition\n     *\n     * @class ShapeRecognitionInput\n     * @extends AbstractRecognitionInput\n     * @constructor\n     */\n    function ShapeRecognitionInput() {\n    }\n\n    /**\n     * Inheritance property\n     */\n    ShapeRecognitionInput.prototype = new scope.AbstractRecognitionInput();\n\n    /**\n     * Constructor property\n     */\n    ShapeRecognitionInput.prototype.constructor = ShapeRecognitionInput;\n\n    /**\n     * Get parameters\n     *\n     * @method getParameters\n     * @returns {ShapeParameter}\n     */\n    ShapeRecognitionInput.prototype.getParameters = function () {\n        return new ShapeParameter({\n            rejectDetectionSensitivity: this.rejectDetectionSensitivity,\n            doBeautification: this.doBeautification,\n            userResources: this.userResources\n        });\n    };\n\n    /**\n     * Set parameters\n     *\n     * @method setParameters\n     * @param {ShapeParameter} parameters\n     */\n    ShapeRecognitionInput.prototype.setParameters = function (parameters) {\n        if (parameters) {\n            this.rejectDetectionSensitivity = parameters.getRejectDetectionSensitivity();\n            this.doBeautification = parameters.hasBeautification();\n            this.userResources = parameters.getUserResources();\n        }\n    };\n\n    /**\n     * Get input components\n     *\n     * @method getComponents\n     * @returns {AbstractComponent[]}\n     */\n    ShapeRecognitionInput.prototype.getComponents = function () {\n        return this.components;\n    };\n\n    /**\n     * Set input components\n     *\n     * @method setComponents\n     * @param {AbstractComponent[]} components\n     */\n    ShapeRecognitionInput.prototype.setComponents = function (components) {\n        this.components = components;\n    };\n\n    // Export\n    scope.ShapeRecognitionInput = ShapeRecognitionInput;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * Recognition data for shape input\n     *\n     * @class ShapeRecognitionData\n     * @extends AbstractRecognitionData\n     * @constructor\n     */\n    function ShapeRecognitionData() {\n    }\n\n    /**\n     * Inheritance property\n     */\n    ShapeRecognitionData.prototype = new scope.AbstractRecognitionData();\n\n    /**\n     * Constructor property\n     */\n    ShapeRecognitionData.prototype.constructor = ShapeRecognitionData;\n\n    /**\n     * Get shape input\n     *\n     * @method getRecognitionInput\n     * @returns {ShapeRecognitionInput}\n     */\n    ShapeRecognitionData.prototype.getRecognitionInput = function () {\n        return this.shapeInput;\n    };\n\n    /**\n     * Set shape input\n     *\n     * @method setRecognitionInput\n     * @param {ShapeRecognitionInput} input\n     */\n    ShapeRecognitionData.prototype.setRecognitionInput = function (input) {\n        this.shapeInput = JSON.stringify(input);\n    };\n\n    // Export\n    scope.ShapeRecognitionData = ShapeRecognitionData;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * Parameters used for math recognition\n     *\n     * @class MathParameter\n     * @extends AbstractParameter\n     * @constructor\n     */\n    function MathParameter(obj) {\n        scope.AbstractParameter.call(this, obj);\n        this.resultTypes = [];\n        this.userResources = [];\n        if (obj) {\n            if (obj.resultTypes) {\n                this.resultTypes = obj.resultTypes;\n            }\n            if (obj.columnarOperation) {\n                this.columnarOperation = obj.columnarOperation;\n            }\n            if (obj.userResources) {\n                this.userResources = obj.userResources;\n            }\n            if (obj.scratchOutDetectionSensitivity) {\n                this.scratchOutDetectionSensitivity = obj.scratchOutDetectionSensitivity;\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MathParameter.prototype = new scope.AbstractParameter();\n\n    /**\n     * Constructor property\n     */\n    MathParameter.prototype.constructor = MathParameter;\n\n    /**\n     * Get the math result types (e.g. LaTex, MathML, SymbolTree)\n     *\n     * @method getResultTypes\n     * @returns {Array}\n     */\n    MathParameter.prototype.getResultTypes = function () {\n        return this.resultTypes;\n    };\n\n    /**\n     * Set the math result types (e.g. LaTex, MathML, SymbolTree)\n     *\n     * @method setResultTypes\n     * @param {Array} resultTypes\n     */\n    MathParameter.prototype.setResultTypes = function (resultTypes) {\n        this.resultTypes = resultTypes;\n    };\n\n    /**\n     * Get the math result result orientation to columnar operations\n     *\n     * @method isColumnar\n     * @returns {Boolean}\n     */\n    MathParameter.prototype.isColumnar = function () {\n        return this.columnarOperation;\n    };\n\n    /**\n     * Set the math result orientation to columnar operations\n     *\n     * @method setColumnar\n     * @param  {Boolean} columnar\n     */\n    MathParameter.prototype.setColumnar = function (columnar) {\n        this.columnarOperation = columnar;\n    };\n\n    /**\n     * Get the user resources\n     *\n     * @method getUserResources\n     * @returns {Array}\n     */\n    MathParameter.prototype.getUserResources = function () {\n        return this.userResources;\n    };\n\n    /**\n     * Set the user resources\n     *\n     * @method setUserResources\n     * @param {Array} userResources\n     */\n    MathParameter.prototype.setUserResources = function (userResources) {\n        this.userResources = userResources;\n    };\n\n    /**\n     * Get the sensitivity of the scratch-out detection\n     *\n     * @method getScratchOutDetectionSensitivity\n     * @returns {Number}\n     */\n    MathParameter.prototype.getScratchOutDetectionSensitivity = function () {\n        return this.scratchOutDetectionSensitivity;\n    };\n\n    /**\n     * Set the sensitivity of the scratch-out detection\n     *\n     * @method setScratchOutDetectionSensitivity\n     * @param {Number} scratchOutDetectionSensitivity\n     */\n    MathParameter.prototype.setScratchOutDetectionSensitivity = function (scratchOutDetectionSensitivity) {\n        this.scratchOutDetectionSensitivity = scratchOutDetectionSensitivity;\n    };\n\n    // Export\n    scope.MathParameter = MathParameter;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * Recognition input object for math recognition\n     *\n     * @class MathRecognitionInput\n     * @extends AbstractRecognitionInput\n     * @constructor\n     */\n    function MathRecognitionInput() {\n    }\n\n    /**\n     * Inheritance property\n     */\n    MathRecognitionInput.prototype = new scope.AbstractRecognitionInput();\n\n    /**\n     * Constructor property\n     */\n    MathRecognitionInput.prototype.constructor = MathRecognitionInput;\n\n    /**\n     * Get parameters\n     *\n     * @method getParameters\n     * @returns {MathParameter}\n     */\n    MathRecognitionInput.prototype.getParameters = function () {\n        return new MathParameter({\n            resultTypes: this.resultTypes,\n            columnarOperation: this.columnarOperation,\n            userResources: this.userResources,\n            scratchOutDetectionSensitivity: this.scratchOutDetectionSensitivity\n        });\n    };\n\n    /**\n     * Set parameters\n     *\n     * @method setParameters\n     * @param {MathParameter} parameters\n     */\n    MathRecognitionInput.prototype.setParameters = function (parameters) {\n        if (parameters) {\n            this.resultTypes = parameters.getResultTypes();\n            this.columnarOperation = parameters.isColumnar();\n            this.userResources = parameters.getUserResources();\n            this.scratchOutDetectionSensitivity = parameters.getScratchOutDetectionSensitivity();\n        }\n    };\n\n    /**\n     * Get input components\n     *\n     * @method getComponents\n     * @returns {AbstractComponent[]}\n     */\n    MathRecognitionInput.prototype.getComponents = function () {\n        return this.components;\n    };\n\n    /**\n     * Set input components\n     *\n     * @method setComponents\n     * @param {AbstractComponent[]} components\n     */\n    MathRecognitionInput.prototype.setComponents = function (components) {\n        this.components = components;\n    };\n\n    // Export\n    scope.MathRecognitionInput = MathRecognitionInput;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * Recognition data for math input\n     *\n     * @class MathRecognitionData\n     * @extends AbstractRecognitionData\n     * @constructor\n     */\n    function MathRecognitionData() {\n    }\n\n    /**\n     * Inheritance property\n     */\n    MathRecognitionData.prototype = new scope.AbstractRecognitionData();\n\n    /**\n     * Constructor property\n     */\n    MathRecognitionData.prototype.constructor = MathRecognitionData;\n\n\n    /**\n     * Get math input\n     *\n     * @method getRecognitionInput\n     * @returns {MathRecognitionInput}\n     */\n    MathRecognitionData.prototype.getRecognitionInput = function () {\n        return this.mathInput;\n    };\n\n    /**\n     * Set math input\n     *\n     * @method setRecognitionInput\n     * @param {MathRecognitionInput} input\n     */\n    MathRecognitionData.prototype.setRecognitionInput = function (input) {\n        this.mathInput = JSON.stringify(input);\n    };\n\n    // Export\n    scope.MathRecognitionData = MathRecognitionData;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * WebSocket start math recognition message\n     *\n     * @class MathStartRequestWSMessage\n     * @extends AbstractStartRequestWSMessage\n     * @param {Object} [obj] Recognition WebSocket message\n     * @constructor\n     */\n    function MathStartRequestWSMessage(obj) {\n        scope.AbstractStartRequestWSMessage.call(this, obj);\n    }\n\n    /**\n     * Inheritance property\n     */\n    MathStartRequestWSMessage.prototype = new scope.AbstractStartRequestWSMessage();\n\n    /**\n     * Constructor property\n     */\n    MathStartRequestWSMessage.prototype.constructor = MathStartRequestWSMessage;\n\n    /**\n     * Get parameters\n     *\n     * @method getParameters\n     * @returns {MathParameter}\n     */\n    MathStartRequestWSMessage.prototype.getParameters = function () {\n        return this.parameters;\n    };\n\n    /**\n     * Set parameters\n     *\n     * @method setParameters\n     * @param {MathParameter} parameters\n     */\n    MathStartRequestWSMessage.prototype.setParameters = function (parameters) {\n        this.parameters = parameters;\n    };\n\n    /**\n     * Get components\n     *\n     * @method getComponents\n     * @returns {MathInputUnit[]}\n     */\n    MathStartRequestWSMessage.prototype.getComponents = function () {\n        return this.components;\n    };\n\n    /**\n     * Set components\n     *\n     * @method setComponents\n     * @param {MathInputUnit[]} components\n     */\n    MathStartRequestWSMessage.prototype.setComponents = function (components) {\n        this.components = components;\n    };\n\n    // Export\n    scope.MathStartRequestWSMessage = MathStartRequestWSMessage;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * WebSocket continue math recognition message\n     *\n     * @class MathContinueRequestWSMessage\n     * @extends AbstractContinueRequestWSMessage\n     * @param {Object} [obj] Recognition WebSocket message\n     * @constructor\n     */\n    function MathContinueRequestWSMessage(obj) {\n        this.type = 'continue';\n        scope.AbstractContinueRequestWSMessage.call(this, obj);\n    }\n\n    /**\n     * Inheritance property\n     */\n    MathContinueRequestWSMessage.prototype = new scope.AbstractContinueRequestWSMessage();\n\n    /**\n     * Constructor property\n     */\n    MathContinueRequestWSMessage.prototype.constructor = MathContinueRequestWSMessage;\n\n    /**\n     * Get components\n     *\n     * @method getComponents\n     * @returns {MathInputUnit[]}\n     */\n    MathContinueRequestWSMessage.prototype.getComponents = function () {\n        return this.components;\n    };\n\n    /**\n     * Set components\n     *\n     * @method setComponents\n     * @param {MathInputUnit[]} components\n     */\n    MathContinueRequestWSMessage.prototype.setComponents = function (components) {\n        this.components = components;\n    };\n\n    // Export\n    scope.MathContinueRequestWSMessage = MathContinueRequestWSMessage;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Abstract music input component\n     *\n     * @class AbstractMusicInputComponent\n     * @extends AbstractComponent\n     * @constructor\n     */\n    function AbstractMusicInputComponent(obj) {\n        scope.AbstractComponent.call(this);\n        if (obj) {\n            if (obj.boundingBox) {\n                this.boundingBox = new scope.Rectangle(obj.boundingBox);\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    AbstractMusicInputComponent.prototype = new scope.AbstractComponent();\n\n    /**\n     * Constructor property\n     */\n    AbstractMusicInputComponent.prototype.constructor = AbstractMusicInputComponent;\n\n    /**\n     * Get input component bounding-box\n     *\n     * @method getBoundingBox\n     * @returns {Rectangle}\n     */\n    AbstractMusicInputComponent.prototype.getBoundingBox = function () {\n        return this.boundingBox;\n    };\n\n    /**\n     * Set input component bounding-box\n     *\n     * @method setBoundingBox\n     * @param {Rectangle} boundingBox\n     */\n    AbstractMusicInputComponent.prototype.setBoundingBox = function (boundingBox) {\n        this.boundingBox = boundingBox;\n    };\n\n    // Export\n    scope.AbstractMusicInputComponent = AbstractMusicInputComponent;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * Accidental input component\n     *\n     * @class MusicAccidentalInputComponent\n     * @extends AbstractMusicInputComponent\n     * @constructor\n     */\n    function MusicAccidentalInputComponent(obj) {\n        scope.AbstractMusicInputComponent.call(this, obj);\n        this.type = 'accidental';\n        if (obj) {\n            if (obj.value) {\n                this.value = obj.value;\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicAccidentalInputComponent.prototype = new scope.AbstractMusicInputComponent();\n\n    /**\n     * Constructor property\n     */\n    MusicAccidentalInputComponent.prototype.constructor = MusicAccidentalInputComponent;\n\n    /**\n     * Get accidental input component value\n     *\n     * @method getValue\n     * @returns {String}\n     */\n    MusicAccidentalInputComponent.prototype.getValue = function () {\n        return this.value;\n    };\n\n    /**\n     * Set accidental input component value\n     *\n     * @method setValue\n     * @param {String} value\n     */\n    MusicAccidentalInputComponent.prototype.setValue = function (value) {\n        this.value = value;\n    };\n\n    // Export\n    scope.MusicAccidentalInputComponent = MusicAccidentalInputComponent;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * Arpeggiate input component\n     *\n     * @class MusicArpeggiateInputComponent\n     * @extends AbstractMusicInputComponent\n     * @constructor\n     */\n    function MusicArpeggiateInputComponent(obj) {\n        scope.AbstractMusicInputComponent.call(this, obj);\n        this.type = 'arpeggiate';\n        if (obj) {\n            if (obj.value) {\n                this.value = obj.value;\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicArpeggiateInputComponent.prototype = new scope.AbstractMusicInputComponent();\n\n    /**\n     * Constructor property\n     */\n    MusicArpeggiateInputComponent.prototype.constructor = MusicArpeggiateInputComponent;\n\n    /**\n     * Get arpeggiate input component value\n     *\n     * @method getValue\n     * @returns {String}\n     */\n    MusicArpeggiateInputComponent.prototype.getValue = function () {\n        return this.value;\n    };\n\n    /**\n     * Set arpeggiate input component value\n     *\n     * @method setValue\n     * @param {String} value\n     */\n    MusicArpeggiateInputComponent.prototype.setValue = function (value) {\n        this.value = value;\n    };\n\n    // Export\n    scope.MusicArpeggiateInputComponent = MusicArpeggiateInputComponent;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * Bar input component\n     *\n     * @class MusicBarInputComponent\n     * @extends AbstractMusicInputComponent\n     * @constructor\n     */\n    function MusicBarInputComponent(obj) {\n        scope.AbstractMusicInputComponent.call(this, obj);\n        this.type = 'bar';\n        this.value = new scope.MusicBar();\n        if (obj) {\n            if (obj.value) {\n                this.value = new scope.MusicBar(obj.value);\n            }\n        }\n\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicBarInputComponent.prototype = new scope.AbstractMusicInputComponent();\n\n    /**\n     * Constructor property\n     */\n    MusicBarInputComponent.prototype.constructor = MusicBarInputComponent;\n\n    /**\n     * Get bar component value\n     *\n     * @method getValue\n     * @returns {MusicBar}\n     */\n    MusicBarInputComponent.prototype.getValue = function () {\n        return this.value;\n    };\n\n    /**\n     * Set bar component value\n     *\n     * @method setValue\n     * @param {MusicBar} value\n     */\n    MusicBarInputComponent.prototype.setValue = function (value) {\n        this.value = value;\n    };\n\n    // Export\n    scope.MusicBarInputComponent = MusicBarInputComponent;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * Beam input component\n     *\n     * @class MusicBeamInputComponent\n     * @extends AbstractMusicInputComponent\n     * @constructor\n     */\n    function MusicBeamInputComponent(obj) {\n        scope.AbstractMusicInputComponent.call(this, obj);\n        this.type = 'beam';\n        this.value = new scope.MusicBeam();\n        if (obj) {\n            if (obj.value) {\n                this.value = new scope.MusicBeam(obj.value);\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicBeamInputComponent.prototype = new scope.AbstractMusicInputComponent();\n\n    /**\n     * Constructor property\n     */\n    MusicBeamInputComponent.prototype.constructor = MusicBeamInputComponent;\n\n    /**\n     * Get beam input component value\n     *\n     * @method getValue\n     * @returns {MusicBeam}\n     */\n    MusicBeamInputComponent.prototype.getValue = function () {\n        return this.value;\n    };\n\n    /**\n     * Set beam input component value\n     *\n     * @method setValue\n     * @param {MusicBeam} value\n     */\n    MusicBeamInputComponent.prototype.setValue = function (value) {\n        this.value = value;\n    };\n\n    // Export\n    scope.MusicBeamInputComponent = MusicBeamInputComponent;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * Clef input component\n     * default clef values: symbol='G', octave=0\n     *\n     * @class MusicClefInputComponent\n     * @extends AbstractMusicInputComponent\n     * @constructor\n     */\n    function MusicClefInputComponent(obj) {\n        scope.AbstractMusicInputComponent.call(this, obj);\n        this.type = 'clef';\n        this.value = new scope.MusicClef();\n        if (obj) {\n            if (obj.value) {\n                this.value = new scope.MusicClef(obj.value);\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicClefInputComponent.prototype = new scope.AbstractMusicInputComponent();\n\n    /**\n     * Constructor property\n     */\n    MusicClefInputComponent.prototype.constructor = MusicClefInputComponent;\n\n    /**\n     * Get clef input component value\n     *\n     * @method getValue\n     * @returns {MusicClef}\n     */\n    MusicClefInputComponent.prototype.getValue = function () {\n        return this.value;\n    };\n\n    /**\n     * Set clef input component value\n     *\n     * @method setValue\n     * @param {MusicClef} value\n     */\n    MusicClefInputComponent.prototype.setValue = function (value) {\n        this.value = value;\n    };\n\n    // Export\n    scope.MusicClefInputComponent = MusicClefInputComponent;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * Decoration input component\n     *\n     * @class MusicDecorationInputComponent\n     * @extends AbstractMusicInputComponent\n     * @constructor\n     */\n    function MusicDecorationInputComponent(obj) {\n        scope.AbstractMusicInputComponent.call(this, obj);\n        this.type = 'decoration';\n        this.value = new scope.MusicDecoration();\n        if (obj) {\n            if (obj.value) {\n                this.value = new scope.MusicDecoration(obj.value);\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicDecorationInputComponent.prototype = new scope.AbstractMusicInputComponent();\n\n    /**\n     * Constructor property\n     */\n    MusicDecorationInputComponent.prototype.constructor = MusicDecorationInputComponent;\n\n    /**\n     * Get decoration input component value\n     *\n     * @method getValue\n     * @returns {MusicDecoration}\n     */\n    MusicDecorationInputComponent.prototype.getValue = function () {\n        return this.value;\n    };\n\n    /**\n     * Set decoration input component value\n     *\n     * @method setValue\n     * @param {MusicDecoration} value\n     */\n    MusicDecorationInputComponent.prototype.setValue = function (value) {\n        this.value = value;\n    };\n\n    // Export\n    scope.MusicDecorationInputComponent = MusicDecorationInputComponent;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * Dots input component\n     *\n     * @class MusicDotsInputComponent\n     * @extends AbstractMusicInputComponent\n     * @constructor\n     */\n    function MusicDotsInputComponent(obj) {\n        scope.AbstractMusicInputComponent.call(this, obj);\n        this.type = 'dots';\n        if (obj) {\n            if (obj.value) {\n                this.value = obj.value;\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicDotsInputComponent.prototype = new scope.AbstractMusicInputComponent();\n\n    /**\n     * Constructor property\n     */\n    MusicDotsInputComponent.prototype.constructor = MusicDotsInputComponent;\n\n    /**\n     * Get dots input component value\n     *\n     * @method getValue\n     * @returns {String}\n     */\n    MusicDotsInputComponent.prototype.getValue = function () {\n        return this.value;\n    };\n\n    /**\n     * Set dots input component value\n     *\n     * @method setValue\n     * @param {String} value\n     */\n    MusicDotsInputComponent.prototype.setValue = function (value) {\n        this.value = value;\n    };\n\n    // Export\n    scope.MusicDotsInputComponent = MusicDotsInputComponent;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * Head input component\n     *\n     * @class MusicHeadInputComponent\n     * @extends AbstractMusicInputComponent\n     * @constructor\n     */\n    function MusicHeadInputComponent(obj) {\n        scope.AbstractMusicInputComponent.call(this, obj);\n        this.type = 'head';\n        if (obj) {\n            if (obj.value) {\n                this.value = obj.value;\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicHeadInputComponent.prototype = new scope.AbstractMusicInputComponent();\n\n    /**\n     * Constructor property\n     */\n    MusicHeadInputComponent.prototype.constructor = MusicHeadInputComponent;\n\n    /**\n     * Get head input component value\n     *\n     * @method getValue\n     * @returns {String}\n     */\n    MusicHeadInputComponent.prototype.getValue = function () {\n        return this.value;\n    };\n\n    /**\n     * Set head input component value\n     *\n     * @method setValue\n     * @param {String} value\n     */\n    MusicHeadInputComponent.prototype.setValue = function (value) {\n        this.value = value;\n    };\n\n    // Export\n    scope.MusicHeadInputComponent = MusicHeadInputComponent;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * Ledger line input component\n     *\n     * @class MusicLedgerLineInputComponent\n     * @extends AbstractMusicInputComponent\n     * @constructor\n     */\n    function MusicLedgerLineInputComponent(obj) {\n        scope.AbstractMusicInputComponent.call(this, obj);\n        this.type = 'ledgerLine';\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicLedgerLineInputComponent.prototype = new scope.AbstractMusicInputComponent();\n\n    /**\n     * Constructor property\n     */\n    MusicLedgerLineInputComponent.prototype.constructor = MusicLedgerLineInputComponent;\n\n    // Export\n    scope.MusicLedgerLineInputComponent = MusicLedgerLineInputComponent;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * Rest input component\n     *\n     * @class MusicRestInputComponent\n     * @extends AbstractMusicInputComponent\n     * @constructor\n     */\n    function MusicRestInputComponent(obj) {\n        scope.AbstractMusicInputComponent.call(this, obj);\n        this.type = 'rest';\n        if (obj) {\n            if (obj.value) {\n                this.value = obj.value;\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicRestInputComponent.prototype = new scope.AbstractMusicInputComponent();\n\n    /**\n     * Constructor property\n     */\n    MusicRestInputComponent.prototype.constructor = MusicRestInputComponent;\n\n    /**\n     * Get rest input component value\n     *\n     * @method getValue\n     * @returns {String}\n     */\n    MusicRestInputComponent.prototype.getValue = function () {\n        return this.value;\n    };\n\n    /**\n     * Set rest input component value\n     *\n     * @method setValue\n     * @param {String} value\n     */\n    MusicRestInputComponent.prototype.setValue = function (value) {\n        this.value = value;\n    };\n\n    // Export\n    scope.MusicRestInputComponent = MusicRestInputComponent;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * Stem input component\n     *\n     * @class MusicStemInputComponent\n     * @extends AbstractMusicInputComponent\n     * @constructor\n     */\n    function MusicStemInputComponent(obj) {\n        scope.AbstractMusicInputComponent.call(this, obj);\n        this.type = 'stem';\n        if (obj) {\n            if (obj.value) {\n                this.value = obj.value;\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicStemInputComponent.prototype = new scope.AbstractMusicInputComponent();\n\n    /**\n     * Constructor property\n     */\n    MusicStemInputComponent.prototype.constructor = MusicStemInputComponent;\n\n    /**\n     * Get stem input component value\n     *\n     * @method getValue\n     * @returns {String}\n     */\n    MusicStemInputComponent.prototype.getValue = function () {\n        return this.value;\n    };\n\n    /**\n     * Set stem input component value\n     *\n     * @method setValue\n     * @param {String} value\n     */\n    MusicStemInputComponent.prototype.setValue = function (value) {\n        this.value = value;\n    };\n\n    // Export\n    scope.MusicStemInputComponent = MusicStemInputComponent;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * Tie ro slur input component\n     *\n     * @class MusicTieOrSlurInputComponent\n     * @extends AbstractMusicInputComponent\n     * @constructor\n     */\n    function MusicTieOrSlurInputComponent(obj) {\n        scope.AbstractMusicInputComponent.call(this, obj);\n        this.type = 'tieOrSlur';\n        if (obj) {\n            if (obj.value) {\n                this.value = obj.value;\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicTieOrSlurInputComponent.prototype = new scope.AbstractMusicInputComponent();\n\n    /**\n     * Constructor property\n     */\n    MusicTieOrSlurInputComponent.prototype.constructor = MusicTieOrSlurInputComponent;\n\n    /**\n     * Get tie or slur input component value\n     *\n     * @method getValue\n     * @returns {String}\n     */\n    MusicTieOrSlurInputComponent.prototype.getValue = function () {\n        return this.value;\n    };\n\n    /**\n     * Set tie or slur input component value\n     *\n     * @method setValue\n     * @param {String} value\n     */\n    MusicTieOrSlurInputComponent.prototype.setValue = function (value) {\n        this.value = value;\n    };\n\n    // Export\n    scope.MusicTieOrSlurInputComponent = MusicTieOrSlurInputComponent;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * Time signature input component\n     *\n     * @class MusicTimeSignatureInputComponent\n     * @extends AbstractMusicInputComponent\n     * @constructor\n     */\n    function MusicTimeSignatureInputComponent(obj) {\n        scope.AbstractMusicInputComponent.call(this, obj);\n        this.type = 'timeSignature';\n        if (obj) {\n            if (obj.value) {\n                this.value = obj.value;\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicTimeSignatureInputComponent.prototype = new scope.AbstractMusicInputComponent();\n\n    /**\n     * Constructor property\n     */\n    MusicTimeSignatureInputComponent.prototype.constructor = MusicTimeSignatureInputComponent;\n\n    /**\n     * Get time signature input component value\n     *\n     * @method getValue\n     * @returns {String}\n     */\n    MusicTimeSignatureInputComponent.prototype.getValue = function () {\n        return this.value;\n    };\n\n    /**\n     * Set time signature input component value\n     *\n     * @method setValue\n     * @param {String} value\n     */\n    MusicTimeSignatureInputComponent.prototype.setValue = function (value) {\n        this.value = value;\n    };\n\n    // Export\n    scope.MusicTimeSignatureInputComponent = MusicTimeSignatureInputComponent;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * Represents a staff used for music recognition\n     * default values: count=5, gap=20\n     *\n     * @class MusicStaff\n     * @constructor\n     */\n    function MusicStaff(obj) {\n        this.count = 5;\n        this.gap = 20;\n        if (obj) {\n            if (obj.count) {\n                this.count = obj.count;\n            }\n            if (obj.gap) {\n                this.gap = obj.gap;\n            }\n            if (obj.top) {\n                this.top = obj.top;\n            }\n        }\n    }\n\n    /**\n     * Get the lines count\n     *\n     * @method getCount\n     * @returns {Number}\n     */\n    MusicStaff.prototype.getCount = function () {\n        return this.count;\n    };\n\n    /**\n     * Set the lines count\n     *\n     * @method setCount\n     * @param {Number} count\n     */\n    MusicStaff.prototype.setCount = function (count) {\n        this.count = count;\n    };\n\n    /**\n     * Get the spacing from the top\n     *\n     * @method getTop\n     * @returns {Number}\n     */\n    MusicStaff.prototype.getTop = function () {\n        return this.top;\n    };\n\n    /**\n     * Set the spacing from the top\n     *\n     * @method setTop\n     * @param {Number} top\n     */\n    MusicStaff.prototype.setTop = function (top) {\n        this.top = top;\n    };\n\n    /**\n     * Get the gap between lines\n     *\n     * @method getGap\n     * @returns {Number}\n     */\n    MusicStaff.prototype.getGap = function () {\n        return this.gap;\n    };\n\n    /**\n     * Set the gap between lines\n     *\n     * @method setGap\n     * @param {Number} gap\n     */\n    MusicStaff.prototype.setGap = function (gap) {\n        this.gap = gap;\n    };\n\n    // Export\n    scope.MusicStaff = MusicStaff;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * Parameters used for music recognition\n     *\n     * @class MusicParameter\n     * @extends AbstractParameter\n     * @constructor\n     */\n    function MusicParameter(obj) {\n        scope.AbstractParameter.call(this, obj);\n        this.resultTypes = [];\n        this.userResources = [];\n        if (obj) {\n            if (obj.divisions) {\n                this.divisions = obj.divisions;\n            }\n            if (obj.staff) {\n                this.staff = new scope.MusicStaff(obj.staff);\n            }\n            if (obj.scratchOutDetectionSensitivity) {\n                this.scratchOutDetectionSensitivity = obj.scratchOutDetectionSensitivity;\n            }\n            if (obj.userResources) {\n                this.userResources = obj.userResources;\n            }\n            if (obj.resultTypes) {\n                this.resultTypes = obj.resultTypes;\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicParameter.prototype = new scope.AbstractParameter();\n\n    /**\n     * Constructor property\n     */\n    MusicParameter.prototype.constructor = MusicParameter;\n\n    /**\n     * Get the music result types (e.g. MusicXML, ScoreTree)\n     *\n     * @method getResultTypes\n     * @returns {Array}\n     */\n    MusicParameter.prototype.getResultTypes = function () {\n        return this.resultTypes;\n    };\n\n    /**\n     * Set the music result types (e.g. MusicXML, ScoreTree)\n     *\n     * @method setResultTypes\n     * @param {Array} resultTypes\n     */\n    MusicParameter.prototype.setResultTypes = function (resultTypes) {\n        this.resultTypes = resultTypes;\n    };\n\n    /**\n     * Get the user resources\n     *\n     * @method getUserResources\n     * @returns {Array}\n     */\n    MusicParameter.prototype.getUserResources = function () {\n        return this.userResources;\n    };\n\n    /**\n     * Set the user resources\n     *\n     * @method setUserResources\n     * @param {Array} userResources\n     */\n    MusicParameter.prototype.setUserResources = function (userResources) {\n        this.userResources = userResources;\n    };\n\n    /**\n     * Get the sensitivity of the scratch-out detection\n     *\n     * @method getScratchOutDetectionSensitivity\n     * @returns {Number}\n     */\n    MusicParameter.prototype.getScratchOutDetectionSensitivity = function () {\n        return this.scratchOutDetectionSensitivity;\n    };\n\n    /**\n     * Set the sensitivity of the scratch-out detection\n     *\n     * @method setScratchOutDetectionSensitivity\n     * @param {Number} scratchOutDetectionSensitivity\n     */\n    MusicParameter.prototype.setScratchOutDetectionSensitivity = function (scratchOutDetectionSensitivity) {\n        this.scratchOutDetectionSensitivity = scratchOutDetectionSensitivity;\n    };\n\n    /**\n     * Get the staff\n     *\n     * @method getStaff\n     * @returns {MusicStaff}\n     */\n    MusicParameter.prototype.getStaff = function () {\n        return this.staff;\n    };\n\n    /**\n     * Set the staff\n     *\n     * @method setStaff\n     * @param {MusicStaff} staff\n     */\n    MusicParameter.prototype.setStaff = function (staff) {\n        this.staff = staff;\n    };\n\n    /**\n     * Get the number of divisions\n     *\n     * @method getDivisions\n     * @returns {Number}\n     */\n    MusicParameter.prototype.getDivisions = function () {\n        return this.divisions;\n    };\n\n    /**\n     * Set the number of divisions\n     *\n     * @method setDivisions\n     * @param {Number} divisions\n     */\n    MusicParameter.prototype.setDivisions = function (divisions) {\n        this.divisions = divisions;\n    };\n\n    // Export\n    scope.MusicParameter = MusicParameter;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * Recognition input object for music recognition\n     *\n     * @class MusicRecognitionInput\n     * @extends AbstractRecognitionInput\n     * @constructor\n     */\n    function MusicRecognitionInput() {\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicRecognitionInput.prototype = new scope.AbstractRecognitionInput();\n\n    /**\n     * Constructor property\n     */\n    MusicRecognitionInput.prototype.constructor = MusicRecognitionInput;\n\n    /**\n     * Get parameters\n     *\n     * @method getParameters\n     * @returns {MusicParameter}\n     */\n    MusicRecognitionInput.prototype.getParameters = function () {\n        return new MusicParameter({\n            divisions: this.divisions,\n            staff: this.staff,\n            scratchOutDetectionSensitivity: this.scratchOutDetectionSensitivity,\n            resultTypes: this.resultTypes,\n            userResources: this.userResources\n        });\n    };\n\n    /**\n     * Set parameters\n     *\n     * @method setParameters\n     * @param {MusicParameter} parameters\n     */\n    MusicRecognitionInput.prototype.setParameters = function (parameters) {\n        if (parameters) {\n            this.divisions = parameters.getDivisions();\n            this.staff = parameters.getStaff();\n            this.scratchOutDetectionSensitivity = parameters.getScratchOutDetectionSensitivity();\n            this.resultTypes = parameters.getResultTypes();\n            this.userResources = parameters.getUserResources();\n        }\n    };\n\n    /**\n     * Get input components\n     *\n     * @method getComponents\n     * @returns {AbstractComponent[]}\n     */\n    MusicRecognitionInput.prototype.getComponents = function () {\n        return this.components;\n    };\n\n    /**\n     * Set input components\n     *\n     * @method setComponents\n     * @param {AbstractComponent[]} components\n     */\n    MusicRecognitionInput.prototype.setComponents = function (components) {\n        this.components = components;\n    };\n\n    // Export\n    scope.MusicRecognitionInput = MusicRecognitionInput;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * Recognition data for music input\n     *\n     * @class MusicRecognitionData\n     * @extends AbstractRecognitionData\n     * @constructor\n     */\n    function MusicRecognitionData() {\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicRecognitionData.prototype = new scope.AbstractRecognitionData();\n\n    /**\n     * Constructor property\n     */\n    MusicRecognitionData.prototype.constructor = MusicRecognitionData;\n\n    /**\n     * Get music input\n     *\n     * @method getRecognitionInput\n     * @returns {MusicRecognitionInput}\n     */\n    MusicRecognitionData.prototype.getRecognitionInput = function () {\n        return this.musicInput;\n    };\n\n    /**\n     * Set music input\n     *\n     * @method setRecognitionInput\n     * @param {MusicRecognitionInput} input\n     */\n    MusicRecognitionData.prototype.setRecognitionInput = function (input) {\n        this.musicInput = JSON.stringify(input);\n    };\n\n    // Export\n    scope.MusicRecognitionData = MusicRecognitionData;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * Parameters used for analyzer recognition\n     *\n     * @class AnalyzerParameter\n     * @extends AbstractParameter\n     * @constructor\n     */\n    function AnalyzerParameter(obj) {\n        scope.AbstractParameter.call(this, obj);\n        this.textParameter = new scope.TextParameter();\n        this.textParameter.setLanguage('en_US');\n        this.textParameter.setInputMode('CURSIVE');\n        if (obj) {\n            if (obj.coordinateResolution) {\n                this.coordinateResolution = obj.coordinateResolution;\n            }\n            if (obj.textParameter) {\n                this.textParameter = new scope.TextParameter(obj.textParameter);\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    AnalyzerParameter.prototype = new scope.AbstractParameter();\n\n    /**\n     * Constructor property\n     */\n    AnalyzerParameter.prototype.constructor = AnalyzerParameter;\n\n    /**\n     * Get text recognition parameters\n     *\n     * @method getTextParameters\n     * @returns {TextParameter}\n     */\n    AnalyzerParameter.prototype.getTextParameters = function () {\n        return this.textParameter;\n    };\n\n    /**\n     * Set text recognition parameters\n     *\n     * @method setTextParameters\n     * @param {TextParameter} parameters\n     */\n    AnalyzerParameter.prototype.setTextParameters = function (parameters) {\n        this.textParameter = parameters;\n    };\n\n    /**\n     * Get analyzer coordinate resolution\n     *\n     * @method getCoordinateResolution\n     * @returns {Number}\n     */\n    AnalyzerParameter.prototype.getCoordinateResolution = function () {\n        return this.coordinateResolution;\n    };\n\n    /**\n     * Set analyzer coordinate resolution\n     *\n     * @method setCoordinateResolution\n     * @param {Number} coordinateResolution\n     */\n    AnalyzerParameter.prototype.setCoordinateResolution = function (coordinateResolution) {\n        this.coordinateResolution = coordinateResolution;\n    };\n\n    // Export\n    scope.AnalyzerParameter = AnalyzerParameter;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * Recognition input object for analyzer recognition\n     *\n     * @class AnalyzerRecognitionInput\n     * @extends AbstractRecognitionInput\n     * @constructor\n     */\n    function AnalyzerRecognitionInput() {\n\n    }\n\n    /**\n     * Inheritance property\n     */\n    AnalyzerRecognitionInput.prototype = new scope.AbstractRecognitionInput();\n\n    /**\n     * Constructor property\n     */\n    AnalyzerRecognitionInput.prototype.constructor = AnalyzerRecognitionInput;\n\n    /**\n     * Get analyzer recognition parameters\n     *\n     * @method getParameters\n     * @returns {AnalyzerParameter}\n     */\n    AnalyzerRecognitionInput.prototype.getParameters = function () {\n        return this.parameter;\n    };\n\n    /**\n     * Set analyzer recognition parameters\n     *\n     * @method setParameters\n     * @param {AnalyzerParameter} parameters\n     */\n    AnalyzerRecognitionInput.prototype.setParameters = function (parameters) {\n        this.parameter = parameters;\n    };\n\n    /**\n     * Get input components\n     *\n     * @method getComponents\n     * @returns {AbstractComponent[]}\n     */\n    AnalyzerRecognitionInput.prototype.getComponents = function () {\n        return this.components;\n    };\n\n    /**\n     * Set input components\n     *\n     * @method setComponents\n     * @param {AbstractComponent[]} components\n     */\n    AnalyzerRecognitionInput.prototype.setComponents = function (components) {\n        this.components = components;\n    };\n\n    // Export\n    scope.AnalyzerRecognitionInput = AnalyzerRecognitionInput;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Recognition data for analyzer input\n     *\n     * @class AnalyzerRecognitionData\n     * @extends AbstractRecognitionData\n     * @constructor\n     */\n    function AnalyzerRecognitionData() {\n    }\n\n    /**\n     * Inheritance property\n     */\n    AnalyzerRecognitionData.prototype = new scope.AbstractRecognitionData();\n\n    /**\n     * Constructor property\n     */\n    AnalyzerRecognitionData.prototype.constructor = AnalyzerRecognitionData;\n\n    /**\n     * Get analyzer input\n     *\n     * @method getRecognitionInput\n     * @returns {AnalyzerRecognitionInput}\n     */\n    AnalyzerRecognitionData.prototype.getRecognitionInput = function () {\n        return this.analyzerInput;\n    };\n\n    /**\n     * Set analyzer input\n     *\n     * @method setRecognitionInput\n     * @param {AnalyzerRecognitionInput} input\n     */\n    AnalyzerRecognitionData.prototype.setRecognitionInput = function (input) {\n        this.analyzerInput = JSON.stringify(input);\n    };\n\n    // Export\n    scope.AnalyzerRecognitionData = AnalyzerRecognitionData;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * Abstract result\n     *\n     * @class AbstractResult\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function AbstractResult(obj) {\n        if (obj) {\n            this.instanceId = obj.instanceId;\n        }\n    }\n\n    /**\n     * Get instance id\n     *\n     * @method getInstanceId\n     * @returns {String}\n     */\n    AbstractResult.prototype.getInstanceId = function () {\n        return this.instanceId;\n    };\n\n    /**\n     * Get document\n     *\n     * @method getDocument\n     * @returns {TextDocument|ShapeDocument|MathDocument|MusicDocument|AnalyzerDocument}\n     */\n    AbstractResult.prototype.getDocument = function () {\n        return this.result;\n    };\n\n    // Export\n    scope.AbstractResult = AbstractResult;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * WebSocket recognition text result message\n     *\n     * @class AbstractRecoResponseWSMessage\n     * @extends AbstractWSMessage\n     * @param {Object} [obj] Recognition WebSocket message\n     * @constructor\n     */\n    function AbstractRecoResponseWSMessage(obj) {\n        scope.AbstractWSMessage.call(this, obj);\n        if (obj) {\n            this.instanceId = obj.instanceId;\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    AbstractRecoResponseWSMessage.prototype = new scope.AbstractWSMessage();\n\n    /**\n     * Constructor property\n     */\n    AbstractRecoResponseWSMessage.prototype.constructor = AbstractRecoResponseWSMessage;\n\n    /**\n     * Get instance id\n     *\n     * @method getInstanceId\n     * @returns {String}\n     */\n    AbstractRecoResponseWSMessage.prototype.getInstanceId = function () {\n        return this.instanceId;\n    };\n\n    /**\n     * Get document\n     *\n     * @method getDocument\n     * @returns {TextDocument|ShapeDocument|MathDocument|MusicDocument|AnalyzerDocument}\n     */\n    AbstractRecoResponseWSMessage.prototype.getDocument = function () {\n        return this.result;\n    };\n\n    // Export\n    scope.AbstractRecoResponseWSMessage = AbstractRecoResponseWSMessage;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * WebSocket recognition hmac challenge message\n     *\n     * @class ChallengeResponseWSMessage\n     * @extends AbstractWSMessage\n     * @param {Object} [obj] Recognition WebSocket message\n     * @constructor\n     */\n    function ChallengeResponseWSMessage(obj) {\n        scope.AbstractWSMessage.call(this, obj);\n        if (obj) {\n            this.challenge = obj.challenge;\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    ChallengeResponseWSMessage.prototype = new scope.AbstractWSMessage();\n\n    /**\n     * Constructor property\n     */\n    ChallengeResponseWSMessage.prototype.constructor = ChallengeResponseWSMessage;\n\n    /**\n     * Get the challenge\n     *\n     * @method getChallenge\n     * @returns {String}\n     */\n    ChallengeResponseWSMessage.prototype.getChallenge = function () {\n        return this.challenge;\n    };\n\n    // Export\n    scope.ChallengeResponseWSMessage = ChallengeResponseWSMessage;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * WebSocket recognition error message\n     *\n     * @class ErrorResponseWSMessage\n     * @extends AbstractWSMessage\n     * @param {Object} [obj] Recognition WebSocket message\n     * @constructor\n     */\n    function ErrorResponseWSMessage(obj) {\n        scope.AbstractWSMessage.call(this, obj);\n        if (obj) {\n            this.error = obj.error;\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    ErrorResponseWSMessage.prototype = new scope.AbstractWSMessage();\n\n    /**\n     * Constructor property\n     */\n    ErrorResponseWSMessage.prototype.constructor = ErrorResponseWSMessage;\n\n    /**\n     * Get the error\n     *\n     * @method getError\n     * @returns {String}\n     */\n    ErrorResponseWSMessage.prototype.getError = function () {\n        return this.error;\n    };\n\n    // Export\n    scope.ErrorResponseWSMessage = ErrorResponseWSMessage;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * WebSocket recognition init message\n     *\n     * @class InitResponseWSMessage\n     * @extends AbstractWSMessage\n     * @param {Object} [obj] Recognition WebSocket message\n     * @constructor\n     */\n    function InitResponseWSMessage(obj) {\n        scope.AbstractWSMessage.call(this, obj);\n    }\n\n    /**\n     * Inheritance property\n     */\n    InitResponseWSMessage.prototype = new scope.AbstractWSMessage();\n\n    /**\n     * Constructor property\n     */\n    InitResponseWSMessage.prototype.constructor = InitResponseWSMessage;\n\n    // Export\n    scope.InitResponseWSMessage = InitResponseWSMessage;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * WebSocket recognition reset message\n     *\n     * @class ResetResponseWSMessage\n     * @extends AbstractWSMessage\n     * @param {Object} [obj] Recognition WebSocket message\n     * @constructor\n     */\n    function ResetResponseWSMessage(obj) {\n        scope.AbstractWSMessage.call(this, obj);\n    }\n\n    /**\n     * Inheritance property\n     */\n    ResetResponseWSMessage.prototype = new scope.AbstractWSMessage();\n\n    /**\n     * Constructor property\n     */\n    ResetResponseWSMessage.prototype.constructor = ResetResponseWSMessage;\n\n    // Export\n    scope.ResetResponseWSMessage = ResetResponseWSMessage;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Text ink ranges\n     *\n     * @class TextInkRange\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function TextInkRange(obj) {\n        if (obj) {\n            if (typeof obj === 'string') {\n                var cpt = obj.split(/[:-]+/);\n                this.startUnit = Number(cpt[0]);\n                this.startComponent = Number(cpt[1]);\n                this.startPoint = Number(cpt[2]);\n                this.endUnit = Number(cpt[3]);\n                this.endComponent = Number(cpt[4]);\n                this.endPoint = Number(cpt[5]);\n            } else {\n                this.startUnit = obj.startUnit;\n                this.startComponent = obj.startComponent;\n                this.startPoint = obj.startPoint;\n                this.endUnit = obj.endUnit;\n                this.endComponent = obj.endComponent;\n                this.endPoint = obj.endPoint;\n            }\n        }\n    }\n\n    /**\n     * Get start unit\n     *\n     * @method getStartUnit\n     * @returns {Number}\n     */\n    TextInkRange.prototype.getStartUnit = function () {\n        return this.startUnit;\n    };\n\n    /**\n     * Get end unit\n     *\n     * @method getEndUnit\n     * @returns {Number}\n     */\n    TextInkRange.prototype.getEndUnit = function () {\n        return this.endUnit;\n    };\n\n    /**\n     * Get start component\n     *\n     * @method getStartComponent\n     * @returns {Number}\n     */\n    TextInkRange.prototype.getStartComponent = function () {\n        return this.startComponent;\n    };\n\n    /**\n     * Get end component\n     *\n     * @method getEndComponent\n     * @returns {Number}\n     */\n    TextInkRange.prototype.getEndComponent = function () {\n        return this.endComponent;\n    };\n\n    /**\n     * Get start point\n     *\n     * @method getStartPoint\n     * @returns {Number}\n     */\n    TextInkRange.prototype.getStartPoint = function () {\n        return this.startPoint;\n    };\n\n    /**\n     * Get end point\n     *\n     * @method getEndPoint\n     * @returns {Number}\n     */\n    TextInkRange.prototype.getEndPoint = function () {\n        return this.endPoint;\n    };\n\n    // Export\n    scope.TextInkRange = TextInkRange;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * Text candidate\n     *\n     * @class TextCandidate\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function TextCandidate(obj) {\n        this.flags = [];\n        this.children = [];\n        if (obj) {\n            this.label = obj.label;\n            this.normalizedScore = obj.normalizedScore;\n            this.spellingDistortionRatio = obj.spellingDistortionRatio;\n            for (var i in obj.flags) {\n                this.flags.push(obj.flags[i]);\n            }\n            for (var j in obj.children) {\n                this.children.push(new scope.TextSegment(obj.children[j]));\n            }\n        }\n    }\n\n    /**\n     * Get label\n     *\n     * @method getLabel\n     * @returns {String}\n     */\n    TextCandidate.prototype.getLabel = function () {\n        return this.label;\n    };\n\n    /**\n     * Get normalized score\n     *\n     * @method getNormalizedScore\n     * @returns {Number}\n     */\n    TextCandidate.prototype.getNormalizedScore = function () {\n        return this.normalizedScore;\n    };\n\n    /**\n     * Get resemblance score\n     *\n     * @method getResemblanceScore\n     * @returns {Number}\n     */\n    TextCandidate.prototype.getResemblanceScore = function () {\n        return this.resemblanceScore;\n    };\n\n    /**\n     * Get spelling distortion ratio\n     *\n     * @method getSpellingDistortionRatio\n     * @returns {Number}\n     */\n    TextCandidate.prototype.getSpellingDistortionRatio = function () {\n        return this.spellingDistortionRatio;\n    };\n\n    /**\n     * Get flags\n     *\n     * @method getFlags\n     * @returns {Array}\n     */\n    TextCandidate.prototype.getFlags = function () {\n        return this.flags;\n    };\n\n    /**\n     * Get children\n     *\n     * @method getChildren\n     * @returns {TextSegment[]}\n     */\n    TextCandidate.prototype.getChildren = function () {\n        return this.children;\n    };\n\n    // Export\n    scope.TextCandidate = TextCandidate;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Text document\n     *\n     * @class TextDocument\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function TextDocument(obj) {\n        this.tagItems = [];\n        this.wordSegments = [];\n        this.charSegments = [];\n        if (obj) {\n            if (obj.textSegmentResult) {\n                this.textSegmentResult = new scope.TextSegment(obj.textSegmentResult);\n            }\n            for (var i in obj.tagItems) {\n                this.tagItems.push(new scope.TextTagItem(obj.tagItems[i]));\n            }\n            for (var j in obj.wordSegments) {\n                this.wordSegments.push(new scope.TextSegment(obj.wordSegments[j]));\n            }\n            for (var k in obj.charSegments) {\n                this.charSegments.push(new scope.TextSegment(obj.charSegments[k]));\n            }\n            /**\n             * @deprecated\n             */\n            for (var l in obj.wordCandidates) {\n                this.wordSegments.push(new scope.TextSegment(obj.wordCandidates[l]));\n            }\n            /**\n             * @deprecated\n             */\n            for (var m in obj.charCandidates) {\n                this.charSegments.push(new scope.TextSegment(obj.charCandidates[m]));\n            }\n        }\n    }\n\n    /**\n     * Get tag items\n     *\n     * @method getTagItems\n     * @returns {TextTagItem[]}\n     */\n    TextDocument.prototype.getTagItems = function () {\n        return this.tagItems;\n    };\n\n    /**\n     * Get word segments\n     *\n     * @method getWordSegments\n     * @returns {TextSegment[]}\n     */\n    TextDocument.prototype.getWordSegments = function () {\n        return this.wordSegments;\n    };\n\n    /**\n     * Get word segment\n     *\n     * @method getWordSegment\n     * @param {TextInkRange[]} inkRanges\n     * @returns {TextSegment}\n     */\n    TextDocument.prototype.getWordSegment = function (inkRanges) {\n        for (var i = 0; i < this.getWordSegments().length; i++) {\n            if (JSON.stringify(this.getWordSegments()[i].getInkRanges()) === JSON.stringify(inkRanges)) {\n                return this.getWordSegments()[i];\n            }\n        }\n        return undefined;\n    };\n\n    /**\n     * Get char segments\n     *\n     * @method getCharSegments\n     * @returns {TextSegment[]}\n     */\n    TextDocument.prototype.getCharSegments = function () {\n        return this.charSegments;\n    };\n\n    /**\n     * Get char segment\n     *\n     * @method getCharSegment\n     * @param {TextInkRange[]} inkRanges\n     * @returns {TextSegment}\n     */\n    TextDocument.prototype.getCharSegment = function (inkRanges) {\n        for (var i = 0; i < this.getCharSegments().length; i++) {\n            if (JSON.stringify(this.getCharSegments()[i].getInkRanges()) === JSON.stringify(inkRanges)) {\n                return this.getCharSegments()[i];\n            }\n        }\n        return undefined;\n    };\n\n    /**\n     * Get text segment\n     *\n     * @method getTextSegment\n     * @returns {TextSegment}\n     */\n    TextDocument.prototype.getTextSegment = function () {\n        return this.textSegmentResult;\n    };\n\n    /**\n     * Has scratch-out results\n     *\n     * @method hasScratchOutResults\n     * @returns {Boolean}\n     */\n    TextDocument.prototype.hasScratchOutResults = function () {\n        return false;\n    };\n\n    // Export\n    scope.TextDocument = TextDocument;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * Text result\n     *\n     * @class TextResult\n     * @extends AbstractResult\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function TextResult(obj) {\n        scope.AbstractResult.call(this, obj);\n        if (obj) {\n            this.result = new scope.TextDocument(obj.result);\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    TextResult.prototype = new scope.AbstractResult();\n\n    /**\n     * Constructor property\n     */\n    TextResult.prototype.constructor = TextResult;\n\n    // Export\n    scope.TextResult = TextResult;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * Text segment\n     *\n     * @class TextSegment\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function TextSegment(obj) {\n        this.candidates = [];\n        this.inkRanges = [];\n        if (obj) {\n            this.selectedCandidateIdx = obj.selectedCandidateIdx;\n            if (obj.inkRanges) {\n                var ranges = obj.inkRanges;\n                if (!Array.isArray(ranges)) {\n                    ranges = ranges.split(/[\\s]+/);\n                }\n                for (var j in ranges) {\n                    this.inkRanges.push(new scope.TextInkRange(ranges[j]));\n                }\n            }\n            for (var i in obj.candidates) {\n                this.candidates.push(new scope.TextCandidate(obj.candidates[i]));\n            }\n        }\n    }\n\n    /**\n     * Get candidates\n     *\n     * @method getCandidates\n     * @returns {TextCandidate[]}\n     */\n    TextSegment.prototype.getCandidates = function () {\n        return this.candidates;\n    };\n\n    /**\n     * Get selected candidate index\n     *\n     * @method getSelectedCandidateIdx\n     * @returns {Number}\n     */\n    TextSegment.prototype.getSelectedCandidateIdx = function () {\n        return this.selectedCandidateIdx;\n    };\n\n    /**\n     * Get selected candidate\n     *\n     * @method getSelectedCandidate\n     * @returns {TextCandidate}\n     */\n    TextSegment.prototype.getSelectedCandidate = function () {\n        if ((this.getCandidates().length > 0) && (this.getSelectedCandidateIdx() !== undefined)) {\n            return this.getCandidates()[this.getSelectedCandidateIdx()];\n        } else {\n            return undefined;\n        }\n    };\n\n    /**\n     * Get ink ranges\n     *\n     * @method getInkRanges\n     * @returns {TextInkRange[]}\n     */\n    TextSegment.prototype.getInkRanges = function () {\n        return this.inkRanges;\n    };\n\n    // Export\n    scope.TextSegment = TextSegment;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * Text tag item\n     *\n     * @class TextTagItem\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function TextTagItem(obj) {\n        this.inkRanges = [];\n        if (obj) {\n            this.tagType = obj.tagType;\n            if (obj.inkRanges) {\n                var ranges = obj.inkRanges;\n                if (!Array.isArray(ranges)) {\n                    ranges = ranges.split(/[\\s]+/);\n                }\n                for (var i in ranges) {\n                    this.inkRanges.push(new scope.TextInkRange(ranges[i]));\n                }\n            }\n        }\n    }\n\n    /**\n     * Get tag type\n     *\n     * @method getTagType\n     * @returns {String}\n     */\n    TextTagItem.prototype.getTagType = function () {\n        return this.tagType;\n    };\n\n    /**\n     * Get ink ranges\n     *\n     * @method getInkRanges\n     * @returns {TextInkRange[]}\n     */\n    TextTagItem.prototype.getInkRanges = function () {\n        return this.inkRanges;\n    };\n\n    // Export\n    scope.TextTagItem = TextTagItem;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * WebSocket recognition text result message\n     *\n     * @class TextResponseWSMessage\n     * @extends AbstractRecoResponseWSMessage\n     * @param {Object} [obj] Recognition WebSocket message\n     * @constructor\n     */\n    function TextResponseWSMessage(obj) {\n        scope.AbstractRecoResponseWSMessage.call(this, obj);\n        if (obj) {\n            this.result = new scope.TextDocument(obj.result);\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    TextResponseWSMessage.prototype = new scope.AbstractRecoResponseWSMessage();\n\n    /**\n     * Constructor property\n     */\n    TextResponseWSMessage.prototype.constructor = TextResponseWSMessage;\n\n    // Export\n    scope.TextResponseWSMessage = TextResponseWSMessage;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * Abstract shape primitive\n     *\n     * @class AbstractShapePrimitive\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function AbstractShapePrimitive(obj) {\n        if (obj) {\n            this.type = obj.type;\n            this.beginDecoration = obj.beginDecoration;\n            this.beginTangentAngle = obj.beginTangentAngle;\n            this.endDecoration = obj.endDecoration;\n            this.endTangentAngle = obj.endTangentAngle;\n        }\n    }\n\n    /**\n     * Get type\n     *\n     * @method getType\n     * @returns {String}\n     */\n    AbstractShapePrimitive.prototype.getType = function () {\n        return this.type;\n    };\n\n    /**\n     * Is line\n     *\n     * @method isLine\n     * @returns {Boolean}\n     */\n    AbstractShapePrimitive.prototype.isLine = function () {\n        return this.type === 'line';\n    };\n\n    /**\n     * Is ellipse\n     *\n     * @method isEllipse\n     * @returns {Boolean}\n     */\n    AbstractShapePrimitive.prototype.isEllipse = function () {\n        return this.type === 'ellipse';\n    };\n\n    /**\n     * Has begin decoration\n     *\n     * @method hasBeginDecoration\n     * @returns {Boolean}\n     */\n    AbstractShapePrimitive.prototype.hasBeginDecoration = function () {\n        return typeof this.beginDecoration !== 'undefined';\n    };\n\n    /**\n     * Has end decoration\n     *\n     * @method hasEndDecoration\n     * @returns {Boolean}\n     */\n    AbstractShapePrimitive.prototype.hasEndDecoration = function () {\n        return typeof this.endDecoration !== 'undefined';\n    };\n\n    /**\n     * Get begin decoration\n     *\n     * @method getBeginDecoration\n     * @returns {String}\n     */\n    AbstractShapePrimitive.prototype.getBeginDecoration = function () {\n        return this.beginDecoration;\n    };\n\n    /**\n     * Get end decoration\n     *\n     * @method getEndDecoration\n     * @returns {String}\n     */\n    AbstractShapePrimitive.prototype.getEndDecoration = function () {\n        return this.endDecoration;\n    };\n\n    /**\n     * Get begin tangent angle\n     *\n     * @method getBeginTangentAngle\n     * @returns {Number}\n     */\n    AbstractShapePrimitive.prototype.getBeginTangentAngle = function () {\n        return this.beginTangentAngle;\n    };\n\n    /**\n     * Get end tangent angle\n     *\n     * @method getEndTangentAngle\n     * @returns {Number}\n     */\n    AbstractShapePrimitive.prototype.getEndTangentAngle = function () {\n        return this.endTangentAngle;\n    };\n\n    // Export\n    scope.AbstractShapePrimitive = AbstractShapePrimitive;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Shape candidate\n     *\n     * @class ShapeCandidate\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function ShapeCandidate(obj) {\n        if (obj) {\n            this.type = obj.type;\n        }\n    }\n\n    /**\n     * Get type\n     *\n     * @method getType\n     * @returns {String}\n     */\n    ShapeCandidate.prototype.getType = function () {\n        return this.type;\n    };\n\n    /**\n     * Is erased\n     *\n     * @method isErased\n     * @returns {Boolean}\n     */\n    ShapeCandidate.prototype.isErased = function () {\n        return this.type === 'erased';\n    };\n\n    /**\n     * Is scratch-out\n     *\n     * @method isScratchOut\n     * @returns {Boolean}\n     */\n    ShapeCandidate.prototype.isScratchOut = function () {\n        return this.type === 'scratchOut';\n    };\n\n    /**\n     * Is not recognized\n     *\n     * @method isNotRecognized\n     * @returns {Boolean}\n     */\n    ShapeCandidate.prototype.isNotRecognized = function () {\n        return this.type === 'notRecognized';\n    };\n\n    /**\n     * Is recognized\n     *\n     * @method isRecognized\n     * @returns {Boolean}\n     */\n    ShapeCandidate.prototype.isRecognized = function () {\n        return this.type === 'recognizedShape';\n    };\n\n    // Export\n    scope.ShapeCandidate = ShapeCandidate;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Shape document\n     *\n     * @class ShapeDocument\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function ShapeDocument(obj) {\n        this.segments = [];\n        if (obj) {\n            for (var i in obj.segments) {\n                this.segments.push(new scope.ShapeSegment(obj.segments[i]));\n            }\n        }\n    }\n\n    /**\n     * Get segments\n     *\n     * @method getSegments\n     * @returns {ShapeSegment[]}\n     */\n    ShapeDocument.prototype.getSegments = function () {\n        return this.segments;\n    };\n\n    /**\n     * Get ink ranges\n     *\n     * @method getInkRanges\n     * @returns {ShapeInkRange[]}\n     */\n    ShapeDocument.prototype.getInkRanges = function () {\n        var inkRanges = [];\n        for (var i in this.segments) {\n            inkRanges = inkRanges.concat(this.segments[i].getInkRanges());\n        }\n        return inkRanges;\n    };\n\n    /**\n     * Has scratch-out results\n     *\n     * @method hasScratchOutResults\n     * @returns {Boolean}\n     */\n    ShapeDocument.prototype.hasScratchOutResults = function () {\n        for (var i in this.getSegments()) {\n            var currentSeg = this.getSegments()[i];\n            for (var j in currentSeg.getCandidates()) {\n                var currentCandidate = currentSeg.getCandidates()[j];\n                if (currentCandidate instanceof scope.ShapeScratchOut) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    };\n\n    // Export\n    scope.ShapeDocument = ShapeDocument;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * Shape ellipse\n     *\n     * @class ShapeEllipse\n     * @extends AbstractShapePrimitive\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function ShapeEllipse(obj) {\n        scope.AbstractShapePrimitive.call(this, obj);\n        if (obj) {\n            this.center = new scope.Point(obj.center);\n            this.minRadius = obj.minRadius;\n            this.maxRadius = obj.maxRadius;\n            this.orientation = obj.orientation;\n            this.startAngle = obj.startAngle;\n            this.sweepAngle = obj.sweepAngle;\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    ShapeEllipse.prototype = new scope.AbstractShapePrimitive();\n\n    /**\n     * Constructor property\n     */\n    ShapeEllipse.prototype.constructor = ShapeEllipse;\n\n    /**\n     * Get center\n     *\n     * @method getCenter\n     * @returns {Point}\n     */\n    ShapeEllipse.prototype.getCenter = function () {\n        return this.center;\n    };\n\n    /**\n     * Get min radius\n     *\n     * @method getMinRadius\n     * @returns {Number}\n     */\n    ShapeEllipse.prototype.getMinRadius = function () {\n        return this.minRadius;\n    };\n\n    /**\n     * Get max radius\n     *\n     * @method getMaxRadius\n     * @returns {Number}\n     */\n    ShapeEllipse.prototype.getMaxRadius = function () {\n        return this.maxRadius;\n    };\n\n    /**\n     * Get orientation\n     *\n     * @method getOrientation\n     * @returns {String}\n     */\n    ShapeEllipse.prototype.getOrientation = function () {\n        return this.orientation;\n    };\n\n    /**\n     * Get start angle\n     *\n     * @method getStartAngle\n     * @returns {Number}\n     */\n    ShapeEllipse.prototype.getStartAngle = function () {\n        return this.startAngle;\n    };\n\n    /**\n     * Get sweep angle\n     *\n     * @method getSweepAngle\n     * @returns {Number}\n     */\n    ShapeEllipse.prototype.getSweepAngle = function () {\n        return this.sweepAngle;\n    };\n\n    // Export\n    scope.ShapeEllipse = ShapeEllipse;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Shape erased\n     *\n     * @class ShapeErased\n     * @extends ShapeCandidate\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function ShapeErased(obj) {\n        scope.ShapeCandidate.call(this, obj);\n    }\n\n    /**\n     * Inheritance property\n     */\n    ShapeErased.prototype = new scope.ShapeCandidate();\n\n    /**\n     * Constructor property\n     */\n    ShapeErased.prototype.constructor = ShapeErased;\n\n    // Export\n    scope.ShapeErased = ShapeErased;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Shape ink range\n     *\n     * @class ShapeInkRange\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function ShapeInkRange(obj) {\n        if (obj) {\n            this.firstStroke = obj.firstStroke;\n            this.lastStroke = obj.lastStroke;\n            this.firstPoint = obj.firstPoint;\n            this.lastPoint = obj.lastPoint;\n        }\n    }\n\n    /**\n     * Get first stroke\n     *\n     * @method getFirstStroke\n     * @returns {Number}\n     */\n    ShapeInkRange.prototype.getFirstStroke = function () {\n        return this.firstStroke;\n    };\n\n    /**\n     * Get last stroke\n     *\n     * @method getLastStroke\n     * @returns {Number}\n     */\n    ShapeInkRange.prototype.getLastStroke = function () {\n        return this.lastStroke;\n    };\n\n    /**\n     * Get first point\n     *\n     * @method getFirstPoint\n     * @returns {Number}\n     */\n    ShapeInkRange.prototype.getFirstPoint = function () {\n        return this.firstPoint;\n    };\n\n    /**\n     * Get last point\n     *\n     * @method getLastPoint\n     * @returns {Number}\n     */\n    ShapeInkRange.prototype.getLastPoint = function () {\n        return this.lastPoint;\n    };\n\n    // Export\n    scope.ShapeInkRange = ShapeInkRange;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Shape line\n     *\n     * @class ShapeLine\n     * @extends AbstractShapePrimitive\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function ShapeLine(obj) {\n        scope.AbstractShapePrimitive.call(this, obj);\n        if (obj) {\n            this.firstPoint = new scope.Point(obj.firstPoint);\n            this.lastPoint = new scope.Point(obj.lastPoint);\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    ShapeLine.prototype = new scope.AbstractShapePrimitive();\n\n    /**\n     * Constructor property\n     */\n    ShapeLine.prototype.constructor = ShapeLine;\n\n    /**\n     * Get first point\n     *\n     * @method getFirstPoint\n     * @returns {Point}\n     */\n    ShapeLine.prototype.getFirstPoint = function () {\n        return this.firstPoint;\n    };\n\n    /**\n     * Get last point\n     *\n     * @method getLastPoint\n     * @returns {Point}\n     */\n    ShapeLine.prototype.getLastPoint = function () {\n        return this.lastPoint;\n    };\n\n    // Export\n    scope.ShapeLine = ShapeLine;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Shape not recognized\n     *\n     * @class ShapeNotRecognized\n     * @extends ShapeCandidate\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function ShapeNotRecognized(obj) {\n        scope.ShapeCandidate.call(this, obj);\n    }\n\n    /**\n     * Inheritance property\n     */\n    ShapeNotRecognized.prototype = new scope.ShapeCandidate();\n\n    /**\n     * Constructor property\n     */\n    ShapeNotRecognized.prototype.constructor = ShapeNotRecognized;\n\n    // Export\n    scope.ShapeNotRecognized = ShapeNotRecognized;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Shape recognized\n     *\n     * @class ShapeRecognized\n     * @extends ShapeCandidate\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function ShapeRecognized(obj) {\n        scope.ShapeCandidate.call(this, obj);\n        this.primitives = [];\n        if (obj) {\n            this.label = obj.label;\n            this.normalizedRecognitionScore = obj.normalizedRecognitionScore;\n            this.resemblanceScore = obj.resemblanceScore;\n            for (var i in obj.primitives) {\n                switch (obj.primitives[i].type) {\n                    case 'line':\n                        this.primitives.push(new scope.ShapeLine(obj.primitives[i]));\n                        break;\n                    case 'ellipse':\n                        this.primitives.push(new scope.ShapeEllipse(obj.primitives[i]));\n                        break;\n                    default:\n                        throw new Error('Unknown shape primitive');\n                }\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    ShapeRecognized.prototype = new scope.ShapeCandidate();\n\n    /**\n     * Constructor property\n     */\n    ShapeRecognized.prototype.constructor = ShapeRecognized;\n\n    /**\n     * Get primitives\n     *\n     * @method getPrimitives\n     * @returns {AbstractShapePrimitive[]}\n     */\n    ShapeRecognized.prototype.getPrimitives = function () {\n        return this.primitives;\n    };\n\n    /**\n     * Get label\n     *\n     * @method getLabel\n     * @returns {String}\n     */\n    ShapeRecognized.prototype.getLabel = function () {\n        return this.label;\n    };\n\n    /**\n     * Get normalized score\n     *\n     * @method getNormalizedRecognitionScore\n     * @returns {Number}\n     */\n    ShapeRecognized.prototype.getNormalizedRecognitionScore = function () {\n        return this.normalizedRecognitionScore;\n    };\n\n    /**\n     * Get resemblance score\n     *\n     * @method getResemblanceScore\n     * @returns {Number}\n     */\n    ShapeRecognized.prototype.getResemblanceScore = function () {\n        return this.resemblanceScore;\n    };\n\n    // Export\n    scope.ShapeRecognized = ShapeRecognized;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Shape result\n     *\n     * @class ShapeResult\n     * @extends AbstractResult\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function ShapeResult(obj) {\n        scope.AbstractResult.call(this, obj);\n        if (obj) {\n            this.result = new scope.ShapeDocument(obj.result);\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    ShapeResult.prototype = new scope.AbstractResult();\n\n    /**\n     * Constructor property\n     */\n    ShapeResult.prototype.constructor = ShapeResult;\n\n    // Export\n    scope.ShapeResult = ShapeResult;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * Shape scratch-out\n     *\n     * @class ShapeScratchOut\n     * @extends ShapeCandidate\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function ShapeScratchOut(obj) {\n        scope.ShapeCandidate.call(this, obj);\n        this.inkRanges = [];\n        if (obj) {\n            for (var j in obj.inkRanges) {\n                this.inkRanges.push(new scope.ShapeInkRange(obj.inkRanges[j]));\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    ShapeScratchOut.prototype = new scope.ShapeCandidate();\n\n    /**\n     * Constructor property\n     */\n    ShapeScratchOut.prototype.constructor = ShapeScratchOut;\n\n    /**\n     * Get ink ranges\n     *\n     * @method getInkRanges\n     * @returns {ShapeInkRange[]}\n     */\n    ShapeScratchOut.prototype.getInkRanges = function () {\n        return this.inkRanges;\n    };\n\n    // Export\n    scope.ShapeScratchOut = ShapeScratchOut;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Shape segment\n     *\n     * @class ShapeSegment\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function ShapeSegment(obj) {\n        this.inkRanges = [];\n        this.candidates = [];\n        if (obj) {\n            this.elementType = obj.elementType;\n            this.uniqueID = obj.uniqueID;\n            this.selectedCandidateIndex = obj.selectedCandidateIndex;\n            for (var i in obj.candidates) {\n                switch (obj.candidates[i].type) {\n                    case 'erased':\n                        this.candidates.push(new scope.ShapeErased(obj.candidates[i]));\n                        break;\n                    case 'scratchOut':\n                        this.candidates.push(new scope.ShapeScratchOut(obj.candidates[i]));\n                        break;\n                    case 'recognizedShape':\n                        this.candidates.push(new scope.ShapeRecognized(obj.candidates[i]));\n                        break;\n                    default:\n                        this.candidates.push(new scope.ShapeNotRecognized(obj.candidates[i]));\n                        break;\n                }\n            }\n            for (var j in obj.inkRanges) {\n                this.inkRanges.push(new scope.ShapeInkRange(obj.inkRanges[j]));\n            }\n        }\n    }\n\n    /**\n     * Get element type\n     *\n     * @method getElementType\n     * @returns {String}\n     */\n    ShapeSegment.prototype.getElementType = function () {\n        return this.elementType;\n    };\n\n    /**\n     * Get unique id\n     *\n     * @method getUniqueId\n     * @returns {String}\n     */\n    ShapeSegment.prototype.getUniqueId = function () {\n        return this.uniqueID;\n    };\n\n    /**\n     * Get ink ranges\n     *\n     * @method getInkRanges\n     * @returns {ShapeInkRange[]}\n     */\n    ShapeSegment.prototype.getInkRanges = function () {\n        return this.inkRanges;\n    };\n\n    /**\n     * Get selected candidate index\n     *\n     * @method getSelectedCandidateIdx\n     * @returns {Number}\n     */\n    ShapeSegment.prototype.getSelectedCandidateIdx = function () {\n        return this.selectedCandidateIndex;\n    };\n\n    /**\n     * Get candidates\n     *\n     * @method getCandidates\n     * @returns {ShapeCandidate[]}\n     */\n    ShapeSegment.prototype.getCandidates = function () {\n        return this.candidates;\n    };\n\n    /**\n     * Get selected candidate\n     *\n     * @method getSelectedCandidate\n     * @returns {ShapeCandidate}\n     */\n    ShapeSegment.prototype.getSelectedCandidate = function () {\n        if ((this.getCandidates().length > 0) && (this.getSelectedCandidateIdx() !== undefined)) {\n            return this.getCandidates()[this.getSelectedCandidateIdx()];\n        } else {\n            return undefined;\n        }\n    };\n\n    // Export\n    scope.ShapeSegment = ShapeSegment;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Math node\n     *\n     * @class MathNode\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MathNode(obj) {\n        if (obj) {\n            this.name = obj.name;\n            this.type = obj.type;\n        }\n    }\n\n    /**\n     * Get name\n     *\n     * @method getName\n     * @returns {String}\n     */\n    MathNode.prototype.getName = function () {\n        return this.name;\n    };\n\n    /**\n     * Get type\n     *\n     * @method getType\n     * @returns {String}\n     */\n    MathNode.prototype.getType = function () {\n        return this.type;\n    };\n\n    // Export\n    scope.MathNode = MathNode;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Math non-terminal node\n     *\n     * @class MathNonTerminalNode\n     * @extends MathNode\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MathNonTerminalNode(obj) {\n        scope.MathNode.call(this, obj);\n        this.candidates = [];\n        if (obj) {\n            this.selectedCandidate = obj.selectedCandidate;\n            for (var i in obj.candidates) {\n                switch (obj.candidates[i].type) {\n                    case 'nonTerminalNode':\n                        this.candidates.push(new scope.MathNonTerminalNode(obj.candidates[i]));\n                        break;\n                    case 'terminalNode':\n                        this.candidates.push(new scope.MathTerminalNode(obj.candidates[i]));\n                        break;\n                    case 'rule':\n                        this.candidates.push(new scope.MathRuleNode(obj.candidates[i]));\n                        break;\n                    case 'cell':\n                        this.candidates.push(new scope.MathCellNonTerminalNode(obj.candidates[i]));\n                        break;\n                    case 'border':\n                        this.candidates.push(new scope.MathBorderNonTerminalNode(obj.candidates[i]));\n                        break;\n                    case 'table':\n                        this.candidates.push(new scope.MathTableRuleNode(obj.candidates[i]));\n                        break;\n                    default:\n                        throw new Error('Unknown math node type: ' + obj.candidates[i].type);\n                }\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MathNonTerminalNode.prototype = new scope.MathNode();\n\n    /**\n     * Constructor property\n     */\n    MathNonTerminalNode.prototype.constructor = MathNonTerminalNode;\n\n    /**\n     * Get candidates\n     *\n     * @method getCandidates\n     * @returns {MathNode[]}\n     */\n    MathNonTerminalNode.prototype.getCandidates = function () {\n        return this.candidates;\n    };\n\n    /**\n     * Get selected candidate index\n     *\n     * @method getSelectedCandidateIdx\n     * @returns {Number}\n     */\n    MathNonTerminalNode.prototype.getSelectedCandidateIdx = function () {\n        return this.selectedCandidate;\n    };\n\n    /**\n     * Get selected candidate\n     *\n     * @method getSelectedCandidate\n     * @returns {MathNode}\n     */\n    MathNonTerminalNode.prototype.getSelectedCandidate = function () {\n        if ((this.getCandidates().length > 0) && (this.getSelectedCandidateIdx() !== undefined)) {\n            return this.getCandidates()[this.getSelectedCandidateIdx()];\n        } else {\n            return undefined;\n        }\n    };\n\n    /**\n     * Get ink ranges\n     *\n     * @method getInkRanges\n     * @returns {MathInkRange[]}\n     */\n    MathNonTerminalNode.prototype.getInkRanges = function () {\n        if (this.getSelectedCandidate()) {\n            return this.getSelectedCandidate().getInkRanges();\n        } else {\n            throw new Error('No selected candidate');\n        }\n    };\n\n    // Export\n    scope.MathNonTerminalNode = MathNonTerminalNode;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * Abstract math result\n     *\n     * @class MathResultElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MathResultElement(obj) {\n        if (obj) {\n            this.type = obj.type;\n        }\n    }\n\n    /**\n     * Get type\n     *\n     * @method getType\n     * @returns {String}\n     */\n    MathResultElement.prototype.getType = function () {\n        return this.type;\n    };\n\n    /**\n     * Is LaTeX result\n     *\n     * @method isLatex\n     * @returns {Boolean}\n     */\n    MathResultElement.prototype.isLaTex = function () {\n        return this.type === 'LATEX';\n    };\n\n    /**\n     * Is MathML result\n     *\n     * @method isMathMl\n     * @returns {Boolean}\n     */\n    MathResultElement.prototype.isMathMl = function () {\n        return this.type === 'MATHML';\n    };\n\n    /**\n     * Is SymbolTree result\n     *\n     * @method isSymbolTree\n     * @returns {Boolean}\n     */\n    MathResultElement.prototype.isSymbolTree = function () {\n        return this.type === 'SYMBOLTREE';\n    };\n\n    // Export\n    scope.MathResultElement = MathResultElement;\n})(MyScript);","(function (scope) {\n    'use strict';\n    /**\n     * Math rule node\n     *\n     * @class MathRuleNode\n     * @extends MathNode\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MathRuleNode(obj) {\n        scope.MathNode.call(this, obj);\n        this.children = [];\n        if (obj) {\n            this.name = obj.name;\n            for (var i in obj.children) {\n                switch (obj.children[i].type) {\n                    case 'nonTerminalNode':\n                        this.children.push(new scope.MathNonTerminalNode(obj.children[i]));\n                        break;\n                    case 'terminalNode':\n                        this.children.push(new scope.MathTerminalNode(obj.children[i]));\n                        break;\n                    case 'rule':\n                        this.children.push(new scope.MathRuleNode(obj.children[i]));\n                        break;\n                    case 'cell':\n                        this.children.push(new scope.MathCellNonTerminalNode(obj.children[i]));\n                        break;\n                    case 'border':\n                        this.children.push(new scope.MathBorderNonTerminalNode(obj.children[i]));\n                        break;\n                    case 'table':\n                        this.children.push(new scope.MathTableRuleNode(obj.children[i]));\n                        break;\n                    default:\n                        throw new Error('Unknown math node type: ' + obj.children[i].type);\n                }\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MathRuleNode.prototype = new scope.MathNode();\n\n    /**\n     * Constructor property\n     */\n    MathRuleNode.prototype.constructor = MathRuleNode;\n\n    /**\n     * Get name\n     *\n     * @method getName\n     * @returns {String}\n     */\n    MathRuleNode.prototype.getName = function () {\n        return this.name;\n    };\n\n    /**\n     * Get children\n     *\n     * @method getChildren\n     * @returns {MathNode[]}\n     */\n    MathRuleNode.prototype.getChildren = function () {\n        return this.children;\n    };\n\n    /**\n     * Get ink ranges\n     *\n     * @method getInkRanges\n     * @returns {MathInkRange[]}\n     */\n    MathRuleNode.prototype.getInkRanges = function () {\n        var inkRanges = [];\n        for (var i in this.getChildren()) {\n            var childInkRanges = this.getChildren()[i].getInkRanges();\n            for (var j in childInkRanges) {\n                inkRanges.push(childInkRanges[j]);\n            }\n        }\n        return inkRanges;\n    };\n\n    // Export\n    scope.MathRuleNode = MathRuleNode;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Math document\n     *\n     * @class MathDocument\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MathDocument(obj) {\n        this.results = [];\n        this.scratchOutResults = [];\n        if (obj) {\n            for (var i in obj.results) {\n                var result = obj.results[i];\n                switch (result.type) {\n                    case 'MATHML':\n                        this.results.push(new scope.MathMathMLResultElement(result));\n                        break;\n                    case 'LATEX':\n                        this.results.push(new scope.MathLaTexResultElement(result));\n                        break;\n                    case 'SYMBOLTREE':\n                        this.results.push(new scope.MathSymbolTreeResultElement(result));\n                        break;\n                    case 'OFFICEOPENXMLMATH':\n                        this.results.push(new scope.MathOfficeOpenXmlMathResultElement(result));\n                        break;\n                    default:\n                        throw new Error('Unknown math result type: ' + result.type);\n                }\n            }\n            for (var j in obj.scratchOutResults) {\n                this.scratchOutResults.push(new scope.MathScratchOut(obj.scratchOutResults[j]));\n            }\n        }\n    }\n\n    /**\n     * Get result elements\n     *\n     * @method getResultElements\n     * @returns {MathResultElement[]}\n     */\n    MathDocument.prototype.getResultElements = function () {\n        return this.results;\n    };\n\n    /**\n     * Get scratch-out results\n     *\n     * @method getScratchOutResults\n     * @returns {MathScratchOut[]}\n     */\n    MathDocument.prototype.getScratchOutResults = function () {\n        return this.scratchOutResults;\n    };\n\n    /**\n     * Has scratch-out results\n     *\n     * @method hasScratchOutResults\n     * @returns {Boolean}\n     */\n    MathDocument.prototype.hasScratchOutResults = function () {\n        if (this.getScratchOutResults() && (this.getScratchOutResults().length > 0)) {\n            return true;\n        }\n        return false;\n    };\n\n    // Export\n    scope.MathDocument = MathDocument;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * Math ink range\n     *\n     * @class MathInkRange\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MathInkRange(obj) {\n        if (obj) {\n            this.component = obj.component;\n            this.firstItem = obj.firstItem;\n            this.lastItem = obj.lastItem;\n        }\n    }\n\n    /**\n     * Get component\n     *\n     * @method getComponent\n     * @returns {Number}\n     */\n    MathInkRange.prototype.getComponent = function () {\n        return this.component;\n    };\n\n    /**\n     * Get first item\n     *\n     * @method getFirstItem\n     * @returns {Number}\n     */\n    MathInkRange.prototype.getFirstItem = function () {\n        return this.firstItem;\n    };\n\n    /**\n     * Get last item\n     *\n     * @method getLastItem\n     * @returns {Number}\n     */\n    MathInkRange.prototype.getLastItem = function () {\n        return this.lastItem;\n    };\n\n    // Export\n    scope.MathInkRange = MathInkRange;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * MathOfficeOpenXmlMathResultElement result element\n     *\n     * @class MathOfficeOpenXmlMathResultElement\n     * @extends MathResultElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MathOfficeOpenXmlMathResultElement(obj) {\n        scope.MathResultElement.call(this, obj);\n        if (obj) {\n            this.value = obj.value;\n        }\n    }\n\n\n    /**\n     * Inheritance property\n     */\n    MathOfficeOpenXmlMathResultElement.prototype = new scope.MathResultElement();\n\n    /**\n     * Constructor property\n     */\n    MathOfficeOpenXmlMathResultElement.prototype.constructor = MathOfficeOpenXmlMathResultElement;\n\n    /**\n     * Get value\n     *\n     * @method getValue\n     * @returns {String}\n     */\n    MathOfficeOpenXmlMathResultElement.prototype.getValue = function () {\n        return this.value;\n    };\n\n    // Export\n    scope.MathOfficeOpenXmlMathResultElement = MathOfficeOpenXmlMathResultElement;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * LaTex result element\n     *\n     * @class MathLaTexResultElement\n     * @extends MathResultElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MathLaTexResultElement(obj) {\n        scope.MathResultElement.call(this, obj);\n        if (obj) {\n            this.value = obj.value;\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MathLaTexResultElement.prototype = new scope.MathResultElement();\n\n    /**\n     * Constructor property\n     */\n    MathLaTexResultElement.prototype.constructor = MathLaTexResultElement;\n\n    /**\n     * Get value\n     *\n     * @method getValue\n     * @returns {String}\n     */\n    MathLaTexResultElement.prototype.getValue = function () {\n        return this.value;\n    };\n\n    // Export\n    scope.MathLaTexResultElement = MathLaTexResultElement;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * MathML result element\n     *\n     * @class MathMathMLResultElement\n     * @extends MathResultElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MathMathMLResultElement(obj) {\n        scope.MathResultElement.call(this, obj);\n        if (obj) {\n            this.value = obj.value;\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MathMathMLResultElement.prototype = new scope.MathResultElement();\n\n    /**\n     * Constructor property\n     */\n    MathMathMLResultElement.prototype.constructor = MathMathMLResultElement;\n\n    /**\n     * Get value\n     *\n     * @method getValue\n     * @returns {String}\n     */\n    MathMathMLResultElement.prototype.getValue = function () {\n        return this.value;\n    };\n\n    // Export\n    scope.MathMathMLResultElement = MathMathMLResultElement;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Math result\n     *\n     * @class MathResult\n     * @extends AbstractResult\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MathResult(obj) {\n        scope.AbstractResult.call(this, obj);\n        if (obj) {\n            this.result = new scope.MathDocument(obj.result);\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MathResult.prototype = new scope.AbstractResult();\n\n    /**\n     * Constructor property\n     */\n    MathResult.prototype.constructor = MathResult;\n\n    // Export\n    scope.MathResult = MathResult;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * Math scratch-out\n     *\n     * @class MathScratchOut\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MathScratchOut(obj) {\n        this.inkRanges = [];\n        this.erasedInkRanges = [];\n        if (obj) {\n            for (var i in obj.inkRanges) {\n                this.inkRanges.push(new scope.MathInkRange(obj.inkRanges[i]));\n            }\n            for (var j in obj.erasedInkRanges) {\n                this.erasedInkRanges.push(new scope.MathInkRange(obj.erasedInkRanges[j]));\n            }\n        }\n    }\n\n    /**\n     * Get ink ranges\n     *\n     * @method getInkRanges\n     * @returns {MathInkRange[]}\n     */\n    MathScratchOut.prototype.getInkRanges = function () {\n        return this.inkRanges;\n    };\n\n    /**\n     * Get erased ink ranges\n     *\n     * @method getErasedInkRanges\n     * @returns {MathInkRange[]}\n     */\n    MathScratchOut.prototype.getErasedInkRanges = function () {\n        return this.erasedInkRanges;\n    };\n\n    // Export\n    scope.MathScratchOut = MathScratchOut;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Math symbol tree\n     *\n     * @class MathSymbolTreeResultElement\n     * @extends MathResultElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MathSymbolTreeResultElement(obj) {\n        scope.MathResultElement.call(this, obj);\n        if (obj) {\n            if (obj.root) {\n                switch (obj.root.type) {\n                    case 'nonTerminalNode':\n                        this.root = new scope.MathNonTerminalNode(obj.root);\n                        break;\n                    case 'terminalNode':\n                        this.root = new scope.MathTerminalNode(obj.root);\n                        break;\n                    case 'rule':\n                        this.root = new scope.MathRuleNode(obj.root);\n                        break;\n                    case 'cell':\n                        this.root = new scope.MathCellNonTerminalNode(obj.root);\n                        break;\n                    case 'border':\n                        this.root = new scope.MathBorderNonTerminalNode(obj.root);\n                        break;\n                    case 'table':\n                        this.root = new scope.MathTableRuleNode(obj.root);\n                        break;\n                    default:\n                        throw new Error('Unknown math node type: ' + obj.root.type);\n                }\n                this.value = JSON.stringify(obj.root, null, '  ');\n            } else {\n                throw new Error('Missing root');\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MathSymbolTreeResultElement.prototype = new scope.MathResultElement();\n\n    /**\n     * Constructor property\n     */\n    MathSymbolTreeResultElement.prototype.constructor = MathSymbolTreeResultElement;\n\n    /**\n     * Get tree root\n     *\n     * @method getRoot\n     * @returns {MathNode}\n     */\n    MathSymbolTreeResultElement.prototype.getRoot = function () {\n        return this.root;\n    };\n\n    /**\n     * Get ink ranges\n     *\n     * @method getInkRanges\n     * @returns {MathInkRange[]}\n     */\n    MathSymbolTreeResultElement.prototype.getInkRanges = function () {\n        if (this.getRoot()) {\n            return this.getRoot().getInkRanges();\n        } else {\n            throw new Error('No selected candidate');\n        }\n    };\n\n    /**\n    * Get value\n    *\n    * @method getValue\n    * @returns {String}\n    */\n    MathSymbolTreeResultElement.prototype.getValue = function () {\n        return this.value;\n    };\n\n    // Export\n    scope.MathSymbolTreeResultElement = MathSymbolTreeResultElement;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * Math terminal node\n     *\n     * @class MathTerminalNode\n     * @extends MathNode\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MathTerminalNode(obj) {\n        scope.MathNode.call(this, obj);\n        this.candidates = [];\n        this.inkRanges = [];\n        if (obj) {\n            this.selectedCandidate = obj.selectedCandidate;\n            for (var i in obj.candidates) {\n                this.candidates.push(new scope.MathTerminalNodeCandidate(obj.candidates[i]));\n            }\n            for (var j in obj.inkRanges) {\n                this.inkRanges.push(new scope.MathInkRange(obj.inkRanges[j]));\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MathTerminalNode.prototype = new scope.MathNode();\n\n    /**\n     * Constructor property\n     */\n    MathTerminalNode.prototype.constructor = MathTerminalNode;\n\n    /**\n     * Get candidates\n     *\n     * @method getCandidates\n     * @returns {MathTerminalNodeCandidate[]}\n     */\n    MathTerminalNode.prototype.getCandidates = function () {\n        return this.candidates;\n    };\n\n    /**\n     * Get ink ranges\n     *\n     * @method getInkRanges\n     * @returns {MathInkRange[]}\n     */\n    MathTerminalNode.prototype.getInkRanges = function () {\n        return this.inkRanges;\n    };\n\n    /**\n     * Get selected candidate index\n     *\n     * @method getSelectedCandidateIdx\n     * @returns {Number}\n     */\n    MathTerminalNode.prototype.getSelectedCandidateIdx = function () {\n        return this.selectedCandidate;\n    };\n\n    /**\n     * Get selected candidate\n     *\n     * @method getSelectedCandidate\n     * @returns {MathTerminalNodeCandidate}\n     */\n    MathTerminalNode.prototype.getSelectedCandidate = function () {\n        if ((this.getCandidates().length > 0) && (this.getSelectedCandidateIdx() !== undefined)) {\n            return this.getCandidates()[this.getSelectedCandidateIdx()];\n        } else {\n            return undefined;\n        }\n    };\n\n    // Export\n    scope.MathTerminalNode = MathTerminalNode;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * Math terminal node candidate\n     *\n     * @class MathTerminalNodeCandidate\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MathTerminalNodeCandidate(obj) {\n        if (obj) {\n            this.label = obj.label;\n            this.normalizedRecognitionScore = obj.normalizedRecognitionScore;\n        }\n    }\n\n    /**\n     * Get label\n     *\n     * @method getLabel\n     * @returns {String}\n     */\n    MathTerminalNodeCandidate.prototype.getLabel = function () {\n        return this.label;\n    };\n\n    /**\n     * Get score\n     *\n     * @method getNormalizedRecognitionScore\n     * @returns {Number}\n     */\n    MathTerminalNodeCandidate.prototype.getNormalizedRecognitionScore = function () {\n        return this.normalizedRecognitionScore;\n    };\n\n    // Export\n    scope.MathTerminalNodeCandidate = MathTerminalNodeCandidate;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Math border data\n     *\n     * @class MathBorderData\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MathBorderData(obj) {\n        if (obj) {\n            this.position = obj.position;\n            this.start = obj.start;\n            this.stop = obj.stop;\n            this.type = obj.type;\n        }\n    }\n\n    /**\n     * Get position\n     *\n     * @method getPosition\n     * @returns {Number}\n     */\n    MathBorderData.prototype.getPosition = function () {\n        return this.position;\n    };\n\n    /**\n     * Get start\n     *\n     * @method getStart\n     * @returns {Number}\n     */\n    MathBorderData.prototype.getStart = function () {\n        return this.start;\n    };\n\n    /**\n     * Get stop\n     *\n     * @method getStop\n     * @returns {Number}\n     */\n    MathBorderData.prototype.getStop = function () {\n        return this.stop;\n    };\n\n    /**\n     * Get type\n     *\n     * @method getType\n     * @returns {String}\n     */\n    MathBorderData.prototype.getType = function () {\n        return this.type;\n    };\n\n    // Export\n    scope.MathBorderData = MathBorderData;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * Math border non-terminal node\n     *\n     * @class MathBorderNonTerminalNode\n     * @extends MathNonTerminalNode\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MathBorderNonTerminalNode(obj) {\n        scope.MathNonTerminalNode.call(this, obj);\n        if (obj) {\n            this.data = new scope.MathBorderData(obj.data);\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MathBorderNonTerminalNode.prototype = new scope.MathNonTerminalNode();\n\n    /**\n     * Constructor property\n     */\n    MathBorderNonTerminalNode.prototype.constructor = MathBorderNonTerminalNode;\n\n    /**\n     * Get data\n     *\n     * @method getData\n     * @returns {MathBorderData}\n     */\n    MathBorderNonTerminalNode.prototype.getData = function () {\n        return this.data;\n    };\n\n    // Export\n    scope.MathBorderNonTerminalNode = MathBorderNonTerminalNode;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * Math cell data\n     *\n     * @class MathCellData\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MathCellData(obj) {\n        if (obj) {\n            this.columnStart = obj.columnStart;\n            this.columnStop = obj.columnStop;\n            this.rowStart = obj.rowStart;\n            this.rowStop = obj.rowStop;\n        }\n    }\n\n    /**\n     * Get column start\n     *\n     * @method getColumnStart\n     * @returns {Number}\n     */\n    MathCellData.prototype.getColumnStart = function () {\n        return this.columnStart;\n    };\n\n    /**\n     * Get column stop\n     *\n     * @method getColumnStop\n     * @returns {Number}\n     */\n    MathCellData.prototype.getColumnStop = function () {\n        return this.columnStop;\n    };\n\n    /**\n     * Get row start\n     *\n     * @method getRowStart\n     * @returns {Number}\n     */\n    MathCellData.prototype.getRowStart = function () {\n        return this.rowStart;\n    };\n\n    /**\n     * Get row stop\n     *\n     * @method getRowStop\n     * @returns {Number}\n     */\n    MathCellData.prototype.getRowStop = function () {\n        return this.rowStop;\n    };\n\n    // Export\n    scope.MathCellData = MathCellData;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * Math cell non-terminal node\n     *\n     * @class MathCellNonTerminalNode\n     * @extends MathNonTerminalNode\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MathCellNonTerminalNode(obj) {\n        scope.MathNonTerminalNode.call(this, obj);\n        if (obj) {\n            this.data = new scope.MathCellData(obj.data);\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MathCellNonTerminalNode.prototype = new scope.MathNonTerminalNode();\n\n    /**\n     * Constructor property\n     */\n    MathCellNonTerminalNode.prototype.constructor = MathCellNonTerminalNode;\n\n    /**\n     * Get data\n     *\n     * @method getData\n     * @returns {MathCellData}\n     */\n    MathCellNonTerminalNode.prototype.getData = function () {\n        return this.data;\n    };\n\n    // Export\n    scope.MathCellNonTerminalNode = MathCellNonTerminalNode;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * Math table data\n     *\n     * @class MathTableData\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MathTableData(obj) {\n        if (obj) {\n            this.columnCount = obj.columnCount;\n            this.rowCount = obj.rowCount;\n        }\n    }\n\n    /**\n     * Get column count\n     *\n     * @method getColumnCount\n     * @returns {Number}\n     */\n    MathTableData.prototype.getColumnCount = function () {\n        return this.columnCount;\n    };\n\n    /**\n     * Get row count\n     *\n     * @method getRowCount\n     * @returns {Number}\n     */\n    MathTableData.prototype.getRowCount = function () {\n        return this.rowCount;\n    };\n\n    // Export\n    scope.MathTableData = MathTableData;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * Math table rule node\n     *\n     * @class MathTableRuleNode\n     * @extends MathRuleNode\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MathTableRuleNode(obj) {\n        scope.MathRuleNode.call(this, obj);\n        if (obj) {\n            this.data = new scope.MathTableData(obj.data);\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MathTableRuleNode.prototype = new scope.MathRuleNode();\n\n    /**\n     * Constructor property\n     */\n    MathTableRuleNode.prototype.constructor = MathTableRuleNode;\n\n    /**\n     * Get data\n     *\n     * @method getData\n     * @returns {MathTableData}\n     */\n    MathTableRuleNode.prototype.getData = function () {\n        return this.data;\n    };\n\n    // Export\n    scope.MathTableRuleNode = MathTableRuleNode;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * WebSocket recognition math result message\n     *\n     * @class MathResponseWSMessage\n     * @extends AbstractRecoResponseWSMessage\n     * @param {Object} [obj] Recognition WebSocket message\n     * @constructor\n     */\n    function MathResponseWSMessage(obj) {\n        scope.AbstractRecoResponseWSMessage.call(this, obj);\n        if (obj) {\n            this.result = new scope.MathDocument(obj.result);\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MathResponseWSMessage.prototype = new scope.AbstractRecoResponseWSMessage();\n\n    /**\n     * Constructor property\n     */\n    MathResponseWSMessage.prototype.constructor = MathResponseWSMessage;\n\n    // Export\n    scope.MathResponseWSMessage = MathResponseWSMessage;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * Abstract music element\n     *\n     * @class MusicElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicElement(obj) {\n        if (obj) {\n            this.inputRanges = [];\n            this.elementType = obj.elementType;\n            this.inputRanges = obj.inputRanges;\n        }\n    }\n\n    /**\n     * Get element type\n     *\n     * @method getElementType\n     * @returns {String}\n     */\n    MusicElement.prototype.getElementType = function () {\n        return this.elementType;\n    };\n\n    /**\n     * Get input ranges\n     *\n     * @method getInputRanges\n     * @returns {MusicInputRange[]}\n     */\n    MusicElement.prototype.getInputRanges = function () {\n        return this.inputRanges;\n    };\n\n    // Export\n    scope.MusicElement = MusicElement;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Abstract music result element\n     *\n     * @class MusicResultElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicResultElement(obj) {\n        if (obj) {\n            this.type = obj.type;\n        }\n    }\n\n    /**\n     * Get type\n     *\n     * @method getType\n     * @returns {String}\n     */\n    MusicResultElement.prototype.getType = function () {\n        return this.type;\n    };\n\n    /**\n     * Is MusicXML\n     *\n     * @method isMusicXML\n     * @returns {Boolean}\n     */\n    MusicResultElement.prototype.isMusicXML = function () {\n        return this.type === 'MUSICXML';\n    };\n\n    /**\n     * Is ScoreTree\n     *\n     * @method isScoreTree\n     * @returns {Boolean}\n     */\n    MusicResultElement.prototype.isScoreTree = function () {\n        return this.type === 'SCORETREE';\n    };\n\n    // Export\n    scope.MusicResultElement = MusicResultElement;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Music accidental\n     *\n     * @class MusicAccidental\n     * @extends MusicElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicAccidental(obj) {\n        scope.MusicElement.call(this, obj);\n        if (obj) {\n            this.type = obj.type;\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicAccidental.prototype = new scope.MusicElement();\n\n    /**\n     * Constructor property\n     */\n    MusicAccidental.prototype.constructor = MusicAccidental;\n\n    /**\n     * Get type\n     *\n     * @method getType\n     * @returns {String}\n     */\n    MusicAccidental.prototype.getType = function () {\n        return this.type;\n    };\n\n    // Export\n    scope.MusicAccidental = MusicAccidental;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Music annotation\n     *\n     * @class MusicAnnotation\n     * @extends MusicElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicAnnotation(obj) {\n        scope.MusicElement.call(this, obj);\n        if (obj) {\n            this.label = obj.label;\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicAnnotation.prototype = new scope.MusicElement();\n\n    /**\n     * Constructor property\n     */\n    MusicAnnotation.prototype.constructor = MusicAnnotation;\n\n    /**\n     * Get label\n     *\n     * @method getLabel\n     * @returns {String}\n     */\n    MusicAnnotation.prototype.getLabel = function () {\n        return this.label;\n    };\n\n    // Export\n    scope.MusicAnnotation = MusicAnnotation;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Music arpeggiate\n     *\n     * @class MusicArpeggiate\n     * @extends MusicElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicArpeggiate(obj) {\n        scope.MusicElement.call(this, obj);\n        if (obj) {\n            this.type = obj.type;\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicArpeggiate.prototype = new scope.MusicElement();\n\n    /**\n     * Constructor property\n     */\n    MusicArpeggiate.prototype.constructor = MusicArpeggiate;\n\n    /**\n     * Get type\n     *\n     * @method getType\n     * @returns {String}\n     */\n    MusicArpeggiate.prototype.getType = function () {\n        return this.type;\n    };\n\n    // Export\n    scope.MusicArpeggiate = MusicArpeggiate;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Music bar\n     *\n     * @class MusicBar\n     * @extends MusicElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicBar(obj) {\n        scope.MusicElement.call(this, obj);\n        this.decorations = [];\n        if (obj) {\n            this.repeatDirection = obj.repeatDirection;\n            this.style = obj.style;\n            for (var i in obj.decorations) {\n                this.decorations.push(new scope.MusicDecoration(obj.decorations[i]));\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicBar.prototype = new scope.MusicElement();\n\n    /**\n     * Constructor property\n     */\n    MusicBar.prototype.constructor = MusicBar;\n\n    /**\n     * Get repeat direction\n     *\n     * @method getRepeatDirection\n     * @returns {String}\n     */\n    MusicBar.prototype.getRepeatDirection = function () {\n        return this.repeatDirection;\n    };\n\n    /**\n     * Set repeat direction\n     *\n     * @method setRepeatDirection\n     * @param {String} repeatDirection\n     */\n    MusicBar.prototype.setRepeatDirection = function (repeatDirection) {\n        this.repeatDirection = repeatDirection;\n    };\n\n    /**\n     * Get style\n     *\n     * @method getStyle\n     * @returns {String}\n     */\n    MusicBar.prototype.getStyle = function () {\n        return this.style;\n    };\n\n    /**\n     * Set style\n     *\n     * @method setStyle\n     * @param {String} style\n     */\n    MusicBar.prototype.setStyle = function (style) {\n        this.style = style;\n    };\n\n    /**\n     * Get decorations\n     *\n     * @method getDecorations\n     * @returns {MusicDecoration[]}\n     */\n    MusicBar.prototype.getDecorations = function () {\n        return this.decorations;\n    };\n\n    /**\n     * Set decorations\n     *\n     * @method setDecorations\n     * @param {MusicDecoration[]}\n     */\n    MusicBar.prototype.setDecorations = function (decorations) {\n        this.decorations = decorations;\n    };\n\n    // Export\n    scope.MusicBar = MusicBar;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Music beam\n     *\n     * @class MusicBeam\n     * @extends MusicElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicBeam(obj) {\n        scope.MusicElement.call(this, obj);\n        if (obj) {\n            this.gap = obj.gap;\n            this.slope = obj.slope;\n            this.placement = obj.placement;\n            this.leftCount = obj.leftCount;\n            this.rightCount = obj.rightCount;\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicBeam.prototype = new scope.MusicElement();\n\n    /**\n     * Constructor property\n     */\n    MusicBeam.prototype.constructor = MusicBeam;\n\n    /**\n     * Get gap\n     *\n     * @method getGap\n     * @returns {Number}\n     */\n    MusicBeam.prototype.getGap = function () {\n        return this.gap;\n    };\n\n    /**\n     * Set gap\n     *\n     * @method setGap\n     * @param {Number} gap\n     */\n    MusicBeam.prototype.setGap = function (gap) {\n        this.gap = gap;\n    };\n\n    /**\n     * Get slope\n     *\n     * @method getSlope\n     * @returns {String}\n     */\n    MusicBeam.prototype.getSlope = function () {\n        return this.slope;\n    };\n\n    /**\n     * Set slope\n     *\n     * @method setSlope\n     * @param {String} slope\n     */\n    MusicBeam.prototype.setSlope = function (slope) {\n        this.slope = slope;\n    };\n\n    /**\n     * Get placement\n     *\n     * @method getPlacement\n     * @returns {String}\n     */\n    MusicBeam.prototype.getPlacement = function () {\n        return this.placement;\n    };\n\n    /**\n     * Set placement\n     *\n     * @method setPlacement\n     * @param {String} placement\n     */\n    MusicBeam.prototype.setPlacement = function (placement) {\n        this.placement = placement;\n    };\n\n    /**\n     * Get left count\n     *\n     * @method getLeftCount\n     * @returns {Number}\n     */\n    MusicBeam.prototype.getLeftCount = function () {\n        return this.leftCount;\n    };\n\n    /**\n     * Set left count\n     *\n     * @method setLeftCount\n     * @param {Number} leftCount\n     */\n    MusicBeam.prototype.setLeftCount = function (leftCount) {\n        this.leftCount = leftCount;\n    };\n\n    /**\n     * Get right count\n     *\n     * @method getRightCount\n     * @returns {Number}\n     */\n    MusicBeam.prototype.getRightCount = function () {\n        return this.rightCount;\n    };\n\n    /**\n     * Set right count\n     *\n     * @method setRightCount\n     * @param {Number} rightCount\n     */\n    MusicBeam.prototype.setRightCount = function (rightCount) {\n        this.rightCount = rightCount;\n    };\n\n\n    // Export\n    scope.MusicBeam = MusicBeam;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Music chord\n     *\n     * @class MusicChord\n     * @extends MusicElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicChord(obj) {\n        scope.MusicElement.call(this, obj);\n        this.decorations = [];\n        this.notes = [];\n        this.beamTypes = [];\n        this.ledgerLines = [];\n        this.startSlurs = [];\n        this.stopSlurs = [];\n        if (obj) {\n            this.duration = obj.duration;\n            this.arpeggiate = new scope.MusicArpeggiate(obj.arpeggiate);\n            this.startBeam = new scope.MusicBeam(obj.startBeam);\n            this.stopBeam = new scope.MusicBeam(obj.stopBeam);\n            this.stem = new scope.MusicStem(obj.stem);\n            for (var i in obj.decorations) {\n                this.decorations.push(new scope.MusicDecoration(obj.decorations[i]));\n            }\n            for (var j in obj.notes) {\n                this.notes.push(new scope.MusicNote(obj.notes[j]));\n            }\n            for (var k in obj.beamTypes) {\n                this.beamTypes.push(obj.beamTypes[k]);\n            }\n            for (var l in obj.ledgerLines) {\n                this.ledgerLines.push(new scope.MusicLedgerLine(obj.ledgerLines[l]));\n            }\n            for (var m in obj.startSlurs) {\n                this.startSlurs.push(new scope.MusicSlur(obj.startSlurs[m]));\n            }\n            for (var n in obj.stopSlurs) {\n                this.stopSlurs.push(new scope.MusicSlur(obj.stopSlurs[n]));\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicChord.prototype = new scope.MusicElement();\n\n    /**\n     * Constructor property\n     */\n    MusicChord.prototype.constructor = MusicChord;\n\n    /**\n     * Get duration\n     *\n     * @method getDuration\n     * @returns {Number}\n     */\n    MusicChord.prototype.getDuration = function () {\n        return this.duration;\n    };\n\n    /**\n     * Get arpeggiate\n     *\n     * @method getArpeggiate\n     * @returns {MusicArpeggiate}\n     */\n    MusicChord.prototype.getArpeggiate = function () {\n        return this.arpeggiate;\n    };\n\n    /**\n     * Get start beam\n     *\n     * @method getStartBeam\n     * @returns {MusicBeam}\n     */\n    MusicChord.prototype.getStartBeam = function () {\n        return this.startBeam;\n    };\n\n    /**\n     * Get stop beam\n     *\n     * @method getStopBeam\n     * @returns {MusicBeam}\n     */\n    MusicChord.prototype.getStopBeam = function () {\n        return this.stopBeam;\n    };\n\n    /**\n     * Get stem\n     *\n     * @method getStem\n     * @returns {MusicStem}\n     */\n    MusicChord.prototype.getStem = function () {\n        return this.stem;\n    };\n\n    /**\n     * Get decorations\n     *\n     * @method getDecorations\n     * @returns {MusicDecoration[]}\n     */\n    MusicChord.prototype.getDecorations = function () {\n        return this.decorations;\n    };\n\n    /**\n     * Get notes\n     *\n     * @method getNotes\n     * @returns {MusicNote[]}\n     */\n    MusicChord.prototype.getNotes = function () {\n        return this.notes;\n    };\n\n    /**\n     * Get beam types\n     *\n     * @method getBeamTypes\n     * @returns {Array}\n     */\n    MusicChord.prototype.getBeamTypes = function () {\n        return this.beamTypes;\n    };\n\n    /**\n     * Get ledger lines\n     *\n     * @method getLedgerLines\n     * @returns {MusicLedgerLine[]}\n     */\n    MusicChord.prototype.getLedgerLines = function () {\n        return this.ledgerLines;\n    };\n\n    /**\n     * Get start slurs\n     *\n     * @method getStartSlurs\n     * @returns {MusicSlur[]}\n     */\n    MusicChord.prototype.getStartSlurs = function () {\n        return this.startSlurs;\n    };\n\n    /**\n     * Get stop slurs\n     *\n     * @method getStopSlurs\n     * @returns {MusicSlur[]}\n     */\n    MusicChord.prototype.getStopSlurs = function () {\n        return this.stopSlurs;\n    };\n\n    // Export\n    scope.MusicChord = MusicChord;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Music clef\n     * default values: symbol='G', octave=0\n     *\n     * @class MusicClef\n     * @extends MusicElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicClef(obj) {\n        scope.MusicElement.call(this, obj);\n        this.symbol = 'G';\n        this.octave = 0;\n        if (obj) {\n            this.line = obj.line;\n            this.yAnchor = obj.yAnchor;\n            this.octave = obj.octave;\n            this.symbol = obj.symbol;\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicClef.prototype = new scope.MusicElement();\n\n    /**\n     * Constructor property\n     */\n    MusicClef.prototype.constructor = MusicClef;\n\n    /**\n     * Get y anchor\n     *\n     * @method getYAnchor\n     * @returns {Number}\n     */\n    MusicClef.prototype.getYAnchor = function () {\n        return this.yAnchor;\n    };\n\n    /**\n     * Set y anchor\n     *\n     * @method setYAnchor\n     * @param {Number} yAnchor\n     */\n    MusicClef.prototype.setYAnchor = function (yAnchor) {\n        this.yAnchor = yAnchor;\n    };\n\n    /**\n     * Get line\n     *\n     * @method getLine\n     * @returns {Number}\n     */\n    MusicClef.prototype.getLine = function () {\n        return this.line;\n    };\n\n    /**\n     * Set line\n     *\n     * @method setLine\n     * @param {Number} line\n     */\n    MusicClef.prototype.setLine = function (line) {\n        this.line = line;\n    };\n\n    /**\n     * Get octave\n     *\n     * @method getOctave\n     * @returns {Number}\n     */\n    MusicClef.prototype.getOctave = function () {\n        return this.octave;\n    };\n\n    /**\n     * Set octave\n     *\n     * @method setOctave\n     * @param {Number} octave\n     */\n    MusicClef.prototype.setOctave = function (octave) {\n        this.octave = octave;\n    };\n\n    /**\n     * Get symbol\n     *\n     * @method getSymbol\n     * @returns {String}\n     */\n    MusicClef.prototype.getSymbol = function () {\n        return this.symbol;\n    };\n\n    /**\n     * Set symbol\n     *\n     * @method setSymbol\n     * @param {String} symbol\n     */\n    MusicClef.prototype.setSymbol = function (symbol) {\n        this.symbol = symbol;\n    };\n\n    // Export\n    scope.MusicClef = MusicClef;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Music decoration\n     *\n     * @class MusicDecoration\n     * @extends MusicElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicDecoration(obj) {\n        scope.MusicElement.call(this, obj);\n        if (obj) {\n            this.symbol = obj.symbol;\n            this.placement = obj.placement;\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicDecoration.prototype = new scope.MusicElement();\n\n    /**\n     * Constructor property\n     */\n    MusicDecoration.prototype.constructor = MusicDecoration;\n\n    /**\n     * Get symbol\n     *\n     * @method getSymbol\n     * @returns {String}\n     */\n    MusicDecoration.prototype.getSymbol = function () {\n        return this.symbol;\n    };\n\n    /**\n     * Set symbol\n     *\n     * @method setSymbol\n     * @param {String} symbol\n     */\n    MusicDecoration.prototype.setSymbol = function (symbol) {\n        this.symbol = symbol;\n    };\n\n    /**\n     * Get placement\n     *\n     * @method getPlacement\n     * @returns {String}\n     */\n    MusicDecoration.prototype.getPlacement = function () {\n        return this.placement;\n    };\n\n    /**\n     * Set placement\n     *\n     * @method setPlacement\n     * @param {String} placement\n     */\n    MusicDecoration.prototype.setPlacement = function (placement) {\n        this.placement = placement;\n    };\n\n    // Export\n    scope.MusicDecoration = MusicDecoration;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Music document\n     *\n     * @class MusicDocument\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicDocument(obj) {\n        this.results = [];\n        this.scratchOutResults = [];\n        if (obj) {\n            for (var i in obj.results) {\n                switch (obj.results[i].type) {\n                    case 'MUSICXML':\n                        this.results.push(new scope.MusicXMLResultElement(obj.results[i]));\n                        break;\n                    default:\n                        this.results.push(new scope.MusicScoreTreeResultElement(obj.results[i]));\n                        break;\n                }\n            }\n            for (var j in obj.scratchOutResults) {\n                this.scratchOutResults.push(new scope.MusicScratchOut(obj.scratchOutResults[j]));\n            }\n        }\n    }\n\n    /**\n     * Get result elements\n     *\n     * @method getResultElements\n     * @returns {MusicResultElement[]}\n     */\n    MusicDocument.prototype.getResultElements = function () {\n        return this.results;\n    };\n\n    /**\n     * Get scratch-out results\n     *\n     * @method getScratchOutResults\n     * @returns {MusicScratchOut[]}\n     */\n    MusicDocument.prototype.getScratchOutResults = function () {\n        return this.scratchOutResults;\n    };\n\n    /**\n     * Has scratch-out results\n     *\n     * @method hasScratchOutResults\n     * @returns {Boolean}\n     */\n    MusicDocument.prototype.hasScratchOutResults = function () {\n        if (this.getScratchOutResults() && (this.getScratchOutResults().length > 0)) {\n            return true;\n        }\n        return false;\n    };\n\n    // Export\n    scope.MusicDocument = MusicDocument;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Music dots\n     *\n     * @class MusicDots\n     * @extends MusicElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicDots(obj) {\n        scope.MusicElement.call(this, obj);\n        if (obj) {\n            this.count = obj.count;\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicDots.prototype = new scope.MusicElement();\n\n    /**\n     * Constructor property\n     */\n    MusicDots.prototype.constructor = MusicDots;\n\n    /**\n     * Get dots counts\n     *\n     * @method getCount\n     * @returns {Number}\n     */\n    MusicDots.prototype.getCount = function () {\n        return this.count;\n    };\n\n    // Export\n    scope.MusicDots = MusicDots;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Music head\n     *\n     * @class MusicHead\n     * @extends MusicElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicHead(obj) {\n        scope.MusicElement.call(this, obj);\n        if (obj) {\n            this.type = obj.type;\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicHead.prototype = new scope.MusicElement();\n\n    /**\n     * Constructor property\n     */\n    MusicHead.prototype.constructor = MusicHead;\n\n    /**\n     * Get type\n     *\n     * @method getType\n     * @returns {String}\n     */\n    MusicHead.prototype.getType = function () {\n        return this.type;\n    };\n\n    // Export\n    scope.MusicHead = MusicHead;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Music input range\n     *\n     * @class MusicInputRange\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicInputRange(obj) {\n        if (obj) {\n            this.component = obj.component;\n            this.firstItem = obj.firstItem;\n            this.lastItem = obj.lastItem;\n        }\n    }\n\n    /**\n     * Get component\n     *\n     * @method getComponent\n     * @returns {Number}\n     */\n    MusicInputRange.prototype.getComponent = function () {\n        return this.component;\n    };\n\n    /**\n     * Get first item\n     *\n     * @method getFirstItem\n     * @returns {Number}\n     */\n    MusicInputRange.prototype.getFirstItem = function () {\n        return this.firstItem;\n    };\n\n    /**\n     * Get last item\n     *\n     * @method getLastItem\n     * @returns {Number}\n     */\n    MusicInputRange.prototype.getLastItem = function () {\n        return this.lastItem;\n    };\n\n    // Export\n    scope.MusicInputRange = MusicInputRange;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Music key signature\n     *\n     * @class MusicKeySignature\n     * @extends MusicElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicKeySignature(obj) {\n        scope.MusicElement.call(this, obj);\n        this.accidentals = [];\n        if (obj) {\n            this.signature = new scope.MusicKeySignatureData(obj.signature);\n            for (var i in obj.accidentals) {\n                this.accidentals.push(new scope.MusicAccidental(obj.accidentals[i]));\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicKeySignature.prototype = new scope.MusicElement();\n\n    /**\n     * Constructor property\n     */\n    MusicKeySignature.prototype.constructor = MusicKeySignature;\n\n    /**\n     * Get signature\n     *\n     * @method getSignature\n     * @returns {MusicKeySignatureData}\n     */\n    MusicKeySignature.prototype.getSignature = function () {\n        return this.signature;\n    };\n\n    /**\n     * Get accidentals\n     *\n     * @method getAccidentals\n     * @returns {MusicAccidental[]}\n     */\n    MusicKeySignature.prototype.getAccidentals = function () {\n        return this.accidentals;\n    };\n\n    // Export\n    scope.MusicKeySignature = MusicKeySignature;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Music key signature data\n     *\n     * @class MusicKeySignatureData\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicKeySignatureData(obj) {\n        if (obj) {\n            this.fifths = obj.fifths;\n            this.cancel = obj.cancel;\n        }\n    }\n\n    /**\n     * Get fifths\n     *\n     * @method getFifths\n     * @returns {Number}\n     */\n    MusicKeySignatureData.prototype.getFifths = function () {\n        return this.fifths;\n    };\n\n    /**\n     * Get cancel\n     *\n     * @method getCancel\n     * @returns {Number}\n     */\n    MusicKeySignatureData.prototype.getCancel = function () {\n        return this.cancel;\n    };\n\n    // Export\n    scope.MusicKeySignatureData = MusicKeySignatureData;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Music ledger line\n     *\n     * @class MusicLedgerLine\n     * @extends MusicElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicLedgerLine(obj) {\n        scope.MusicElement.call(this, obj);\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicLedgerLine.prototype = new scope.MusicElement();\n\n    /**\n     * Constructor property\n     */\n    MusicLedgerLine.prototype.constructor = MusicLedgerLine;\n\n    // Export\n    scope.MusicLedgerLine = MusicLedgerLine;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Music note\n     *\n     * @class MusicNote\n     * @extends MusicElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicNote(obj) {\n        scope.MusicElement.call(this, obj);\n        this.decorations = [];\n        this.beamTypes = [];\n        this.ledgerLines = [];\n        this.startSlurs = [];\n        this.stopSlurs = [];\n        if (obj) {\n            this.accidental = new scope.MusicAccidental(obj.accidental);\n            this.dots = new scope.MusicDots(obj.dots);\n            this.duration = obj.duration;\n            this.head = new scope.MusicHead(obj.head);\n            this.line = obj.line;\n            this.pitch = new scope.MusicPitchData(obj.pitch);\n            this.startBeam = new scope.MusicBeam(obj.startBeam);\n            this.stopBeam = new scope.MusicBeam(obj.stopBeam);\n            this.stem = new scope.MusicStem(obj.stem);\n            this.startTie = new scope.MusicTie(obj.startTie);\n            this.stopTie = new scope.MusicTie(obj.stopTie);\n            this.startTuplet = new scope.MusicTuplet(obj.startTuplet);\n            this.stopTuplet = new scope.MusicTuplet(obj.stopTuplet);\n            this.timeModification = new scope.MusicTimeModificationData(obj.timeModification);\n            this.type = obj.type;\n            for (var i in obj.decorations) {\n                this.decorations.push(new scope.MusicDecoration(obj.decorations[i]));\n            }\n            for (var j in obj.beamTypes) {\n                this.beamTypes.push(obj.beamTypes[j]);\n            }\n            for (var k in obj.ledgerLines) {\n                this.ledgerLines.push(new scope.MusicLedgerLine(obj.ledgerLines[k]));\n            }\n            for (var l in obj.startSlurs) {\n                this.startSlurs.push(new scope.MusicSlur(obj.startSlurs[l]));\n            }\n            for (var m in obj.stopSlurs) {\n                this.stopSlurs.push(new scope.MusicSlur(obj.stopSlurs[m]));\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicNote.prototype = new scope.MusicElement();\n\n    /**\n     * Constructor property\n     */\n    MusicNote.prototype.constructor = MusicNote;\n\n    /**\n     * Get accidental\n     *\n     * @method getAccidental\n     * @returns {MusicAccidental}\n     */\n    MusicNote.prototype.getAccidental = function () {\n        return this.accidental;\n    };\n\n    /**\n     * Get dots\n     *\n     * @method getDots\n     * @returns {MusicDots}\n     */\n    MusicNote.prototype.getDots = function () {\n        return this.dots;\n    };\n\n    /**\n     * Get duration\n     *\n     * @method getDuration\n     * @returns {Number}\n     */\n    MusicNote.prototype.getDuration = function () {\n        return this.duration;\n    };\n\n    /**\n     * Get head\n     *\n     * @method getHead\n     * @returns {MusicHead}\n     */\n    MusicNote.prototype.getHead = function () {\n        return this.head;\n    };\n\n    /**\n     * Get line\n     *\n     * @method getLine\n     * @returns {Number}\n     */\n    MusicNote.prototype.getLine = function () {\n        return this.line;\n    };\n\n    /**\n     * Get pitch\n     *\n     * @method getPitch\n     * @returns {MusicPitchData}\n     */\n    MusicNote.prototype.getPitch = function () {\n        return this.pitch;\n    };\n\n    /**\n     * Get start beam\n     *\n     * @method getStartBeam\n     * @returns {MusicBeam}\n     */\n    MusicNote.prototype.getStartBeam = function () {\n        return this.startBeam;\n    };\n\n    /**\n     * Get stop beam\n     *\n     * @method getStopBeam\n     * @returns {MusicBeam}\n     */\n    MusicNote.prototype.getStopBeam = function () {\n        return this.stopBeam;\n    };\n\n    /**\n     * Get stem\n     *\n     * @method getStem\n     * @returns {MusicStem}\n     */\n    MusicNote.prototype.getStem = function () {\n        return this.stem;\n    };\n\n    /**\n     * Get start tie\n     *\n     * @method getStartTie\n     * @returns {MusicTie}\n     */\n    MusicNote.prototype.getStartTie = function () {\n        return this.startTie;\n    };\n\n    /**\n     * Get stop tie\n     *\n     * @method getStopTie\n     * @returns {MusicTie}\n     */\n    MusicNote.prototype.getStopTie = function () {\n        return this.stopTie;\n    };\n\n    /**\n     * Get start tuplet\n     *\n     * @method getStartTuplet\n     * @returns {MusicTuplet}\n     */\n    MusicNote.prototype.getStartTuplet = function () {\n        return this.startTuplet;\n    };\n\n    /**\n     * Get stop tuplet\n     *\n     * @method getStopTuplet\n     * @returns {MusicTuplet}\n     */\n    MusicNote.prototype.getStopTuplet = function () {\n        return this.stopTuplet;\n    };\n\n    /**\n     * Get time modification\n     *\n     * @method getTimeModification\n     * @returns {MusicTimeModificationData}\n     */\n    MusicNote.prototype.getTimeModification = function () {\n        return this.timeModification;\n    };\n\n    /**\n     * Get type\n     *\n     * @method getType\n     * @returns {String}\n     */\n    MusicNote.prototype.getType = function () {\n        return this.type;\n    };\n\n    /**\n     * Get decorations\n     *\n     * @method getDecorations\n     * @returns {MusicDecoration[]}\n     */\n    MusicNote.prototype.getDecorations = function () {\n        return this.decorations;\n    };\n\n    /**\n     * Get beam types\n     *\n     * @method getBeamTypes\n     * @returns {Array}\n     */\n    MusicNote.prototype.getBeamTypes = function () {\n        return this.beamTypes;\n    };\n\n    /**\n     * Get ledger lines\n     *\n     * @method getLedgerLines\n     * @returns {MusicLedgerLine[]}\n     */\n    MusicNote.prototype.getLedgerLines = function () {\n        return this.ledgerLines;\n    };\n\n    /**\n     * Get start slurs\n     *\n     * @method getStartSlurs\n     * @returns {MusicSlur[]}\n     */\n    MusicNote.prototype.getStartSlurs = function () {\n        return this.startSlurs;\n    };\n\n    /**\n     * Get stop slurs\n     *\n     * @method getStopSlurs\n     * @returns {MusicSlur[]}\n     */\n    MusicNote.prototype.getStopSlurs = function () {\n        return this.stopSlurs;\n    };\n\n    // Export\n    scope.MusicNote = MusicNote;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Music part\n     *\n     * @class MusicPart\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicPart(obj) {\n        this.elements = [];\n        if (obj) {\n            for (var i in obj.elements) {\n                switch (obj.elements[i].elementType) {\n                    case 'accidental':\n                        this.elements.push(new scope.MusicAccidental(obj.elements[i]));\n                        break;\n                    case 'annotation':\n                        this.elements.push(new scope.MusicAnnotation(obj.elements[i]));\n                        break;\n                    case 'arpeggiate':\n                        this.elements.push(new scope.MusicArpeggiate(obj.elements[i]));\n                        break;\n                    case 'bar':\n                        this.elements.push(new scope.MusicBar(obj.elements[i]));\n                        break;\n                    case 'beam':\n                        this.elements.push(new scope.MusicBeam(obj.elements[i]));\n                        break;\n                    case 'chord':\n                        this.elements.push(new scope.MusicChord(obj.elements[i]));\n                        break;\n                    case 'clef':\n                        this.elements.push(new scope.MusicClef(obj.elements[i]));\n                        break;\n                    case 'decoration':\n                        this.elements.push(new scope.MusicDecoration(obj.elements[i]));\n                        break;\n                    case 'dots':\n                        this.elements.push(new scope.MusicDots(obj.elements[i]));\n                        break;\n                    case 'head':\n                        this.elements.push(new scope.MusicHead(obj.elements[i]));\n                        break;\n                    case 'keySignature':\n                        this.elements.push(new scope.MusicKeySignature(obj.elements[i]));\n                        break;\n                    case 'ledgerLine':\n                        this.elements.push(new scope.MusicLedgerLine(obj.elements[i]));\n                        break;\n                    case 'note':\n                        this.elements.push(new scope.MusicNote(obj.elements[i]));\n                        break;\n                    case 'rest':\n                        this.elements.push(new scope.MusicRest(obj.elements[i]));\n                        break;\n                    case 'slur':\n                        this.elements.push(new scope.MusicSlur(obj.elements[i]));\n                        break;\n                    case 'stem':\n                        this.elements.push(new scope.MusicStem(obj.elements[i]));\n                        break;\n                    case 'tie':\n                        this.elements.push(new scope.MusicTie(obj.elements[i]));\n                        break;\n                    case 'timeSignature':\n                        this.elements.push(new scope.MusicTimeSignature(obj.elements[i]));\n                        break;\n                    case 'tuplet':\n                        this.elements.push(new scope.MusicTuplet(obj.elements[i]));\n                        break;\n                    case 'tupletBracket':\n                        this.elements.push(new scope.MusicTupletBracket(obj.elements[i]));\n                        break;\n                    default:\n                        throw new Error('Unknown music element');\n                }\n            }\n        }\n    }\n\n    /**\n     * Get elements\n     *\n     * @method getElements\n     * @returns {MusicElement[]}\n     */\n    MusicPart.prototype.getElements = function () {\n        return this.elements;\n    };\n\n    // Export\n    scope.MusicPart = MusicPart;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Music pitch data\n     *\n     * @class MusicPitchData\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicPitchData(obj) {\n        if (obj) {\n            this.alteration = obj.alteration;\n            this.octave = obj.octave;\n            this.step = obj.step;\n        }\n    }\n\n    /**\n     * Get alteration\n     *\n     * @method getAlteration\n     * @returns {Number}\n     */\n    MusicPitchData.prototype.getAlteration = function () {\n        return this.alteration;\n    };\n\n    /**\n     * Get octave\n     *\n     * @method getOctave\n     * @returns {Number}\n     */\n    MusicPitchData.prototype.getOctave = function () {\n        return this.octave;\n    };\n\n    /**\n     * Get step\n     *\n     * @method getStep\n     * @returns {String}\n     */\n    MusicPitchData.prototype.getStep = function () {\n        return this.step;\n    };\n\n    // Export\n    scope.MusicPitchData = MusicPitchData;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Music rest\n     *\n     * @class MusicRest\n     * @extends MusicElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicRest(obj) {\n        scope.MusicElement.call(this, obj);\n        this.decorations = [];\n        this.startSlurs = [];\n        this.stopSlurs = [];\n        if (obj) {\n            this.type = obj.type;\n            this.dots = new scope.MusicDots(obj.dots);\n            this.startTuplet = new scope.MusicTuplet(obj.startTuplet);\n            this.stopTuplet = new scope.MusicTuplet(obj.stopTuplet);\n            this.timeModification = new scope.MusicTimeModificationData(obj.timeModification);\n            this.duration = obj.duration;\n            for (var i in obj.decorations) {\n                this.decorations.push(new scope.MusicDecoration(obj.decorations[i]));\n            }\n            for (var l in obj.startSlurs) {\n                this.startSlurs.push(new scope.MusicSlur(obj.startSlurs[l]));\n            }\n            for (var m in obj.stopSlurs) {\n                this.stopSlurs.push(new scope.MusicSlur(obj.stopSlurs[m]));\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicRest.prototype = new scope.MusicElement();\n\n    /**\n     * Constructor property\n     */\n    MusicRest.prototype.constructor = MusicRest;\n\n    /**\n     * Get type\n     *\n     * @method getType\n     * @returns {String}\n     */\n    MusicRest.prototype.getType = function () {\n        return this.type;\n    };\n\n    /**\n     * Get dots\n     *\n     * @method getDots\n     * @returns {MusicDots}\n     */\n    MusicRest.prototype.getDots = function () {\n        return this.dots;\n    };\n\n    /**\n     * Get start tuplet\n     *\n     * @method getStartTuplet\n     * @returns {MusicTuplet}\n     */\n    MusicRest.prototype.getStartTuplet = function () {\n        return this.startTuplet;\n    };\n\n    /**\n     * Get stop tuplet\n     *\n     * @method getStopTuplet\n     * @returns {MusicTuplet}\n     */\n    MusicRest.prototype.getStopTuplet = function () {\n        return this.stopTuplet;\n    };\n\n    /**\n     * Get time modification\n     *\n     * @method getTimeModification\n     * @returns {MusicTimeModificationData}\n     */\n    MusicRest.prototype.getTimeModification = function () {\n        return this.timeModification;\n    };\n\n    /**\n     * Get duration\n     *\n     * @method getDuration\n     * @returns {Number}\n     */\n    MusicRest.prototype.getDuration = function () {\n        return this.duration;\n    };\n\n    /**\n     * Get decorations\n     *\n     * @method getDecorations\n     * @returns {MusicDecoration[]}\n     */\n    MusicRest.prototype.getDecorations = function () {\n        return this.decorations;\n    };\n\n    /**\n     * Get start slurs\n     *\n     * @method getStartSlurs\n     * @returns {MusicSlur[]}\n     */\n    MusicRest.prototype.getStartSlurs = function () {\n        return this.startSlurs;\n    };\n\n    /**\n     * Get stop slurs\n     *\n     * @method getStopSlurs\n     * @returns {MusicSlur[]}\n     */\n    MusicRest.prototype.getStopSlurs = function () {\n        return this.stopSlurs;\n    };\n\n    // Export\n    scope.MusicRest = MusicRest;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Music result\n     *\n     * @class MusicResult\n     * @extends AbstractResult\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicResult(obj) {\n        scope.AbstractResult.call(this, obj);\n        if (obj) {\n            this.result = new scope.MusicDocument(obj.result);\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicResult.prototype = new scope.AbstractResult();\n\n    /**\n     * Constructor property\n     */\n    MusicResult.prototype.constructor = MusicResult;\n\n    // Export\n    scope.MusicResult = MusicResult;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * Music score\n     *\n     * @class MusicScore\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicScore(obj) {\n        this.parts = [];\n        if (obj) {\n            for (var i in obj.parts) {\n                this.parts.push(new scope.MusicPart(obj.parts[i]));\n            }\n        }\n    }\n\n    /**\n     * Get parts\n     *\n     * @method getParts\n     * @returns {MusicPart[]}\n     */\n    MusicScore.prototype.getParts = function () {\n        return this.parts;\n    };\n\n    // Export\n    scope.MusicScore = MusicScore;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Music score tree\n     *\n     * @class MusicScoreTreeResultElement\n     * @extends MusicResultElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicScoreTreeResultElement(obj) {\n        scope.MusicResultElement.call(this, obj);\n        if (obj) {\n            this.score = new scope.MusicScore(obj.score);\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicScoreTreeResultElement.prototype = new scope.MusicResultElement();\n\n    /**\n     * Constructor property\n     */\n    MusicScoreTreeResultElement.prototype.constructor = MusicScoreTreeResultElement;\n\n    /**\n     * Get score\n     *\n     * @method getScore\n     * @returns {MusicScore}\n     */\n    MusicScoreTreeResultElement.prototype.getScore = function () {\n        return this.score;\n    };\n\n    // Export\n    scope.MusicScoreTreeResultElement = MusicScoreTreeResultElement;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Music scratch-out\n     *\n     * @class MusicScratchOut\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicScratchOut(obj) {\n        this.inputRanges = [];\n        this.erasedInputRanges = [];\n        if (obj) {\n            for (var i in obj.inputRanges) {\n                this.inputRanges.push(new scope.MusicInputRange(obj.inputRanges[i]));\n            }\n            for (var j in obj.erasedInputRanges) {\n                this.erasedInputRanges.push(new scope.MusicInputRange(obj.erasedInputRanges[j]));\n            }\n        }\n    }\n\n    /**\n     * Get input ranges\n     *\n     * @method getInputRanges\n     * @returns {MusicInputRange[]}\n     */\n    MusicScratchOut.prototype.getInputRanges = function () {\n        return this.inputRanges;\n    };\n\n    /**\n     * Get erased input ranges\n     *\n     * @method getErasedInputRanges\n     * @returns {MusicInputRange[]}\n     */\n    MusicScratchOut.prototype.getErasedInputRanges = function () {\n        return this.erasedInputRanges;\n    };\n\n    // Export\n    scope.MusicScratchOut = MusicScratchOut;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Music slur\n     *\n     * @class MusicSlur\n     * @extends MusicElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicSlur(obj) {\n        scope.MusicElement.call(this, obj);\n        if (obj) {\n            this.placement = obj.placement;\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicSlur.prototype = new scope.MusicElement();\n\n    /**\n     * Constructor property\n     */\n    MusicSlur.prototype.constructor = MusicSlur;\n\n    /**\n     * Get placement\n     *\n     * @method getPlacement\n     * @returns {String}\n     */\n    MusicSlur.prototype.getPlacement = function () {\n        return this.placement;\n    };\n\n    // Export\n    scope.MusicSlur = MusicSlur;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Music stem\n     *\n     * @class MusicStem\n     * @extends MusicElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicStem(obj) {\n        scope.MusicElement.call(this, obj);\n        if (obj) {\n            this.type = obj.type;\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicStem.prototype = new scope.MusicElement();\n\n    /**\n     * Constructor property\n     */\n    MusicStem.prototype.constructor = MusicStem;\n\n    /**\n     * Get type\n     *\n     * @method getType\n     * @returns {String}\n     */\n    MusicStem.prototype.getType = function () {\n        return this.type;\n    };\n\n    // Export\n    scope.MusicStem = MusicStem;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Music tie\n     *\n     * @class MusicTie\n     * @extends MusicElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicTie(obj) {\n        scope.MusicElement.call(this, obj);\n        if (obj) {\n            this.placement = obj.placement;\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicTie.prototype = new scope.MusicElement();\n\n    /**\n     * Constructor property\n     */\n    MusicTie.prototype.constructor = MusicTie;\n\n    /**\n     * Get placement\n     *\n     * @method getPlacement\n     * @returns {String}\n     */\n    MusicTie.prototype.getPlacement = function () {\n        return this.placement;\n    };\n\n    // Export\n    scope.MusicTie = MusicTie;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Music time modification data\n     *\n     * @class MusicTimeModificationData\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicTimeModificationData(obj) {\n        if (obj) {\n            this.actual = obj.actual;\n            this.dots = obj.dots;\n            this.normal = obj.normal;\n            this.type = obj.type;\n        }\n    }\n\n    /**\n     * Get actual\n     *\n     * @method getActual\n     * @returns {Number}\n     */\n    MusicTimeModificationData.prototype.getActual = function () {\n        return this.actual;\n    };\n\n    /**\n     * Get dots\n     *\n     * @method getDots\n     * @returns {Number}\n     */\n    MusicTimeModificationData.prototype.getDots = function () {\n        return this.dots;\n    };\n\n    /**\n     * Get normal\n     *\n     * @method getNormal\n     * @returns {Number}\n     */\n    MusicTimeModificationData.prototype.getNormal = function () {\n        return this.normal;\n    };\n\n    /**\n     * Get type\n     *\n     * @method getType\n     * @returns {String}\n     */\n    MusicTimeModificationData.prototype.getType = function () {\n        return this.type;\n    };\n\n    // Export\n    scope.MusicTimeModificationData = MusicTimeModificationData;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Music time signature\n     *\n     * @class MusicTimeSignature\n     * @extends MusicElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicTimeSignature(obj) {\n        scope.MusicElement.call(this, obj);\n        if (obj) {\n            this.top = new scope.MusicAnnotation(obj.top);\n            this.bottom = new scope.MusicAnnotation(obj.bottom);\n            this.type = obj.type;\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicTimeSignature.prototype = new scope.MusicElement();\n\n    /**\n     * Constructor property\n     */\n    MusicTimeSignature.prototype.constructor = MusicTimeSignature;\n\n    /**\n     * Get top\n     *\n     * @method getTop\n     * @returns {MusicAnnotation}\n     */\n    MusicTimeSignature.prototype.getTop = function () {\n        return this.top;\n    };\n\n    /**\n     * Get bottom\n     *\n     * @method getBottom\n     * @returns {MusicAnnotation}\n     */\n    MusicTimeSignature.prototype.getBottom = function () {\n        return this.bottom;\n    };\n\n    /**\n     * Get type\n     *\n     * @method getType\n     * @returns {String}\n     */\n    MusicTimeSignature.prototype.getType = function () {\n        return this.type;\n    };\n\n    // Export\n    scope.MusicTimeSignature = MusicTimeSignature;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Music tuplet bracket\n     *\n     * @class MusicTupletBracket\n     * @extends MusicElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicTupletBracket(obj) {\n        scope.MusicElement.call(this, obj);\n        if (obj) {\n            this.type = obj.type;\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicTupletBracket.prototype = new scope.MusicElement();\n\n    /**\n     * Constructor property\n     */\n    MusicTupletBracket.prototype.constructor = MusicTupletBracket;\n\n    /**\n     * Get type\n     *\n     * @method getType\n     * @returns {String}\n     */\n    MusicTupletBracket.prototype.getType = function () {\n        return this.type;\n    };\n\n    // Export\n    scope.MusicTupletBracket = MusicTupletBracket;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Music tuplet\n     *\n     * @class MusicTuplet\n     * @extends MusicElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicTuplet(obj) {\n        scope.MusicElement.call(this, obj);\n        this.brackets = [];\n        if (obj) {\n            this.placement = obj.placement;\n            this.number = new scope.MusicAnnotation(obj.number);\n            for (var i in obj.brackets) {\n                this.brackets.push(new scope.MusicTupletBracket(obj.brackets[i]));\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicTuplet.prototype = new scope.MusicElement();\n\n    /**\n     * Constructor property\n     */\n    MusicTuplet.prototype.constructor = MusicTuplet;\n\n    /**\n     * Get placement\n     *\n     * @method getPlacement\n     * @returns {String}\n     */\n    MusicTuplet.prototype.getPlacement = function () {\n        return this.placement;\n    };\n\n    /**\n     * Get number\n     *\n     * @method getNumber\n     * @returns {MusicAnnotation}\n     */\n    MusicTuplet.prototype.getNumber = function () {\n        return this.number;\n    };\n\n    /**\n     * Get brackets\n     *\n     * @method getBrackets\n     * @returns {Array}\n     */\n    MusicTuplet.prototype.getBrackets = function () {\n        return this.brackets;\n    };\n\n    // Export\n    scope.MusicTuplet = MusicTuplet;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * MusicXML result\n     *\n     * @class MusicXMLResultElement\n     * @extends MusicResultElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicXMLResultElement(obj) {\n        scope.MusicResultElement.call(this, obj);\n        if (obj) {\n            this.value = obj.value;\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicXMLResultElement.prototype = new scope.MusicResultElement();\n\n    /**\n     * Constructor property\n     */\n    MusicXMLResultElement.prototype.constructor = MusicXMLResultElement;\n\n    /**\n     * Get value\n     *\n     * @method getValue\n     * @returns {String}\n     */\n    MusicXMLResultElement.prototype.getValue = function () {\n        return this.value;\n    };\n\n    // Export\n    scope.MusicXMLResultElement = MusicXMLResultElement;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Analyzer element\n     *\n     * @class AnalyzerElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function AnalyzerElement(obj) {\n        if (obj) {\n            this.elementType = obj.elementType;\n        }\n    }\n\n    /**\n     * Get element type\n     *\n     * @method getElementType\n     * @returns {String}\n     */\n    AnalyzerElement.prototype.getElementType = function () {\n        return this.elementType;\n    };\n\n    // Export\n    scope.AnalyzerElement = AnalyzerElement;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Analyzer table cell\n     *\n     * @class AnalyzerCell\n     * @extends AnalyzerElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function AnalyzerCell(obj) {\n        scope.AnalyzerElement.call(this, obj);\n        if (obj) {\n            this.data = new scope.AnalyzerCellData(obj.data);\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    AnalyzerCell.prototype = new scope.AnalyzerElement();\n\n    /**\n     * Constructor property\n     */\n    AnalyzerCell.prototype.constructor = AnalyzerCell;\n\n    /**\n     * Get analyzer cell data\n     *\n     * @method getData\n     * @returns {AnalyzerCellData}\n     */\n    AnalyzerCell.prototype.getData = function () {\n        return this.data;\n    };\n\n    // Export\n    scope.AnalyzerCell = AnalyzerCell;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Analyzer cell data\n     *\n     * @class AnalyzerCellData\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function AnalyzerCellData(obj) {\n        if (obj) {\n            this.firstColumn = obj.firstColumn;\n            this.lastColumn = obj.lastColumn;\n            this.firstRow = obj.firstRow;\n            this.lastRow = obj.lastRow;\n            this.height = obj.height;\n            this.width = obj.width;\n            this.orientation = obj.orientation;\n            this.topLeftPoint = new scope.Point(obj.topLeftPoint);\n            this.topBorder = obj.topBorder;\n            this.bottomBorder = obj.bottomBorder;\n            this.leftBorder = obj.leftBorder;\n            this.rightBorder = obj.rightBorder;\n        }\n    }\n\n    /**\n     * Get first column\n     *\n     * @method getFirstColumn\n     * @returns {Number}\n     */\n    AnalyzerCellData.prototype.getFirstColumn = function () {\n        return this.firstColumn;\n    };\n\n    /**\n     * Get last column\n     *\n     * @method getLastColumn\n     * @returns {Number}\n     */\n    AnalyzerCellData.prototype.getLastColumn = function () {\n        return this.lastColumn;\n    };\n\n    /**\n     * Get first row\n     *\n     * @method getFirstRow\n     * @returns {Number}\n     */\n    AnalyzerCellData.prototype.getFirstRow = function () {\n        return this.firstRow;\n    };\n\n    /**\n     * Get last row\n     *\n     * @method getLastRow\n     * @returns {Number}\n     */\n    AnalyzerCellData.prototype.getLastRow = function () {\n        return this.lastRow;\n    };\n\n    /**\n     * Get height\n     *\n     * @method getHeight\n     * @returns {Number}\n     */\n    AnalyzerCellData.prototype.getHeight = function () {\n        return this.height;\n    };\n\n    /**\n     * Get width\n     *\n     * @method getWidth\n     * @returns {Number}\n     */\n    AnalyzerCellData.prototype.getWidth = function () {\n        return this.width;\n    };\n\n    /**\n     * Get orientation\n     *\n     * @method getOrientation\n     * @returns {String}\n     */\n    AnalyzerCellData.prototype.getOrientation = function () {\n        return this.orientation;\n    };\n\n    /**\n     * Get top-left point\n     *\n     * @method getTopLeftPoint\n     * @returns {Point}\n     */\n    AnalyzerCellData.prototype.getTopLeftPoint = function () {\n        return this.topLeftPoint;\n    };\n\n    /**\n     * Has top border\n     *\n     * @method hasTopBorder\n     * @returns {Boolean}\n     */\n    AnalyzerCellData.prototype.hasTopBorder = function () {\n        return this.topBorder;\n    };\n\n    /**\n     * Has bottom border\n     *\n     * @method hasBottomBorder\n     * @returns {Boolean}\n     */\n    AnalyzerCellData.prototype.hasBottomBorder = function () {\n        return this.bottomBorder;\n    };\n\n    /**\n     * Has left border\n     *\n     * @method hasLeftBorder\n     * @returns {Boolean}\n     */\n    AnalyzerCellData.prototype.hasLeftBorder = function () {\n        return this.leftBorder;\n    };\n\n    /**\n     * Has right border\n     *\n     * @method hasRightBorder\n     * @returns {Boolean}\n     */\n    AnalyzerCellData.prototype.hasRightBorder = function () {\n        return this.rightBorder;\n    };\n\n    /**\n     * Get bounding box\n     *\n     * @method getBoundingBox\n     * @returns {Rectangle}\n     */\n    AnalyzerCellData.prototype.getBoundingBox = function () {\n        var rectangle = new scope.Rectangle();\n        rectangle.setTopLeftPoint(this.getTopLeftPoint());\n        rectangle.setWidth(this.getWidth());\n        rectangle.setHeight(this.getHeight());\n        return rectangle;\n    };\n\n    // Export\n    scope.AnalyzerCellData = AnalyzerCellData;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Analyzer document\n     *\n     * @class AnalyzerDocument\n     * @extends AnalyzerElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function AnalyzerDocument(obj) {\n        scope.AnalyzerElement.call(this, obj);\n        this.textLines = [];\n        this.shapes = [];\n        this.tables = [];\n        this.groups = [];\n        if (obj) {\n            for (var i in obj.textLines) {\n                this.textLines.push(new scope.AnalyzerTextLine(obj.textLines[i]));\n            }\n            for (var j in obj.shapes) {\n                this.shapes.push(new scope.ShapeSegment(obj.shapes[j]));\n            }\n            for (var k in obj.tables) {\n                this.tables.push(new scope.AnalyzerTable(obj.tables[k]));\n            }\n            for (var l in obj.groups) {\n                this.groups.push(new scope.AnalyzerGroup(obj.groups[l]));\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    AnalyzerDocument.prototype = new scope.AnalyzerElement();\n\n    /**\n     * Constructor property\n     */\n    AnalyzerDocument.prototype.constructor = AnalyzerDocument;\n\n    /**\n     * Get text lines\n     *\n     * @method getTextLines\n     * @returns {AnalyzerTextLine[]}\n     */\n    AnalyzerDocument.prototype.getTextLines = function () {\n        return this.textLines;\n    };\n\n    /**\n     * Get shapes\n     *\n     * @method getShapes\n     * @returns {ShapeSegment[]}\n     */\n    AnalyzerDocument.prototype.getShapes = function () {\n        return this.shapes;\n    };\n\n    /**\n     * Get tables\n     *\n     * @method getTables\n     * @returns {AnalyzerTable[]}\n     */\n    AnalyzerDocument.prototype.getTables = function () {\n        return this.tables;\n    };\n\n    /**\n     * Get groups\n     *\n     * @method getGroups\n     * @returns {AnalyzerGroup[]}\n     */\n    AnalyzerDocument.prototype.getGroups = function () {\n        return this.groups;\n    };\n\n    /**\n     * Has scratch-out results\n     *\n     * @method hasScratchOutResults\n     * @returns {Boolean}\n     */\n    AnalyzerDocument.prototype.hasScratchOutResults = function () {\n        for (var i in this.getShapes()) {\n            var currentSeg = this.getShapes()[i];\n            for (var j in currentSeg.getCandidates()) {\n                var currentCandidate = currentSeg.getCandidates()[j];\n                if (currentCandidate instanceof scope.ShapeScratchOut) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    };\n\n    // Export\n    scope.AnalyzerDocument = AnalyzerDocument;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Analyzer element reference\n     *\n     * @class AnalyzerElementReference\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function AnalyzerElementReference(obj) {\n        if (obj) {\n            this.uniqueID = obj.uniqueID;\n            this.type = obj.type;\n        }\n    }\n\n    /**\n     * Get unique id\n     *\n     * @method getUniqueId\n     * @returns {String}\n     */\n    AnalyzerElementReference.prototype.getUniqueId = function () {\n        return this.uniqueID;\n    };\n\n    /**\n     * Get type\n     *\n     * @method getType\n     * @returns {String}\n     */\n    AnalyzerElementReference.prototype.getType = function () {\n        return this.type;\n    };\n\n    // Export\n    scope.AnalyzerElementReference = AnalyzerElementReference;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Analyzer group\n     *\n     * @class AnalyzerGroup\n     * @extends AnalyzerElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function AnalyzerGroup(obj) {\n        scope.AnalyzerElement.call(this, obj);\n        this.elementReferences = [];\n        if (obj) {\n            this.type = obj.type;\n            this.uniqueID = obj.uniqueID;\n            for (var i in obj.elementReferences) {\n                this.elementReferences.push(new scope.AnalyzerElementReference(obj.elementReferences[i]));\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    AnalyzerGroup.prototype = new scope.AnalyzerElement();\n\n    /**\n     * Constructor property\n     */\n    AnalyzerGroup.prototype.constructor = AnalyzerGroup;\n\n    /**\n     * Get element references\n     *\n     * @method getElementReferences\n     * @returns {AnalyzerElementReference[]}\n     */\n    AnalyzerGroup.prototype.getElementReferences = function () {\n        return this.elementReferences;\n    };\n\n    /**\n     * Get type\n     *\n     * @method getType\n     * @returns {String}\n     */\n    AnalyzerGroup.prototype.getType = function () {\n        return this.type;\n    };\n\n    /**\n     * Get unique Id\n     *\n     * @method getUniqueId\n     * @returns {String}\n     */\n    AnalyzerGroup.prototype.getUniqueId = function () {\n        return this.uniqueID;\n    };\n\n    // Export\n    scope.AnalyzerGroup = AnalyzerGroup;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Analyzer ink range\n     *\n     * @class AnalyzerInkRange\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function AnalyzerInkRange(obj) {\n        if (obj) {\n            this.firstPoint = new scope.Point(obj.firstPoint);\n            this.lastPoint = new scope.Point(obj.lastPoint);\n            this.stroke = new scope.AnalyzerRecognizedStroke(obj.stroke);\n        }\n    }\n\n    /**\n     * Get first point\n     *\n     * @method getFirstPoint\n     * @returns {Point}\n     */\n    AnalyzerInkRange.prototype.getFirstPoint = function () {\n        return this.firstPoint;\n    };\n\n    /**\n     * Get last point\n     *\n     * @method getLastPoint\n     * @returns {Point}\n     */\n    AnalyzerInkRange.prototype.getLastPoint = function () {\n        return this.lastPoint;\n    };\n\n    /**\n     * Get stroke\n     *\n     * @method getStroke\n     * @returns {null|*}\n     */\n    AnalyzerInkRange.prototype.getStroke = function () {\n        return this.stroke;\n    };\n\n    // Export\n    scope.AnalyzerInkRange = AnalyzerInkRange;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Analyzer line\n     *\n     * @class AnalyzerLine\n     * @extends AnalyzerElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function AnalyzerLine(obj) {\n        scope.AnalyzerElement.call(this, obj);\n        if (obj) {\n            this.data = new scope.AnalyzerLineData(obj.data);\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    AnalyzerLine.prototype = new scope.AnalyzerElement();\n\n    /**\n     * Constructor property\n     */\n    AnalyzerLine.prototype.constructor = AnalyzerLine;\n\n    /**\n     * Get data\n     *\n     * @method getData\n     * @returns {AnalyzerLineData}\n     */\n    AnalyzerLine.prototype.getData = function () {\n        return this.data;\n    };\n\n    // Export\n    scope.AnalyzerLine = AnalyzerLine;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Analyzer line data\n     *\n     * @class AnalyzerLineData\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function AnalyzerLineData(obj) {\n        if (obj) {\n            this.p1 = new scope.Point(obj.p1);\n            this.p2 = new scope.Point(obj.p2);\n        }\n    }\n\n    /**\n     * Get p1\n     *\n     * @method getP1\n     * @returns {Point}\n     */\n    AnalyzerLineData.prototype.getP1 = function () {\n        return this.p1;\n    };\n\n    /**\n     * Get p2\n     *\n     * @method getP2\n     * @returns {Point}\n     */\n    AnalyzerLineData.prototype.getP2 = function () {\n        return this.p2;\n    };\n\n    // Export\n    scope.AnalyzerLineData = AnalyzerLineData;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * AnalyzerRecognizedStroke\n     *\n     * @class AnalyzerRecognizedStroke\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function AnalyzerRecognizedStroke(obj) {\n        if (obj) {\n            this.type = obj.type;\n            this.x = obj.x;\n            this.y = obj.y;\n        }\n    }\n\n    /**\n     * Get type\n     *\n     * @method getType\n     * @returns {String}\n     */\n    AnalyzerRecognizedStroke.prototype.getType = function () {\n        return this.type;\n    };\n\n    /**\n     * Get x\n     *\n     * @method getX\n     * @returns {Number[]}\n     */\n    AnalyzerRecognizedStroke.prototype.getX = function () {\n        return this.x;\n    };\n\n    /**\n     * Get y\n     *\n     * @method getY\n     * @returns {Number[]}\n     */\n    AnalyzerRecognizedStroke.prototype.getY = function () {\n        return this.y;\n    };\n\n    // Export\n    scope.AnalyzerRecognizedStroke = AnalyzerRecognizedStroke;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Analyzer result\n     *\n     * @class AnalyzerResult\n     * @extends AbstractResult\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function AnalyzerResult(obj) {\n        scope.AbstractResult.call(this, obj);\n        if (obj) {\n            this.result = new scope.AnalyzerDocument(obj.result);\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    AnalyzerResult.prototype = new scope.AbstractResult();\n\n    /**\n     * Constructor property\n     */\n    AnalyzerResult.prototype.constructor = AnalyzerResult;\n\n    // Export\n    scope.AnalyzerResult = AnalyzerResult;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * Analyzer stroke type\n     *\n     * @class AnalyzerStrokeType\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function AnalyzerStrokeType(obj) {\n        if (obj) {\n            this.inkRange = new scope.AnalyzerInkRange(obj.inkRange);\n            this.type = obj.type;\n        }\n    }\n\n    /**\n     * Get ink range\n     *\n     * @method getInkRange\n     * @returns {AnalyzerInkRange}\n     */\n    AnalyzerStrokeType.prototype.getInkRange = function () {\n        return this.inkRange;\n    };\n\n    /**\n     * Get type\n     *\n     * @method getType\n     * @returns {String}\n     */\n    AnalyzerStrokeType.prototype.getType = function () {\n        return this.type;\n    };\n\n    // Export\n    scope.AnalyzerStrokeType = AnalyzerStrokeType;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Analyzer table\n     *\n     * @class AnalyzerTable\n     * @extends AnalyzerElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function AnalyzerTable(obj) {\n        scope.AnalyzerElement.call(this, obj);\n        this.lines = [];\n        this.cells = [];\n        this.inkRanges = [];\n        if (obj) {\n            this.data = new scope.AnalyzerTableData(obj.data);\n            for (var i in obj.lines) {\n                this.lines.push(new scope.AnalyzerLine(obj.lines[i]));\n            }\n            for (var j in obj.cells) {\n                this.cells.push(new scope.AnalyzerCell(obj.cells[j]));\n            }\n            for (var k in obj.inkRanges) {\n                this.inkRanges.push(new scope.AnalyzerInkRange(obj.inkRanges[k]));\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    AnalyzerTable.prototype = new scope.AnalyzerElement();\n\n    /**\n     * Constructor property\n     */\n    AnalyzerTable.prototype.constructor = AnalyzerTable;\n\n    /**\n     * Get data\n     *\n     * @method getData\n     * @returns {AnalyzerTableData}\n     */\n    AnalyzerTable.prototype.getData = function () {\n        return this.data;\n    };\n\n    /**\n     * Get lines\n     *\n     * @method getLines\n     * @returns {AnalyzerLine[]}\n     */\n    AnalyzerTable.prototype.getLines = function () {\n        return this.lines;\n    };\n\n    /**\n     * Get cells\n     *\n     * @method getCells\n     * @returns {AnalyzerCell[]}\n     */\n    AnalyzerTable.prototype.getCells = function () {\n        return this.cells;\n    };\n\n    /**\n     * Get ink ranges\n     *\n     * @method getInkRanges\n     * @returns {AnalyzerInkRange[]}\n     */\n    AnalyzerTable.prototype.getInkRanges = function () {\n        return this.inkRanges;\n    };\n\n    // Export\n    scope.AnalyzerTable = AnalyzerTable;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Analyzer table data\n     *\n     * @class AnalyzerTableData\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function AnalyzerTableData(obj) {\n        if (obj) {\n            this.columnCount = obj.columnCount;\n            this.rowCount = obj.rowCount;\n        }\n    }\n\n    /**\n     * Get column count\n     *\n     * @method getColumnCount\n     * @returns {Number}\n     */\n    AnalyzerTableData.prototype.getColumnCount = function () {\n        return this.columnCount;\n    };\n\n    /**\n     * Get row count\n     *\n     * @method getRowCount\n     * @returns {Number}\n     */\n    AnalyzerTableData.prototype.getRowCount = function () {\n        return this.rowCount;\n    };\n\n    // Export\n    scope.AnalyzerTableData = AnalyzerTableData;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Analyzer text line\n     *\n     * @class AnalyzerTextLine\n     * @extends AnalyzerElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function AnalyzerTextLine(obj) {\n        scope.AnalyzerElement.call(this, obj);\n        this.inkRanges = [];\n        this.underlineList = [];\n        if (obj) {\n            this.data = new scope.AnalyzerTextLineData(obj.data);\n            this.result = new scope.TextDocument(obj.result);\n            for (var i in obj.inkRanges) {\n                this.inkRanges.push(new scope.AnalyzerInkRange(obj.inkRanges[i]));\n            }\n            for (var j in obj.underlineList) {\n                this.underlineList.push(new scope.AnalyzerUnderline(obj.underlineList[j]));\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    AnalyzerTextLine.prototype = new scope.AnalyzerElement();\n\n    /**\n     * Constructor property\n     */\n    AnalyzerTextLine.prototype.constructor = AnalyzerTextLine;\n\n    /**\n     * Get data\n     *\n     * @method getData\n     * @returns {AnalyzerTextLineData}\n     */\n    AnalyzerTextLine.prototype.getData = function () {\n        return this.data;\n    };\n\n    /**\n     * Get text document\n     *\n     * @method getTextDocument\n     * @returns {TextDocument}\n     */\n    AnalyzerTextLine.prototype.getTextDocument = function () {\n        return this.result;\n    };\n\n    /**\n     * Get ink ranges\n     *\n     * @method getInkRanges\n     * @returns {AnalyzerInkRange[]}\n     */\n    AnalyzerTextLine.prototype.getInkRanges = function () {\n        return this.inkRanges;\n    };\n\n    /**\n     * Get underline list\n     *\n     * @method getUnderlineList\n     * @returns {AnalyzerUnderline[]}\n     */\n    AnalyzerTextLine.prototype.getUnderlineList = function () {\n        return this.underlineList;\n    };\n\n    // Export\n    scope.AnalyzerTextLine = AnalyzerTextLine;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Analyzer text line data\n     *\n     * @class AnalyzerTextLineData\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function AnalyzerTextLineData(obj) {\n        if (obj) {\n            this.baselinePos = obj.baselinePos;\n            this.toMidline = obj.toMidline;\n            this.orientation = obj.orientation;\n            this.topLeftPoint = new scope.Point(obj.topLeftPoint);\n            this.textHeight = obj.textHeight;\n            this.justificationType = obj.justificationType;\n            this.height = obj.height;\n            this.width = obj.width;\n        }\n    }\n\n    /**\n     * Get baseline position\n     *\n     * @method getBaselinePos\n     * @returns {Number}\n     */\n    AnalyzerTextLineData.prototype.getBaselinePos = function () {\n        return this.baselinePos;\n    };\n\n    /**\n     * Get to midline\n     *\n     * @method getToMidline\n     * @returns {Number}\n     */\n    AnalyzerTextLineData.prototype.getToMidline = function () {\n        return this.toMidline;\n    };\n\n    /**\n     * Get orientation\n     *\n     * @method getOrientation\n     * @returns {String}\n     */\n    AnalyzerTextLineData.prototype.getOrientation = function () {\n        return this.orientation;\n    };\n\n    /**\n     * Get top-left point\n     *\n     * @method getTopLeftPoint\n     * @returns {Point}\n     */\n    AnalyzerTextLineData.prototype.getTopLeftPoint = function () {\n        return this.topLeftPoint;\n    };\n\n    /**\n     * Get text height\n     *\n     * @method getTextHeight\n     * @returns {Number}\n     */\n    AnalyzerTextLineData.prototype.getTextHeight = function () {\n        return this.textHeight;\n    };\n\n    /**\n     * Get justification type\n     *\n     * @method getJustificationType\n     * @returns {String}\n     */\n    AnalyzerTextLineData.prototype.getJustificationType = function () {\n        return this.justificationType;\n    };\n\n    /**\n     * Get height\n     *\n     * @method getHeight\n     * @returns {Number}\n     */\n    AnalyzerTextLineData.prototype.getHeight = function () {\n        return this.height;\n    };\n\n    /**\n     * Get width\n     *\n     * @method getWidth\n     * @returns {Number}\n     */\n    AnalyzerTextLineData.prototype.getWidth = function () {\n        return this.width;\n    };\n\n    /**\n     * Get bounding box\n     *\n     * @method getBoundingBox\n     * @returns {Rectangle}\n     */\n    AnalyzerTextLineData.prototype.getBoundingBox = function () {\n        var rectangle = new scope.Rectangle();\n        if (this.getTopLeftPoint() || this.getWidth() || this.getHeight()) {\n            rectangle.setTopLeftPoint(this.getTopLeftPoint());\n            rectangle.setWidth(this.getWidth());\n            rectangle.setHeight(this.getHeight());\n        }\n        return rectangle;\n    };\n\n    // Export\n    scope.AnalyzerTextLineData = AnalyzerTextLineData;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Analyzer underline\n     *\n     * @class AnalyzerUnderline\n     * @extends AnalyzerElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function AnalyzerUnderline(obj) {\n        scope.AnalyzerElement.call(this, obj);\n        this.inkRanges = [];\n        if (obj) {\n            this.data = new scope.AnalyzerUnderlineData(obj.data);\n            for (var i in obj.inkRanges) {\n                this.inkRanges.push(new scope.AnalyzerInkRange(obj.inkRanges[i]));\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    AnalyzerUnderline.prototype = new scope.AnalyzerElement();\n\n    /**\n     * Constructor property\n     */\n    AnalyzerUnderline.prototype.constructor = AnalyzerUnderline;\n\n    /**\n     * Get data\n     *\n     * @method getData\n     * @returns {AnalyzerUnderlineData}\n     */\n    AnalyzerUnderline.prototype.getData = function () {\n        return this.data;\n    };\n\n    /**\n     * Get ink ranges\n     *\n     * @method getInkRanges\n     * @returns {AnalyzerInkRange[]}\n     */\n    AnalyzerUnderline.prototype.getInkRanges = function () {\n        return this.inkRanges;\n    };\n\n    // Export\n    scope.AnalyzerUnderline = AnalyzerUnderline;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Analyzer underline data\n     *\n     * @class AnalyzerUnderlineData\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function AnalyzerUnderlineData(obj) {\n        if (obj) {\n            this.firstCharacter = obj.firstCharacter;\n            this.lastCharacter = obj.lastCharacter;\n        }\n    }\n\n    /**\n     * Get first character\n     *\n     * @method getFirstCharacter\n     * @returns {Number}\n     */\n    AnalyzerUnderlineData.prototype.getFirstCharacter = function () {\n        return this.firstCharacter;\n    };\n\n    /**\n     * Get last character\n     *\n     * @method getLastCharacter\n     * @returns {Number}\n     */\n    AnalyzerUnderlineData.prototype.getLastCharacter = function () {\n        return this.lastCharacter;\n    };\n\n    // Export\n    scope.AnalyzerUnderlineData = AnalyzerUnderlineData;\n})(MyScript);","'use strict';\n\n(function (scope, Q) {\n    /**\n     * Network interface\n     *\n     * @class NetworkInterface\n     * @constructor\n     */\n    function NetworkInterface() {\n    }\n\n    NetworkInterface.parseURL = function (url) {\n\n        var parser = document.createElement('a'),\n            searchObject = {},\n            queries, split, i;\n        // Let the browser do the work\n        parser.href = url;\n        // Convert query string to object\n        queries = parser.search.replace(/^\\?/, '').split('&');\n        for (i = 0; i < queries.length; i++) {\n            split = queries[i].split('=');\n            searchObject[split[0]] = split[1];\n        }\n        return {\n            protocol: parser.protocol,\n            host: parser.host,\n            hostname: parser.hostname,\n            port: parser.port,\n            pathname: parser.pathname,\n            search: parser.search,\n            searchObject: searchObject,\n            hash: parser.hash\n        };\n    };\n\n    /**\n     * Parse JSON String to Object\n     *\n     * @method parse\n     * @param {Object} req\n     * @returns {Object}\n     */\n    NetworkInterface.parse = function (req) {\n        var result;\n        try {\n            result = JSON.parse(req.responseText);\n        } catch (e) {\n            result = req.responseText;\n        }\n        return result;\n    };\n\n    /**\n     * Transform object data request to a list of parameters\n     *\n     * @method transformRequest\n     * @param {Object} [obj]\n     * @returns {String}\n     */\n    NetworkInterface.transformRequest = function (obj) {\n        var str = [];\n        for (var p in obj) {\n            if ((typeof obj[p] !== 'undefined') &&\n                (typeof obj[p] !== 'function')) {\n                str.push(encodeURIComponent(p) + '=' + encodeURIComponent(obj[p]));\n            }\n        }\n        return str.join('&');\n    };\n\n    /**\n     * Send request to the network and return a promise\n     *\n     * @method xhr\n     * @param {String} type\n     * @param {String} url\n     * @param {Object} data\n     * @returns {Promise}\n     */\n    NetworkInterface.xhr = function (type, url, data) {\n\n        return Q.Promise(function (resolve, reject, notify) {\n\n            function onStateChange() {\n                if (request.readyState === 4) {\n                    if (request.status >= 200 && request.status < 300) {\n                        resolve(NetworkInterface.parse(request));\n                    }\n                }\n            }\n\n            function onLoad() {\n                if (request.status >= 200 && request.status < 300) {\n                    resolve(NetworkInterface.parse(request));\n                } else {\n                    reject(new Error(request.responseText));\n                }\n            }\n\n            function onError() {\n                reject(new Error('Can\\'t XHR ' + url));\n            }\n\n            function onProgress(e) {\n                notify(e.loaded / e.total);\n            }\n\n            var request = new XMLHttpRequest();\n            request.open(type, url, true);\n            request.withCredentials = true;\n            request.setRequestHeader('Accept', 'application/json');\n            request.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded;charset=UTF-8');\n            request.onerror = onError;\n            request.onprogress = onProgress;\n            request.onload = onLoad;\n            request.onreadystatechange = onStateChange;\n            request.send(NetworkInterface.transformRequest(data));\n        });\n    };\n\n    /**\n     * Get request\n     *\n     * @method get\n     * @param {String} src\n     * @param {Object} params\n     * @returns {Promise}\n     */\n    NetworkInterface.get = function (src, params) {\n        if (params) {\n            src += '?' + NetworkInterface.transformRequest(params);\n        }\n        return scope.NetworkInterface.xhr('GET', src, undefined);\n    };\n\n    /**\n     * Put request\n     *\n     * @method put\n     * @param {String} url\n     * @param {Object} data\n     * @returns {Promise}\n     */\n    NetworkInterface.put = function (url, data) {\n        return scope.NetworkInterface.xhr('PUT', url, data);\n    };\n\n    /**\n     * Post request\n     *\n     * @method post\n     * @param {String} url\n     * @param {Object} data\n     * @returns {Promise}\n     */\n    NetworkInterface.post = function (url, data) {\n        return scope.NetworkInterface.xhr('POST', url, data);\n    };\n\n    /**\n     * Delete request\n     *\n     * @method delete\n     * @param {String} url\n     * @param {Object} data\n     * @returns {Promise}\n     */\n    NetworkInterface.delete = function (url, data) {\n        return scope.NetworkInterface.xhr('DELETE', url, data);\n    };\n\n    // Export\n    scope.NetworkInterface = NetworkInterface;\n})(MyScript, Q);\n","'use strict';\n/* jshint ignore:start */\n\n(function (scope, Q) {\n    /**\n     * Network interface\n     *\n     * @class NetworkWSInterface\n     * @constructor\n     */\n    function NetworkWSInterface() {\n    }\n\n    NetworkWSInterface.prototype.setUrl = function (url) {\n        if ((url !== undefined) && (url !== this._url)) {\n            this.close();\n            this._url = url;\n        }\n    };\n\n    NetworkWSInterface.prototype.getUrl = function () {\n        return this._url;\n    };\n\n    NetworkWSInterface.prototype.setCallback = function (callback) {\n        if (callback !== undefined) {\n            this.close();\n            this._callback = callback;\n        }\n    };\n\n    NetworkWSInterface.prototype.getCallback = function () {\n        return this._callback;\n    };\n\n    NetworkWSInterface.prototype.getState = function () {\n        return _getWebSocketState(this._socket);\n    };\n\n    NetworkWSInterface.prototype.isClosed = function () {\n        return this.getState() === 3;\n    };\n\n    NetworkWSInterface.prototype.isClosing = function () {\n        return this.getState() === 2;\n    };\n\n    NetworkWSInterface.prototype.isOpen = function () {\n        return this.getState() === 1;\n    };\n\n    NetworkWSInterface.prototype.isConnecting = function () {\n        return this.getState() === 0;\n    };\n\n    NetworkWSInterface.prototype.open = function () {\n        if (this.getUrl() && this.getCallback() && ((this.getState() < 0) || this.isClosed())) {\n            this._socket = _openWebSocket(this.getUrl(), this.getCallback());\n        }\n    };\n\n    NetworkWSInterface.prototype.close = function (code, reason) {\n        if (this.getState() < 2) {\n            _closeWebSocket(this._socket, code, reason);\n        }\n    };\n\n    NetworkWSInterface.prototype.send = function (request) {\n        var state = _getWebSocketState(this._socket);\n        if (state  === 1) {\n            _sendMessage(this._socket, request);\n        } else {\n            this.open();\n        }\n    };\n\n    /**\n     *\n     * @param url\n     * @param callback\n     * @returns {WebSocket}\n     * @private\n     */\n    var _openWebSocket = function (url, callback) {\n        function onOpen(e) {\n            callback(e);\n        }\n        function onClose(e) {\n            callback(e);\n        }\n        function onError(e) {\n            callback(e);\n        }\n        function onMessage(e) {\n            callback({\n                type: e.type,\n                data: JSON.parse(e.data)\n            });\n        }\n\n        var socket = new WebSocket(url);\n        socket.onopen = onOpen;\n        socket.onclose = onClose;\n        socket.onerror = onError;\n        socket.onmessage = onMessage;\n        return socket;\n    };\n\n    /**\n     *\n     * @param socket\n     * @param code\n     * @param reason\n     * @private\n     */\n    var _closeWebSocket = function (socket, code, reason) {\n        if (socket) {\n            socket.close(code, reason);\n        }\n    };\n\n    /**\n     *\n     * @param socket\n     * @returns {*}\n     * @private\n     */\n    var _getWebSocketState = function (socket) {\n        if (socket) {\n            return socket.readyState;\n        }\n        return -1;\n    };\n\n    /**\n     *\n     * @param socket\n     * @param message\n     * @private\n     */\n    var _sendMessage = function (socket, message) {\n        if (socket) {\n            socket.send(JSON.stringify(message));\n        }\n    };\n\n    // Export\n    scope.NetworkWSInterface = NetworkWSInterface;\n})(MyScript, Q);\n/* jshint ignore:end */\n","'use strict';\n\n(function (scope, CryptoJS) {\n    /**\n     * Abstract recognizer interface\n     *\n     * @class AbstractRecognizer\n     * @param {String} [host='cloud.myscript.com'] Recognition service host\n     * @constructor\n     */\n    function AbstractRecognizer(host) {\n        this.setUrl(this.getProtocol() + 'cloud.myscript.com');\n        if (host) {\n            this.setUrl(this.getProtocol() + host);\n        }\n        this.setSSL(true);\n    }\n\n    AbstractRecognizer.prototype.getProtocol = function() {\n        return this._ssl? 'https://': 'http://';\n    };\n\n    AbstractRecognizer.prototype.getSSL = function() {\n        return this._ssl;\n    };\n\n    AbstractRecognizer.prototype.setSSL = function (ssl) {\n        if (ssl !== undefined) {\n            this._ssl = ssl;\n            this.setUrl(this.getProtocol() + this.getHost());\n        }\n    };\n\n    /**\n     * Get the recognition service host\n     *\n     * @method getHost\n     * @returns {string|String|*}\n     */\n    AbstractRecognizer.prototype.getHost = function() {\n        return scope.NetworkInterface.parseURL(this.getUrl()).host;\n    };\n\n    /**\n     * Set the recognition service host\n     *\n     * @method setHost\n     * @param {String}\n     */\n    AbstractRecognizer.prototype.setHost = function (host) {\n        if (host !== undefined) {\n            this.setUrl(this.getProtocol() + host);\n        }\n    };\n\n    /**\n     * Get the recognition service host\n     *\n     * @method getUrl\n     * @returns {String}\n     */\n    AbstractRecognizer.prototype.getUrl = function() {\n        return this.url;\n    };\n\n    /**\n     * Set the recognition service url\n     *\n     * @method setUrl\n     * @param {String}\n     */\n    AbstractRecognizer.prototype.setUrl = function (url) {\n        if (url !== undefined) {\n            this.url = url;\n        }\n    };\n\n    /**\n     * Get parameters\n     *\n     * @method getParameters\n     * @returns {AbstractParameter}\n     */\n    AbstractRecognizer.prototype.getParameters = function () {\n        return this.parameters;\n    };\n\n    /**\n     * Set parameters\n     *\n     * @method setParameters\n     * @param {AbstractParameter} parameters\n     */\n    AbstractRecognizer.prototype.setParameters = function (parameters) {\n        this.parameters = parameters;\n    };\n\n    /**\n     * Get precision\n     *\n     * @method getPrecision\n     * @returns {Number}\n     */\n    AbstractRecognizer.prototype.getPrecision = function () {\n        return this.precision;\n    };\n\n    /**\n     * Set precision\n     *\n     * @method setPrecision\n     * @param {Number} precision\n     */\n    AbstractRecognizer.prototype.setPrecision = function (precision) {\n        this.precision = precision;\n    };\n\n    /**\n     * Get the recognition languages available for an application and a specific inputMode\n     *\n     * @method getAvailableLanguageList\n     * @param {String} applicationKey\n     * @param {String} inputMode\n     * @returns {Promise}\n     */\n    AbstractRecognizer.prototype.getAvailableLanguageList = function (applicationKey, inputMode) {\n        var data = new scope.RecognitionLanguagesData();\n        data.setApplicationKey(applicationKey);\n        data.setInputMode(inputMode);\n\n        return scope.NetworkInterface.get(this.getUrl() + '/api/v3.0/recognition/rest/text/languages.json', data).then(\n            function success(response) {\n                return response.result;\n            }\n        );\n    };\n\n    /**\n     * Do REST recognition\n     *\n     * @private\n     * @method doRestRecognition\n     * @param {AbstractRecognitionInput} input\n     * @param {String} applicationKey\n     * @param {String} hmacKey\n     * @param {String} instanceId\n     * @returns {Promise}\n     */\n    AbstractRecognizer.prototype.doRestRecognition = function (input, applicationKey, hmacKey, instanceId) {\n        if (input.getComponents) {\n            _filterStrokes(input.getComponents(), this.getPrecision());\n        } else if (input.getInputUnits) {\n            for (var i in input.getInputUnits()) {\n                _filterStrokes(input.getInputUnits()[i].getComponents(), this.getPrecision());\n            }\n        }\n\n        if (input instanceof scope.TextRecognitionInput) {\n            return _doTextRecognition(this.getUrl(), input, applicationKey, hmacKey, instanceId);\n        } else if (input instanceof scope.ShapeRecognitionInput) {\n            return _doShapeRecognition(this.getUrl(), input, applicationKey, hmacKey, instanceId);\n        } else if (input instanceof scope.MathRecognitionInput) {\n            return _doMathRecognition(this.getUrl(), input, applicationKey, hmacKey, instanceId);\n        } else if (input instanceof scope.MusicRecognitionInput) {\n            return _doMusicRecognition(this.getUrl(), input, applicationKey, hmacKey, instanceId);\n        } else if (input instanceof scope.AnalyzerRecognitionInput) {\n            return _doAnalyzerRecognition(this.getUrl(), input, applicationKey, hmacKey, instanceId);\n        } else {\n            throw new Error('not implemented');\n        }\n    };\n\n    /**\n     * Clear REST recognition\n     *\n     * @method clearRestRecognition\n     * @param {String} instanceId\n     * @returns {Promise}\n     */\n    AbstractRecognizer.prototype.clearRestRecognition = function (instanceId) {\n        var data = {\n            instanceSessionId: instanceId\n        };\n        return _clearShapeRecognition(this.getUrl(), data);\n    };\n\n    /**\n     * Do text recognition\n     *\n     * @private\n     * @method _doTextRecognition\n     * @param {String} url\n     * @param {TextRecognitionInput} input\n     * @param {String} applicationKey\n     * @param {String} hmacKey\n     * @param {String} instanceId\n     * @returns {Promise}\n     */\n    var _doTextRecognition = function (url, input, applicationKey, hmacKey, instanceId) {\n        var data = new scope.TextRecognitionData();\n        _fillData(data, input, instanceId, applicationKey, hmacKey);\n\n        return scope.NetworkInterface.post(url + '/api/v3.0/recognition/rest/text/doSimpleRecognition.json', data).then(\n            function success(response) {\n                return new scope.TextResult(response);\n            }\n        );\n    };\n\n    /**\n     * Do shape recognition\n     *\n     * @private\n     * @method _doShapeRecognition\n     * @param {String} url\n     * @param {ShapeRecognitionInput} input\n     * @param {String} applicationKey\n     * @param {String} hmacKey\n     * @param {String} instanceId\n     * @returns {Promise}\n     */\n    var _doShapeRecognition = function (url, input, applicationKey, hmacKey, instanceId) {\n        var data = new scope.ShapeRecognitionData();\n        _fillData(data, input, instanceId, applicationKey, hmacKey);\n\n        return scope.NetworkInterface.post(url + '/api/v3.0/recognition/rest/shape/doSimpleRecognition.json', data).then(\n            function success(response) {\n                return new scope.ShapeResult(response);\n            }\n        );\n    };\n\n    /**\n     * Clear shape recognition\n     *\n     * @private\n     * @method _clearShapeRecognition\n     * @param {String} url\n     * @param {String} instanceId\n     * @returns {Promise}\n     */\n    var _clearShapeRecognition = function (url, instanceId) {\n        var data = {\n            instanceSessionId: instanceId\n        };\n\n        return scope.NetworkInterface.post(url + '/api/v3.0/recognition/rest/shape/clearSessionId.json', data).then(\n            function success(response) {\n                return new scope.ShapeResult(response);\n            }\n        );\n    };\n\n    /**\n     * Do shape recognition\n     *\n     * @private\n     * @method _doMathRecognition\n     * @param {String} url\n     * @param {MathRecognitionInput} input\n     * @param {String} applicationKey\n     * @param {String} hmacKey\n     * @param {String} instanceId\n     * @returns {Promise}\n     */\n    var _doMathRecognition = function (url, input, applicationKey, hmacKey, instanceId) {\n        var data = new scope.MathRecognitionData();\n        _fillData(data, input, instanceId, applicationKey, hmacKey);\n\n        return scope.NetworkInterface.post(url + '/api/v3.0/recognition/rest/math/doSimpleRecognition.json', data).then(\n            function success(response) {\n                return new scope.MathResult(response);\n            }\n        );\n    };\n\n    /**\n     * Do music recognition\n     *\n     * @private\n     * @method _doMusicRecognition\n     * @param {String} url\n     * @param {MusicRecognitionInput} input\n     * @param {String} applicationKey\n     * @param {String} hmacKey\n     * @param {String} instanceId\n     * @returns {Promise}\n     */\n    var _doMusicRecognition = function (url, input, applicationKey, hmacKey, instanceId) {\n        var data = new scope.MusicRecognitionData();\n        _fillData(data, input, instanceId, applicationKey, hmacKey);\n\n        return scope.NetworkInterface.post(url + '/api/v3.0/recognition/rest/music/doSimpleRecognition.json', data).then(\n            function success(response) {\n                return new scope.MusicResult(response);\n            }\n        );\n    };\n\n    /**\n     * Do analyzer recognition\n     *\n     * @method _doAnalyzerRecognition\n     * @param {String} url\n     * @param {AnalyzerRecognitionInput} input\n     * @param {String} applicationKey\n     * @param {String} hmacKey\n     * @param {String} instanceId\n     * @returns {Promise}\n     */\n    var _doAnalyzerRecognition = function (url, input, applicationKey, hmacKey, instanceId) {\n        var data = new scope.AnalyzerRecognitionData();\n        _fillData(data, input, instanceId, applicationKey, hmacKey);\n\n        return scope.NetworkInterface.post(url + '/api/v3.0/recognition/rest/analyzer/doSimpleRecognition.json', data).then(\n            function success(response) {\n                return new scope.AnalyzerResult(response);\n            }\n        );\n    };\n\n    /**\n     * Compute HMAC signature for server authentication\n     *\n     * @private\n     * @method _computeHmac\n     * @param {AbstractRecognitionInput} input\n     * @param {String} applicationKey\n     * @param {String} hmacKey\n     */\n    var _computeHmac = function (input, applicationKey, hmacKey) {\n        var jsonInput = (typeof input === 'object') ? JSON.stringify(input) : input;\n        return CryptoJS.HmacSHA512(jsonInput, applicationKey + hmacKey).toString(CryptoJS.enc.Hex);\n    };\n\n    var _filterStrokes = function (components, precision) {\n        components.forEach(function (currentValue) {\n            if (currentValue instanceof scope.StrokeComponent) {\n                currentValue.toFixed(precision);\n            }\n        });\n    };\n\n    var _fillData = function (data, input, instanceId, applicationKey, hmacKey) {\n        data.setRecognitionInput(input);\n        data.setApplicationKey(applicationKey);\n        data.setInstanceId(instanceId);\n        if (hmacKey) {\n            data.setHmac(_computeHmac(data.getRecognitionInput(), applicationKey, hmacKey));\n        }\n    };\n\n    // Export\n    scope.AbstractRecognizer = AbstractRecognizer;\n})(MyScript, CryptoJS);\n","'use strict';\n\n(function (scope, CryptoJS) {\n    /**\n     * Abstract WebSocket recognizer interface\n     *\n     * @class AbstractWSRecognizer\n     * @constructor\n     */\n    function AbstractWSRecognizer() {\n        this._wsInterface = new scope.NetworkWSInterface();\n    }\n\n    AbstractWSRecognizer.prototype.getProtocol = function() {\n        return this._ssl? 'wss://': 'ws://';\n    };\n\n    AbstractWSRecognizer.prototype.getSSL = function() {\n        return this._ssl;\n    };\n\n    AbstractWSRecognizer.prototype.setSSL = function (ssl) {\n        if (ssl !== undefined) {\n            this._ssl = ssl;\n            this.setUrl(this.getProtocol() + this.getHost());\n        }\n    };\n\n    /**\n     * Get the recognition service host\n     *\n     * @method getHost\n     * @returns {string|String|*}\n     */\n    AbstractWSRecognizer.prototype.getHost = function() {\n        return scope.NetworkInterface.parseURL(this.getUrl()).host;\n    };\n\n    /**\n     * Set the recognition service host\n     *\n     * @method setHost\n     * @param {String}\n     */\n    AbstractWSRecognizer.prototype.setHost = function (host) {\n        if ((host !== undefined) && (host != this.getHost())) {\n            this.setUrl(this.getProtocol() + host);\n        }\n    };\n\n    AbstractWSRecognizer.prototype.setUrl = function (url) { // jshint ignore:line\n        throw new Error('not implemented');\n    };\n\n    AbstractWSRecognizer.prototype.getUrl = function () {\n        return this._wsInterface.getUrl();\n    };\n\n    AbstractWSRecognizer.prototype.setCallback = function (callback) { // jshint ignore:line\n        throw new Error('not implemented');\n    };\n\n    /**\n     * Get parameters\n     *\n     * @method getParameters\n     * @returns {AbstractParameter}\n     */\n    AbstractWSRecognizer.prototype.getParameters = function () {\n        return this.parameters;\n    };\n\n    /**\n     * Set parameters\n     *\n     * @method setParameters\n     * @param {AbstractParameter} parameters\n     */\n    AbstractWSRecognizer.prototype.setParameters = function (parameters) {\n        this.parameters = parameters;\n    };\n\n    /**\n     * Get precision\n     *\n     * @method getPrecision\n     * @returns {Number}\n     */\n    AbstractWSRecognizer.prototype.getPrecision = function () {\n        return this.precision;\n    };\n\n    /**\n     * Set precision\n     *\n     * @method setPrecision\n     * @param {Number} precision\n     */\n    AbstractWSRecognizer.prototype.setPrecision = function (precision) {\n        this.precision = precision;\n    };\n\n    AbstractWSRecognizer.prototype.isClosed = function () {\n        return this._wsInterface.isClosed();\n    };\n\n    AbstractWSRecognizer.prototype.isClosing = function () {\n        return this._wsInterface.isClosing();\n    };\n\n    AbstractWSRecognizer.prototype.isOpen = function () {\n        return this._wsInterface.isOpen();\n    };\n\n    AbstractWSRecognizer.prototype.isConnecting = function () {\n        return this._wsInterface.isConnecting();\n    };\n\n    /**\n     * Open the socket\n     *\n     * @method open\n     */\n    AbstractWSRecognizer.prototype.open = function () {\n        this._wsInterface.open();\n    };\n\n    /**\n     * Close the socket\n     *\n     * @method close\n     */\n    AbstractWSRecognizer.prototype.close = function () {\n        this._wsInterface.close();\n    };\n\n    /**\n     * Send a message\n     *\n     * @method sendMessage\n     * @param {AbstractWSMessage} message\n     */\n    AbstractWSRecognizer.prototype.sendMessage = function (message) {\n        if (message.getComponents) {\n            _filterStrokes(message.getComponents(), this.getPrecision());\n        } else if (message.getInputUnits) {\n            for (var i in message.getInputUnits()) {\n                _filterStrokes(message.getInputUnits()[i].getComponents(), this.getPrecision());\n            }\n        }\n        this._wsInterface.send(message);\n    };\n\n    /**\n     * Initialize the WebSocket\n     *\n     * @method initWSRecognition\n     * @param {String} applicationKey\n     */\n    AbstractWSRecognizer.prototype.initWSRecognition = function (applicationKey) {\n        var message = new scope.InitRequestWSMessage();\n        message.setApplicationKey(applicationKey);\n        this.sendMessage(message);\n    };\n\n    /**\n     * Authenticate the WebSocket client end with a handshake of HMAC signature\n     *\n     * @method takeUpHmacChallenge\n     * @param {String} applicationKey\n     * @param {String} challenge\n     * @param {String} hmacKey\n     */\n    AbstractWSRecognizer.prototype.takeUpHmacChallenge = function (applicationKey, challenge, hmacKey) {\n        var message = new scope.ChallengeRequestWSMessage();\n        message.setApplicationKey(applicationKey);\n        message.setChallenge(challenge);\n        if (hmacKey) {\n            message.setHmacSignature(_computeHmac(challenge, applicationKey, hmacKey));\n        }\n        this.sendMessage(message);\n    };\n\n    /**\n     * Reset the WebSocket recognition session\n     *\n     * @method resetWSRecognition\n     */\n    AbstractWSRecognizer.prototype.resetWSRecognition = function () {\n        var message = new scope.ResetRequestWSMessage();\n        this.sendMessage(message);\n    };\n\n    /**\n     * Compute HMAC signature for server authentication\n     *\n     * @private\n     * @method _computeHmac\n     * @param {String} input\n     * @param {String} applicationKey\n     * @param {String} hmacKey\n     */\n    var _computeHmac = function (input, applicationKey, hmacKey) {\n        var jsonInput = (typeof input === 'object') ? JSON.stringify(input) : input;\n        return CryptoJS.HmacSHA512(jsonInput, applicationKey + hmacKey).toString(CryptoJS.enc.Hex);\n    };\n\n    var _filterStrokes = function (components, precision) {\n        components.forEach(function (currentValue) {\n            if (currentValue instanceof scope.StrokeComponent) {\n                currentValue.toFixed(precision);\n            }\n        });\n    };\n\n    // Export\n    scope.AbstractWSRecognizer = AbstractWSRecognizer;\n})(MyScript, CryptoJS);\n","'use strict';\n\n(function (scope) {\n    /**\n     * Text recognizer interface\n     *\n     * @class TextRecognizer\n     * @extends AbstractRecognizer\n     * @param {String} [host='cloud.myscript.com'] Recognition service host\n     * @constructor\n     */\n    function TextRecognizer(host) {\n        scope.AbstractRecognizer.call(this, host);\n        this.parameters = new scope.TextParameter();\n        this.parameters.setLanguage('en_US');\n        this.parameters.setInputMode('CURSIVE');\n    }\n\n    /**\n     * Inheritance property\n     */\n    TextRecognizer.prototype = new scope.AbstractRecognizer();\n\n    /**\n     * Constructor property\n     */\n    TextRecognizer.prototype.constructor = TextRecognizer;\n\n    /**\n     * Do text recognition\n     *\n     * @method doSimpleRecognition\n     * @param {String} applicationKey\n     * @param {String} instanceId\n     * @param {AbstractComponent[]|TextInputUnit[]} components\n     * @param {String} hmacKey\n     * @param {TextParameter} [parameters]\n     * @returns {Promise}\n     */\n    TextRecognizer.prototype.doSimpleRecognition = function (applicationKey, instanceId, components, hmacKey, parameters) {\n        var params = this.getParameters();\n        if (parameters) {\n            params = parameters;\n        }\n        var inputUnits = [];\n        if (components && components.length > 0) {\n            if (components[0] instanceof scope.TextInputUnit) {\n                inputUnits = components;\n            } else {\n                var unit = new scope.TextInputUnit();\n                unit.setComponents(components);\n                inputUnits.push(unit);\n            }\n        }\n        var input = new scope.TextRecognitionInput();\n        input.setParameters(params);\n        input.setInputUnits(inputUnits);\n        return scope.AbstractRecognizer.prototype.doRestRecognition.call(this, input, applicationKey, hmacKey, instanceId); // super\n    };\n\n    // Export\n    scope.TextRecognizer = TextRecognizer;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * Text WebSocket recognizer interface\n     *\n     * @class TextWSRecognizer\n     * @extends AbstractWSRecognizer\n     * @param {Function} callback The WebSocket response callback\n     * @param {String} [host='cloud.myscript.com'] Recognition service host\n     * @constructor\n     */\n    function TextWSRecognizer(callback, host) {\n        scope.AbstractWSRecognizer.call(this);\n        this.parameters = new scope.TextParameter();\n        this.parameters.setLanguage('en_US');\n        this.parameters.setInputMode('CURSIVE');\n        this.setUrl(this.getProtocol() + 'cloud.myscript.com');\n        if (host) {\n            this.setUrl(this.getProtocol() + host);\n        }\n        this.setSSL(true);\n        this.setCallback(callback);\n    }\n\n    /**\n     * Inheritance property\n     */\n    TextWSRecognizer.prototype = new scope.AbstractWSRecognizer();\n\n    /**\n     * Constructor property\n     */\n    TextWSRecognizer.prototype.constructor = TextWSRecognizer;\n\n    /**\n     * Get parameters\n     *\n     * @method getParameters\n     * @returns {TextParameter}\n     */\n    TextWSRecognizer.prototype.getParameters = function () {\n        return this.parameters;\n    };\n\n    /**\n     * Set parameters\n     *\n     * @method setParameters\n     * @param {TextParameter} parameters\n     */\n    TextWSRecognizer.prototype.setParameters = function (parameters) {\n        this.parameters = parameters;\n    };\n\n    TextWSRecognizer.prototype.setUrl = function (url) {\n        if (url !== undefined) {\n            this._wsInterface.setUrl(url + '/api/v3.0/recognition/ws/text');\n        }\n    };\n\n    TextWSRecognizer.prototype.setCallback = function (callback) {\n        if (callback !== undefined) {\n            this._wsInterface.setCallback(function (message) {\n                switch (message.type) {\n                    case 'open':\n                        callback(message);\n                        break;\n                    case 'close':\n                        callback(message);\n                        break;\n                    case 'error':\n                        callback(undefined, message);\n                        break;\n                    default:\n                        switch (message.data.type) {\n                            case 'init':\n                                message.data = new scope.InitResponseWSMessage(message.data);\n                                callback(message.data);\n                                break;\n                            case 'reset':\n                                message.data = new scope.ResetResponseWSMessage(message.data);\n                                callback(message.data);\n                                break;\n                            case 'error':\n                                message.data = new scope.ErrorResponseWSMessage(message.data);\n                                callback(undefined, new Error(JSON.stringify(message.data.getError())));\n                                break;\n                            case 'hmacChallenge':\n                                message.data = new scope.ChallengeResponseWSMessage(message.data);\n                                callback(message.data);\n                                break;\n                            default:\n                                message.data = new scope.TextResponseWSMessage(message.data);\n                                callback(message.data);\n                                break;\n                        }\n                        break;\n                }\n            });\n        }\n    };\n\n    /**\n     * Start the WebSocket session\n     *\n     * @method startWSRecognition\n     * @param {AbstractComponent[]|TextInputUnit[]} components\n     * @param {TextParameter} [parameters]\n     */\n    TextWSRecognizer.prototype.startWSRecognition = function (components, parameters) {\n        var message = new scope.TextStartRequestWSMessage();\n        var params = this.getParameters();\n        if (parameters) {\n            params = parameters;\n        }\n        var inputUnits = [];\n        if (components && components.length > 0) {\n            if (components[0] instanceof scope.TextInputUnit) {\n                inputUnits = components;\n            } else {\n                var unit = new scope.TextInputUnit();\n                unit.setComponents(components);\n                inputUnits.push(unit);\n            }\n        }\n        message.setParameters(params);\n        message.setInputUnits(inputUnits);\n        this.sendMessage(message);\n    };\n\n    /**\n     * Continue the recognition\n     *\n     * @method continueWSRecognition\n     * @param {AbstractComponent[]|TextInputUnit[]} components\n     * @param {String} instanceId\n     */\n    TextWSRecognizer.prototype.continueWSRecognition = function (components, instanceId) {\n        var message = new scope.TextContinueRequestWSMessage();\n        var inputUnits = [];\n        if (components && components.length > 0) {\n            if (components[0] instanceof scope.TextInputUnit) {\n                inputUnits = components;\n            } else {\n                var unit = new scope.TextInputUnit();\n                unit.setComponents(components);\n                inputUnits.push(unit);\n            }\n        }\n        message.setInputUnits(inputUnits);\n        message.setInstanceId(instanceId);\n        this.sendMessage(message);\n    };\n\n    // Export\n    scope.TextWSRecognizer = TextWSRecognizer;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * Shape recognizer interface\n     *\n     * @class ShapeRecognizer\n     * @extends AbstractRecognizer\n     * @param {String} [host='cloud.myscript.com'] Recognition service host\n     * @constructor\n     */\n    function ShapeRecognizer(host) {\n        scope.AbstractRecognizer.call(this, host);\n        this.parameters = new scope.ShapeParameter();\n    }\n\n    /**\n     * Inheritance property\n     */\n    ShapeRecognizer.prototype = new scope.AbstractRecognizer();\n\n    /**\n     * Constructor property\n     */\n    ShapeRecognizer.prototype.constructor = ShapeRecognizer;\n\n    /**\n     * Do shape recognition\n     *\n     * @method doSimpleRecognition\n     * @param {String} applicationKey\n     * @param {String} instanceId\n     * @param {AbstractComponent[]} components\n     * @param {String} hmacKey\n     * @param {ShapeParameter} [parameters]\n     * @returns {Promise}\n     */\n    ShapeRecognizer.prototype.doSimpleRecognition = function (applicationKey, instanceId, components, hmacKey, parameters) {\n        var params = this.getParameters();\n        if (parameters) {\n            params = parameters;\n        }\n        var input = new scope.ShapeRecognitionInput();\n        input.setParameters(params);\n        input.setComponents(components);\n        return scope.AbstractRecognizer.prototype.doRestRecognition.call(this, input, applicationKey, hmacKey, instanceId); // super\n    };\n\n    /**\n     * Clear shape recognition session\n     *\n     * @method clearShapeRecognitionSession\n     * @param {String} applicationKey\n     * @param {String} instanceId\n     * @returns {Promise}\n     */\n    ShapeRecognizer.prototype.clearShapeRecognitionSession = function (applicationKey, instanceId) {\n        return scope.AbstractRecognizer.prototype.clearRestRecognition.call(this, instanceId); // super\n    };\n\n    // Export\n    scope.ShapeRecognizer = ShapeRecognizer;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * Math recognizer interface\n     *\n     * @class MathRecognizer\n     * @extends AbstractRecognizer\n     * @param {String} [host='cloud.myscript.com'] Recognition service host\n     * @constructor\n     */\n    function MathRecognizer(host) {\n        scope.AbstractRecognizer.call(this, host);\n        this.parameters = new scope.MathParameter();\n    }\n\n    /**\n     * Inheritance property\n     */\n    MathRecognizer.prototype = new scope.AbstractRecognizer();\n\n    /**\n     * Constructor property\n     */\n    MathRecognizer.prototype.constructor = MathRecognizer;\n\n    /**\n     * Do math recognition\n     *\n     * @method doSimpleRecognition\n     * @param {String} applicationKey\n     * @param {String} instanceId\n     * @param {AbstractComponent[]} components\n     * @param {String} hmacKey\n     * @param {MathParameter} [parameters]\n     * @returns {Promise}\n     */\n    MathRecognizer.prototype.doSimpleRecognition = function (applicationKey, instanceId, components, hmacKey, parameters) {\n        var params = this.getParameters();\n        if (parameters) {\n            params = parameters;\n        }\n        var input = new scope.MathRecognitionInput();\n        input.setParameters(params);\n        input.setComponents(components);\n        return scope.AbstractRecognizer.prototype.doRestRecognition.call(this, input, applicationKey, hmacKey, instanceId); // super\n    };\n\n    // Export\n    scope.MathRecognizer = MathRecognizer;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * Math WebSocket recognizer interface\n     *\n     * @class MathWSRecognizer\n     * @extends AbstractWSRecognizer\n     * @param {Function} callback The WebSocket response callback\n     * @param {String} [host='cloud.myscript.com'] Recognition service host\n     * @constructor\n     */\n    function MathWSRecognizer(callback, host) {\n        scope.AbstractWSRecognizer.call(this);\n        this.parameters = new scope.MathParameter();\n        this.setUrl(this.getProtocol() + 'cloud.myscript.com');\n        if (host) {\n            this.setUrl(this.getProtocol() + host);\n        }\n        this.setSSL(true);\n        this.setCallback(callback);\n    }\n\n    /**\n     * Inheritance property\n     */\n    MathWSRecognizer.prototype = new scope.AbstractWSRecognizer();\n\n    /**\n     * Constructor property\n     */\n    MathWSRecognizer.prototype.constructor = MathWSRecognizer;\n\n    /**\n     * Get parameters\n     *\n     * @method getParameters\n     * @returns {MathParameter}\n     */\n    MathWSRecognizer.prototype.getParameters = function () {\n        return this.parameters;\n    };\n\n    /**\n     * Set parameters\n     *\n     * @method setParameters\n     * @param {MathParameter} parameters\n     */\n    MathWSRecognizer.prototype.setParameters = function (parameters) {\n        this.parameters = parameters;\n    };\n\n    MathWSRecognizer.prototype.setUrl = function (url) {\n        if (url !== undefined) {\n            this._wsInterface.setUrl(url + '/api/v3.0/recognition/ws/math');\n        }\n    };\n\n    MathWSRecognizer.prototype.setCallback = function (callback) {\n        if (callback !== undefined) {\n            this._wsInterface.setCallback(function (message) {\n                switch (message.type) {\n                    case 'open':\n                        callback(message);\n                        break;\n                    case 'close':\n                        callback(message);\n                        break;\n                    case 'error':\n                        callback(undefined, message);\n                        break;\n                    default:\n                        switch (message.data.type) {\n                            case 'init':\n                                message.data = new scope.InitResponseWSMessage(message.data);\n                                callback(message.data);\n                                break;\n                            case 'reset':\n                                message.data = new scope.ResetResponseWSMessage(message.data);\n                                callback(message.data);\n                                break;\n                            case 'error':\n                                message.data = new scope.ErrorResponseWSMessage(message.data);\n                                callback(undefined, new Error(JSON.stringify(message.data.getError())));\n                                break;\n                            case 'hmacChallenge':\n                                message.data = new scope.ChallengeResponseWSMessage(message.data);\n                                callback(message.data);\n                                break;\n                            default:\n                                message.data = new scope.MathResponseWSMessage(message.data);\n                                callback(message.data);\n                                break;\n                        }\n                        break;\n                }\n            });\n        }\n    };\n\n    /**\n     * Start the WebSocket session\n     *\n     * @method startWSRecognition\n     * @param {AbstractComponent[]} components\n     * @param {MathParameter} [parameters]\n     */\n    MathWSRecognizer.prototype.startWSRecognition = function (components, parameters) {\n        var message = new scope.MathStartRequestWSMessage();\n        var params = this.getParameters();\n        if (parameters) {\n            params = parameters;\n        }\n        message.setParameters(params);\n        message.setComponents(components);\n        this.sendMessage(message);\n    };\n\n    /**\n     * Continue the recognition\n     *\n     * @method continueWSRecognition\n     * @param {AbstractComponent[]} components\n     * @param {String} instanceId\n     */\n    MathWSRecognizer.prototype.continueWSRecognition = function (components, instanceId) {\n        var message = new scope.MathContinueRequestWSMessage();\n        message.setComponents(components);\n        message.setInstanceId(instanceId);\n        this.sendMessage(message);\n    };\n\n    // Export\n    scope.MathWSRecognizer = MathWSRecognizer;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * Music recognizer interface\n     *\n     * @class MusicRecognizer\n     * @extends AbstractRecognizer\n     * @param {String} [host='cloud.myscript.com'] Recognition service host\n     * @constructor\n     */\n    function MusicRecognizer(host) {\n        scope.AbstractRecognizer.call(this, host);\n        this.parameters = new scope.MusicParameter();\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicRecognizer.prototype = new scope.AbstractRecognizer();\n\n    /**\n     * Constructor property\n     */\n    MusicRecognizer.prototype.constructor = MusicRecognizer;\n\n    /**\n     * Do music recognition\n     *\n     * @method doSimpleRecognition\n     * @param {String} applicationKey\n     * @param {String} instanceId\n     * @param {AbstractComponent[]} components\n     * @param {String} hmacKey\n     * @param {MusicParameter} [parameters]\n     * @returns {Promise}\n     */\n    MusicRecognizer.prototype.doSimpleRecognition = function (applicationKey, instanceId, components, hmacKey, parameters) {\n        var params = this.getParameters();\n        if (parameters) {\n            params = parameters;\n        }\n        var input = new scope.MusicRecognitionInput();\n        input.setParameters(params);\n        input.setComponents(components);\n        return scope.AbstractRecognizer.prototype.doRestRecognition.call(this, input, applicationKey, hmacKey, instanceId); // super\n    };\n\n    // Export\n    scope.MusicRecognizer = MusicRecognizer;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * Analyzer recognizer interface\n     *\n     * @class AnalyzerRecognizer\n     * @extends AbstractRecognizer\n     * @param {String} [host='cloud.myscript.com'] Recognition service host\n     * @constructor\n     */\n    function AnalyzerRecognizer(host) {\n        scope.AbstractRecognizer.call(this, host);\n        this.parameters = new scope.AnalyzerParameter();\n    }\n\n    /**\n     * Inheritance property\n     */\n    AnalyzerRecognizer.prototype = new scope.AbstractRecognizer();\n\n    /**\n     * Constructor property\n     */\n    AnalyzerRecognizer.prototype.constructor = AnalyzerRecognizer;\n\n    /**\n     * Do analyzer recognition\n     *\n     * @method doSimpleRecognition\n     * @param {String} applicationKey\n     * @param {String} instanceId\n     * @param {AbstractComponent[]} components\n     * @param {String} hmacKey\n     * @param {AnalyzerParameter} [parameters]\n     * @returns {Promise}\n     */\n    AnalyzerRecognizer.prototype.doSimpleRecognition = function (applicationKey, instanceId, components, hmacKey, parameters) {\n        var params = this.getParameters();\n        if (parameters) {\n            params = parameters;\n        }\n        var input = new scope.AnalyzerRecognitionInput();\n        input.setParameters(params);\n        input.setComponents(components);\n        return scope.AbstractRecognizer.prototype.doRestRecognition.call(this, input, applicationKey, hmacKey, instanceId); // super\n    };\n\n    // Export\n    scope.AnalyzerRecognizer = AnalyzerRecognizer;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * Represent the Abstract Renderer. It's used to calculate the ink rendering in HTML5 canvas\n     *\n     * @class AbstractRenderer\n     * @param {Object} context\n     * @constructor\n     */\n    function AbstractRenderer(context) {\n        this.penParameters = new scope.PenParameters();\n        this.showBoundingBoxes = false;\n        this.typeset = true;\n        this.context = context;\n    }\n\n    /**\n     * Get the context\n     *\n     * @returns {Object}\n     */\n    AbstractRenderer.prototype.getContext = function () {\n        return this.context;\n    };\n\n    /**\n     * This property is use to show or not show the bounding box\n     *\n     * @method getShowBoundingBoxes\n     * @returns {Boolean}\n     */\n    AbstractRenderer.prototype.getShowBoundingBoxes = function () {\n        return this.showBoundingBoxes;\n    };\n\n    /**\n     * Set the show state of bounding box\n     *\n     * @method setShowBoundingBoxes\n     * @param {Boolean} showBoundingBoxes\n     */\n    AbstractRenderer.prototype.setShowBoundingBoxes = function (showBoundingBoxes) {\n        this.showBoundingBoxes = showBoundingBoxes;\n    };\n\n    /**\n     * Get the default pen parameters\n     *\n     * @returns {PenParameters}\n     */\n    AbstractRenderer.prototype.getParameters = function () {\n        return this.penParameters;\n    };\n\n    /**\n     * Set the default pen parameters\n     *\n     * @param {PenParameters} penParameters\n     */\n    AbstractRenderer.prototype.setParameters = function (penParameters) {\n        this.penParameters = penParameters;\n    };\n\n    /**\n     * Is typesetting\n     *\n     * @returns {Boolean}\n     */\n    AbstractRenderer.prototype.isTypesetting = function () {\n        return this.typeset;\n    };\n\n    /**\n     * Enable / disable typesetting\n     *\n     * @param {Boolean} typeset\n     */\n    AbstractRenderer.prototype.setTypeset = function (typeset) {\n        this.typeset = typeset;\n    };\n\n    /**\n     * Clear the recognition context\n     *\n     * @method clear\n     */\n    AbstractRenderer.prototype.clear = function () {\n        this.getContext().clearRect(0, 0, this.getContext().canvas.width, this.getContext().canvas.height);\n    };\n\n    /**\n     * Draw recognition result on HTML5 canvas.\n     *\n     * @method drawRecognitionResult\n     * @param {AbstractComponent[]} components\n     * @param {Object} recognitionResult\n     */\n    AbstractRenderer.prototype.drawRecognitionResult = function (components, recognitionResult) { // jshint ignore:line\n        throw new Error('not implemented');\n    };\n\n    /**\n     * Draw input components\n     *\n     * @method drawComponents\n     * @param {AbstractComponent[]} components\n     */\n    AbstractRenderer.prototype.drawComponents = function (components) { // jshint ignore:line\n        throw new Error('not implemented');\n    };\n\n    /**\n     * Draw component\n     *\n     * @method drawComponent\n     * @param {AbstractComponent} component\n     */\n    AbstractRenderer.prototype.drawComponent = function (component) {\n        if (component instanceof scope.StrokeComponent) {\n            _drawStroke(component, this.getContext(), this.getParameters());\n        } else if (component instanceof scope.CharacterInputComponent) {\n            _drawCharacter(component, this.getContext(), this.getParameters());\n        } else {\n            throw new Error('Component not implemented: ' + component.getType());\n        }\n    };\n\n    /**\n     * Draw stroke component\n     *\n     * @private\n     * @method _drawStroke\n     * @param {StrokeComponent} stroke\n     * @param {Object} context\n     * @param {PenParameters} parameters\n     */\n    var _drawStroke = function (stroke, context, parameters) { // jshint ignore:line\n        if (stroke && stroke.getLength() > 0) {\n            _renderStroke(stroke, context);\n        }\n    };\n\n    /**\n     * Draw character component\n     *\n     * @private\n     * @method _drawCharacter\n     * @param {CharacterInputComponent} character\n     * @param {Object} context\n     * @param {PenParameters} parameters\n     */\n    var _drawCharacter = function (character, context, parameters) { // jshint ignore:line\n        throw new Error('not implemented');\n    };\n\n    /**\n     * Draw a rectangle on context\n     *\n     * @private\n     * @method _drawRectangle\n     * @param {Rectangle} rectangle\n     * @param {Object} context\n     * @param {PenParameters} parameters\n     */\n    var _drawRectangle = function (rectangle, context, parameters) {\n        context.save();\n        try {\n            context.fillStyle = parameters.getRectColor();\n            context.strokeStyle = parameters.getColor();\n            context.lineWidth = 0.5 * parameters.getWidth();\n            context.fillRect(rectangle.getX(), rectangle.getY(), rectangle.getWidth(), rectangle.getHeight());\n        } finally {\n            context.restore();\n        }\n    };\n\n    /*******************************************************************************************************************\n     * Algorithm methods to compute rendering\n     ******************************************************************************************************************/\n\n    function _computeLinksPoints(point, angle, width) {\n        var radius = point.p * width;\n        return [{\n            x: (point.x - Math.sin(angle) * radius),\n            y: (point.y + Math.cos(angle) * radius)\n        }, {\n            x: (point.x + Math.sin(angle) * radius),\n            y: (point.y - Math.cos(angle) * radius)\n        }\n        ];\n    }\n\n    function _computeMiddlePoint(point1, point2) {\n        return {\n            x: ((point2.x + point1.x) / 2),\n            y: ((point2.y + point1.y) / 2),\n            p: ((point2.p + point1.p) / 2)\n        };\n    }\n\n    function _computeAxeAngle(begin, end) {\n        return Math.atan2(end.y - begin.y, end.x - begin.x);\n    }\n\n    function _fill(context, color) {\n        if (color !== undefined) {\n            context.fillStyle = color;\n            context.fill();\n        }\n    }\n\n    /**\n     *\n     * @param stroke\n     * @param context\n     * @param parameters\n     * @private\n     */\n    function _renderStroke(stroke, context) {\n        context.beginPath();\n        var length = stroke.getLength();\n        var width = stroke.getWidth();\n        var firstPoint = stroke.getPointByIndex(0);\n        if (length < 3) {\n            context.arc(firstPoint.x, firstPoint.y, width * 0.6, 0, Math.PI * 2, true);\n        } else {\n            context.arc(firstPoint.x, firstPoint.y, width * firstPoint.p, 0, Math.PI * 2, true);\n            _renderLine(context, firstPoint, _computeMiddlePoint(firstPoint, stroke.getPointByIndex(1)), width);\n\n            // Possibility to try this (the start looks better when the ink is large)\n            //var first = _computeMiddlePoint(stroke[0], stroke[1]);\n            //context.arc(first.x, first.y, width * first.p, 0, Math.PI * 2, true);\n\n            var nbquadratics = length - 2;\n            for (var i = 0; i < nbquadratics; i++) {\n                _renderQuadratic(context, _computeMiddlePoint(stroke.getPointByIndex(i), stroke.getPointByIndex(i + 1)), _computeMiddlePoint(stroke.getPointByIndex(i + 1), stroke.getPointByIndex(i + 2)), stroke.getPointByIndex(i + 1), width);\n            }\n            _renderLine(context, _computeMiddlePoint(stroke.getPointByIndex(length - 2), stroke.getPointByIndex(length - 1)), stroke.getPointByIndex(length - 1), width);\n            _renderFinal(context, stroke.getPointByIndex(length - 2), stroke.getPointByIndex(length - 1), width);\n        }\n        context.closePath();\n        _fill(context, stroke.getColor());\n    }\n\n    function _renderFinal(context, begin, end, width) {\n        var ARCSPLIT = 6;\n        var angle = _computeAxeAngle(begin, end);\n        var linkPoints = _computeLinksPoints(end, angle, width);\n        context.moveTo(linkPoints[0].x, linkPoints[0].y);\n        for (var i = 1; i <= ARCSPLIT; i++) {\n            var newAngle = angle - i * Math.PI / ARCSPLIT;\n            context.lineTo(end.x - end.p * width * Math.sin(newAngle), end.y + end.p * width * Math.cos(newAngle));\n        }\n    }\n\n    function _renderLine(context, begin, end, width) {\n        var linkPoints1 = _computeLinksPoints(begin, _computeAxeAngle(begin, end), width);\n        var linkPoints2 = _computeLinksPoints(end, _computeAxeAngle(begin, end), width);\n\n        context.moveTo(linkPoints1[0].x, linkPoints1[0].y);\n        context.lineTo(linkPoints2[0].x, linkPoints2[0].y);\n        context.lineTo(linkPoints2[1].x, linkPoints2[1].y);\n        context.lineTo(linkPoints1[1].x, linkPoints1[1].y);\n    }\n\n    function _renderQuadratic(context, begin, end, ctrl, width) {\n        var linkPoints1 = _computeLinksPoints(begin, _computeAxeAngle(begin, ctrl), width);\n        var linkPoints2 = _computeLinksPoints(end, _computeAxeAngle(ctrl, end), width);\n        var linkPoints3 = _computeLinksPoints(ctrl, _computeAxeAngle(begin, end), width);\n\n        context.moveTo(linkPoints1[0].x, linkPoints1[0].y);\n        context.quadraticCurveTo(linkPoints3[0].x, linkPoints3[0].y, linkPoints2[0].x, linkPoints2[0].y);\n        context.lineTo(linkPoints2[1].x, linkPoints2[1].y);\n        context.quadraticCurveTo(linkPoints3[1].x, linkPoints3[1].y, linkPoints1[1].x, linkPoints1[1].y);\n    }\n\n    // Export\n    scope.AbstractRenderer = AbstractRenderer;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * Represent the Text Renderer. It's used to calculate the text ink rendering in HTML5 canvas\n     *\n     * @class TextRenderer\n     * @extends AbstractRenderer\n     * @param {Object} context\n     * @constructor\n     */\n    function TextRenderer(context) {\n        scope.AbstractRenderer.call(this, context);\n    }\n\n    /**\n     * Inheritance property\n     */\n    TextRenderer.prototype = new scope.AbstractRenderer();\n\n    /**\n     * Constructor property\n     */\n    TextRenderer.prototype.constructor = TextRenderer;\n\n    /**\n     * Draw text recognition result on HTML5 canvas. Scratch out results are use to redraw HTML5 Canvas\n     *\n     * @method drawRecognitionResult\n     * @param {AbstractComponent[]} components\n     * @param {TextDocument} recognitionResult\n     */\n    TextRenderer.prototype.drawRecognitionResult = function (components, recognitionResult) {\n        this.clear();\n        if (recognitionResult) {\n            this.drawComponents(components);\n        } else {\n            this.drawComponents(components);\n        }\n    };\n\n    /**\n     * Draw components\n     *\n     * @method drawComponents\n     * @param {AbstractComponent[]} components\n     */\n    TextRenderer.prototype.drawComponents = function (components) {\n        for (var i in components) {\n            var component = components[i];\n            if (component instanceof scope.TextInputUnit) {\n                this.drawComponents(component.getComponents());\n            } else if (component instanceof scope.AbstractTextInputComponent) {\n                _drawTextComponent(component, this.getContext(), this.getParameters());\n            } else if (component instanceof scope.AbstractComponent) {\n                scope.AbstractRenderer.prototype.drawComponent.call(this, component); // super\n            } else {\n                throw new Error('not implemented');\n            }\n        }\n    };\n\n    /**\n     * Draw text component\n     *\n     * @private\n     * @method _drawTextComponent\n     * @param {AbstractTextInputComponent} component\n     * @param {Object} context\n     * @param {PenParameters} parameters\n     */\n    var _drawTextComponent = function (component, context, parameters) {\n        if (component instanceof scope.CharInputComponent) {\n            _drawChar(component, context, parameters);\n        } else if (component instanceof scope.StringInputComponent) {\n            _drawString(component, context, parameters);\n        } else {\n            throw new Error('Component not implemented: ' + component.getType());\n        }\n    };\n\n    /**\n     * Draw char\n     *\n     * @private\n     * @method _drawChar\n     * @param {CharInputComponent} char\n     * @param {Object} context The canvas 2d context\n     * @param {PenParameters} parameters\n     */\n    var _drawChar = function (char, context, parameters) { // jshint ignore:line\n        throw new Error('not implemented');\n    };\n\n    /**\n     * Draw string\n     *\n     * @private\n     * @method _drawString\n     * @param {StringInputComponent} string\n     * @param {Object} context The canvas 2d context\n     * @param {PenParameters} parameters\n     */\n    var _drawString = function (string, context, parameters) { // jshint ignore:line\n        throw new Error('not implemented');\n    };\n\n    // Export\n    scope.TextRenderer = TextRenderer;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * Represent the Shape Renderer. It's used to calculate the shape ink rendering in HTML5 canvas\n     *\n     * @class ShapeRenderer\n     * @extends AbstractRenderer\n     * @param {Object} context\n     * @constructor\n     */\n    function ShapeRenderer(context) {\n        scope.AbstractRenderer.call(this, context);\n    }\n\n    /**\n     * Inheritance property\n     */\n    ShapeRenderer.prototype = new scope.AbstractRenderer();\n\n    /**\n     * Constructor property\n     */\n    ShapeRenderer.prototype.constructor = ShapeRenderer;\n\n    /**\n     * Draw shape recognition result on HTML5 canvas\n     *\n     * @method drawRecognitionResult\n     * @param {AbstractComponent[]} components\n     * @param {ShapeDocument} document\n     */\n    ShapeRenderer.prototype.drawRecognitionResult = function (components, document) {\n        this.clear();\n        if (document && (document instanceof scope.ShapeDocument)) {\n            this.drawShapes(components, document.getSegments());\n            var lastComponents = [];\n            var processedComponents = _extractComponents(components, document.getInkRanges());\n\n            for (var i in components) {\n                var component = components[i];\n                if (processedComponents.indexOf(component) !== -1) {\n                    lastComponents.push(component);\n                }\n            }\n            this.drawComponents(lastComponents);\n        } else {\n            this.drawComponents(components);\n        }\n        return {components : components, document : document}\n    };\n\n    /**\n     * Draw components\n     *\n     * @method drawComponents\n     * @param {AbstractComponent[]} components\n     */\n    ShapeRenderer.prototype.drawComponents = function (components) {\n        for (var i in components) {\n            var component = components[i];\n            if (component instanceof scope.AbstractShapePrimitive) {\n                _drawShapePrimitive(component, this.getContext(), this.getParameters());\n            } else if (component instanceof scope.AbstractComponent) {\n                scope.AbstractRenderer.prototype.drawComponent.call(this, component); // super\n            } else {\n                throw new Error('not implemented');\n            }\n        }\n    };\n\n    /**\n     * Draw the shapes\n     *\n     * @method drawShapes\n     * @param {AbstractComponent[]} components\n     * @param {ShapeSegment[]} shapes\n     */\n    ShapeRenderer.prototype.drawShapes = function (components, shapes) {\n        for (var i in shapes) {\n            this.drawShapeSegment(components, shapes[i]);\n        }\n    };\n\n    /**\n     * Draw shape segment\n     *\n     * @method drawShapeSegment\n     * @param {AbstractComponent[]} components\n     * @param {ShapeSegment} segment\n     */\n    ShapeRenderer.prototype.drawShapeSegment = function (components, segment) {\n        var candidate = segment.getSelectedCandidate();\n        if (candidate instanceof scope.ShapeRecognized) {\n            _drawShapeRecognized(candidate, this.getContext(), this.getParameters());\n        } else if (candidate instanceof scope.ShapeNotRecognized) {\n            this.drawComponents(_extractComponents(components, segment.getInkRanges()));\n        } else {\n            throw new Error('not implemented');\n        }\n    };\n\n    /**\n     * This method allow you to draw not recognized shape\n     *\n     * @method drawShapeNotRecognized\n     * @param {AbstractComponent[]} components\n     * @param {ShapeInkRange[]} inkRanges\n     */\n    ShapeRenderer.prototype.drawShapeNotRecognized = function (components, inkRanges) {\n        this.drawComponents(_extractComponents(components, inkRanges));\n    };\n\n    /**\n     * Draw shape primitive\n     *\n     * @method drawShapePrimitive\n     * @param {AbstractShapePrimitive} primitive\n     */\n    ShapeRenderer.prototype.drawShapePrimitive = function (primitive) {\n        _drawShapePrimitive(primitive, this.getContext(), this.getParameters());\n    };\n\n    /**\n     * This method allow you to draw recognized shape\n     *\n     * @private\n     * @method _drawShapeRecognized\n     * @param {ShapeRecognized} shapeRecognized\n     * @param {Object} context\n     * @param {PenParameters} parameters\n     */\n    var _drawShapeRecognized = function (shapeRecognized, context, parameters) {\n        for (var i in shapeRecognized.getPrimitives()) {\n            _drawShapePrimitive(shapeRecognized.getPrimitives()[i], context, parameters);\n        }\n    };\n\n    /**\n     * Draw shape primitive\n     *\n     * @private\n     * @method _drawShapePrimitive\n     * @param {AbstractShapePrimitive} primitive\n     * @param {Object} context\n     * @param {PenParameters} parameters\n     */\n    var _drawShapePrimitive = function (primitive, context, parameters) {\n        if (primitive instanceof scope.ShapeEllipse) {\n            _drawShapeEllipse(primitive, context, parameters);\n        } else if (primitive instanceof scope.ShapeLine) {\n            _drawShapeLine(primitive, context, parameters);\n        } else {\n            throw new Error('Primitive not implemented: ' + primitive.getType());\n        }\n    };\n\n    /**\n     * Draw shape line\n     *\n     * @private\n     * @method _drawShapeLine\n     * @param {ShapeLine} shapeLine\n     * @param {Object} context\n     * @param {PenParameters} parameters\n     */\n    var _drawShapeLine = function (shapeLine, context, parameters) {\n        _drawLine(shapeLine.getFirstPoint(), shapeLine.getLastPoint(), context, parameters);\n        if (shapeLine.hasBeginDecoration() && shapeLine.getBeginDecoration() === 'ARROW_HEAD') {\n            _drawArrowHead(shapeLine.getFirstPoint(), shapeLine.getBeginTangentAngle(), 12.0, context, parameters);\n        }\n        if (shapeLine.hasEndDecoration() && shapeLine.getEndDecoration() === 'ARROW_HEAD') {\n            _drawArrowHead(shapeLine.getLastPoint(), shapeLine.getEndTangentAngle(), 12.0, context, parameters);\n        }\n    };\n\n    /**\n     * Draw shape ellipse\n     *\n     * @private\n     * @method _drawShapeEllipse\n     * @param {ShapeEllipse} shapeEllipse\n     * @param {Object} context\n     * @param {PenParameters} parameters\n     */\n    var _drawShapeEllipse = function (shapeEllipse, context, parameters) {\n        var points = _drawEllipseArc(\n            shapeEllipse.getCenter(),\n            shapeEllipse.getMaxRadius(),\n            shapeEllipse.getMinRadius(),\n            shapeEllipse.getOrientation(),\n            shapeEllipse.getStartAngle(),\n            shapeEllipse.getSweepAngle(),\n            context, parameters);\n\n        if (shapeEllipse.hasBeginDecoration() && shapeEllipse.getBeginDecoration() === 'ARROW_HEAD') {\n            _drawArrowHead(points[0], shapeEllipse.getBeginTangentAngle(), 12.0, context, parameters);\n        }\n        if (shapeEllipse.hasEndDecoration() && shapeEllipse.getEndDecoration() === 'ARROW_HEAD') {\n            _drawArrowHead(points[1], shapeEllipse.getEndTangentAngle(), 12.0, context, parameters);\n        }\n    };\n\n    /**\n     * Draw an ellipse arc on context\n     *\n     * @private\n     * @method _drawEllipseArc\n     * @param {Point} centerPoint\n     * @param {Number} maxRadius\n     * @param {Number} minRadius\n     * @param {String} orientation\n     * @param {Number} startAngle\n     * @param {Number} sweepAngle\n     * @param {Object} context The canvas 2d context\n     * @param {PenParameters} parameters\n     * @returns {Point[]}\n     */\n    var _drawEllipseArc = function (centerPoint, maxRadius, minRadius, orientation, startAngle, sweepAngle, context, parameters) {\n\n        var angleStep = 0.02; // angle delta between interpolated\n\n        var z1 = Math.cos(orientation);\n        var z3 = Math.sin(orientation);\n        var z2 = z1;\n        var z4 = z3;\n        z1 *= maxRadius;\n        z2 *= minRadius;\n        z3 *= maxRadius;\n        z4 *= minRadius;\n\n        var n = Math.floor(Math.abs(sweepAngle) / angleStep);\n\n        var boundariesPoints = [];\n\n        context.save();\n        try {\n            context.fillStyle = parameters.getColor();\n            context.strokeStyle = parameters.getColor();\n            context.lineWidth = 0.5 * parameters.getWidth();\n\n            context.beginPath();\n\n            for (var i = 0; i <= n; i++) {\n\n                var angle = startAngle + (i / n) * sweepAngle; // points on the arc, in radian\n                var alpha = Math.atan2(Math.sin(angle) / minRadius, Math.cos(angle) / maxRadius);\n\n                var cosAlpha = Math.cos(alpha);\n                var sinAlpha = Math.sin(alpha);\n\n                // current point\n                var x = centerPoint.x + z1 * cosAlpha - z4 * sinAlpha;\n                var y = centerPoint.y + z2 * sinAlpha + z3 * cosAlpha;\n                if (i === 0) {\n                    context.moveTo(x, y);\n                } else {\n                    context.lineTo(x, y);\n                }\n\n                if (i === 0 || i === n) {\n                    boundariesPoints.push(new scope.Point({x: x, y: y}));\n                }\n            }\n\n            context.stroke();\n\n        } finally {\n            context.restore();\n        }\n\n        return boundariesPoints;\n    };\n\n    /**\n     * Draw a line on context\n     *\n     * @private\n     * @method _drawLine\n     * @param {Point} p1\n     * @param {Point} p2\n     * @param {Object} context The canvas 2d context\n     * @param {PenParameters} parameters\n     */\n    var _drawLine = function (p1, p2, context, parameters) {\n        context.save();\n        try {\n            context.fillStyle = parameters.getColor();\n            context.strokeStyle = parameters.getColor();\n            context.lineWidth = 0.5 * parameters.getWidth();\n\n            context.beginPath();\n            context.moveTo(p1.getX(), p1.getY());\n            context.lineTo(p2.getX(), p2.getY());\n            context.stroke();\n        } finally {\n            context.restore();\n        }\n    };\n\n    /**\n     * Clamp an angle into the range [-PI, +PI]\n     *\n     * @private\n     * @method _phi\n     * @param {Number} angle\n     * @returns {Number}\n     */\n    var _phi = function (angle) {\n        angle = ((angle + Math.PI) % (Math.PI * 2)) - Math.PI;\n        if (angle < -Math.PI) {\n            angle += Math.PI * 2;\n        }\n        return angle;\n    };\n\n    /**\n     * Draw an arrow head on context\n     *\n     * @private\n     * @method _drawArrowHead\n     * @param {Point} headPoint\n     * @param {Number} angle\n     * @param {Number} length\n     * @param {Object} context The canvas 2d context\n     * @param {PenParameters} parameters\n     */\n    var _drawArrowHead = function (headPoint, angle, length, context, parameters) {\n        var alpha = _phi(angle + Math.PI - (Math.PI / 8)),\n            beta = _phi(angle - Math.PI + (Math.PI / 8));\n\n        context.save();\n        try {\n            context.fillStyle = parameters.getColor();\n            context.strokeStyle = parameters.getColor();\n            context.lineWidth = 0.5 * parameters.getWidth();\n\n            context.moveTo(headPoint.getX(), headPoint.getY());\n            context.beginPath();\n            context.lineTo(headPoint.getX() + (length * Math.cos(alpha)), headPoint.getY() + (length * Math.sin(alpha)));\n            context.lineTo(headPoint.getX() + (length * Math.cos(beta)), headPoint.getY() + (length * Math.sin(beta)));\n            context.lineTo(headPoint.getX(), headPoint.getY());\n            context.fill();\n\n        } finally {\n            context.restore();\n        }\n\n    };\n\n    /**\n     * Return components from ink ranges\n     *\n     * @private\n     * @param components\n     * @param inkRanges\n     * @returns {AbstractComponent[]}\n     */\n    var _extractComponents = function (components, inkRanges) {\n        var result = [];\n\n        for (var i in inkRanges) {\n            var inkRange = inkRanges[i];\n\n            var firstPointIndex = Math.floor(inkRange.getFirstPoint());\n            var lastPointIndex = Math.ceil(inkRange.getLastPoint());\n\n            for (var strokeIndex = inkRange.getFirstStroke(); strokeIndex <= inkRange.getLastStroke(); strokeIndex++) {\n                var currentStroke = components[strokeIndex];\n                var currentStrokePointCount = currentStroke.getX().length;\n\n                var newStroke = new scope.StrokeComponent();\n                newStroke.setColor(currentStroke.getColor());\n                newStroke.setWidth(currentStroke.getWidth());\n\n                for (var pointIndex = firstPointIndex; (strokeIndex === inkRange.getLastStroke() && pointIndex <= lastPointIndex && pointIndex < currentStrokePointCount) || (strokeIndex !== inkRange.getLastStroke() && pointIndex < currentStrokePointCount); pointIndex++) {\n                    newStroke.addPoint(currentStroke.getX()[pointIndex], currentStroke.getY()[pointIndex], currentStroke.getT()[pointIndex]);\n                }\n                result.push(newStroke);\n            }\n        }\n        return result;\n\n    };\n\n    // Export\n    scope.ShapeRenderer = ShapeRenderer;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * Represent the Math Renderer. It's used to calculate the math ink rendering in HTML5 canvas\n     *\n     * @class MathRenderer\n     * @extends AbstractRenderer\n     * @param {Object} context\n     * @constructor\n     */\n    function MathRenderer(context) {\n        scope.AbstractRenderer.call(this, context);\n    }\n\n    /**\n     * Inheritance property\n     */\n    MathRenderer.prototype = new scope.AbstractRenderer();\n\n    /**\n     * Constructor property\n     */\n    MathRenderer.prototype.constructor = MathRenderer;\n\n    /**\n     * Draw math recognition result on HTML5 canvas. Scratch out results are use to redraw HTML5 Canvas\n     *\n     * @method drawRecognitionResult\n     * @param {AbstractComponent[]} components\n     * @param {MathDocument} recognitionResult\n     */\n    MathRenderer.prototype.drawRecognitionResult = function (components, recognitionResult) {\n        this.clear();\n        if (recognitionResult) {\n            var notScratchOutComponents = _filterScratchOut(components, recognitionResult.getScratchOutResults());\n            this.drawComponents(notScratchOutComponents);\n        } else {\n            this.drawComponents(components);\n        }\n    };\n\n    /**\n     * Draw components\n     *\n     * @method drawComponents\n     * @param {AbstractComponent[]} components\n     */\n    MathRenderer.prototype.drawComponents = function (components) {\n        for (var i in components) {\n            var component = components[i];\n            if (component instanceof scope.AbstractComponent) {\n                if(!component.scratchedStroke){\n                    scope.AbstractRenderer.prototype.drawComponent.call(this, component); // super\n                }\n            } else {\n                throw new Error('not implemented');\n            }\n        }\n    };\n\n\n    /**\n     * Return non-scratched out components\n     *\n     * @private\n     * @param components\n     * @param scratchOutResults\n     * @returns {*}\n     */\n    var _filterScratchOut = function (components, scratchOutResults) {\n        if (!scratchOutResults || scratchOutResults.length === 0) {\n            return components;\n        }\n        for (var k in scratchOutResults) {\n            for (var n in scratchOutResults[k].getErasedInkRanges()) {\n                components[scratchOutResults[k].getErasedInkRanges()[n].getComponent()].scratchedStroke = true;\n            }\n            for (var p in scratchOutResults[k].getInkRanges()) {\n                components[scratchOutResults[k].getInkRanges()[p].getComponent()].scratchedStroke = true;;\n            }\n        }\n        return components;\n    };\n\n    // Export\n    scope.MathRenderer = MathRenderer;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * Represent the Music Renderer. It's used to calculate the music ink rendering in HTML5 canvas\n     *\n     * @class MusicRenderer\n     * @extends AbstractRenderer\n     * @param {Object} context\n     * @constructor\n     */\n    function MusicRenderer(context) {\n        scope.AbstractRenderer.call(this, context);\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicRenderer.prototype = new scope.AbstractRenderer();\n\n    /**\n     * Constructor property\n     */\n    MusicRenderer.prototype.constructor = MusicRenderer;\n\n    /**\n     * Draw music recognition result on HTML5 canvas. Scratch out results are use to redraw HTML5 Canvas\n     *\n     * @method drawRecognitionResult\n     * @param {AbstractComponent[]} components\n     * @param {MusicDocument} recognitionResult\n     */\n    MusicRenderer.prototype.drawRecognitionResult = function (components, recognitionResult) {\n        this.clear();\n        if (recognitionResult) {\n            var notScratchOutComponents = _removeMusicScratchOut(components, recognitionResult.getScratchOutResults());\n            this.drawComponents(notScratchOutComponents);\n        } else {\n            this.drawComponents(components);\n        }\n    };\n\n    /**\n     * Draw staff on the HTML5 canvas\n     *\n     * @method drawStaff\n     * @param {MusicStaff} staff\n     */\n    MusicRenderer.prototype.drawStaff = function (staff) {\n        _drawStaff(staff, this.getContext(), this.getParameters());\n    };\n\n    /**\n     * Draw components\n     *\n     * @method drawComponents\n     * @param {AbstractComponent[]} components\n     */\n    MusicRenderer.prototype.drawComponents = function (components) {\n        for (var i in components) {\n            var component = components[i];\n            if (component instanceof scope.AbstractMusicInputComponent) {\n                _drawMusicNode(component, this.getContext(), this.getParameters());\n            } else if (component instanceof scope.AbstractComponent) {\n                scope.AbstractRenderer.prototype.drawComponent.call(this, component); // super\n            } else {\n                throw new Error('not implemented');\n            }\n        }\n    };\n\n    /**\n     * Draw staff on the HTML5 canvas\n     *\n     * @private\n     * @method _drawStaff\n     * @param {MusicStaff} staff\n     * @param {Object} context\n     * @param {PenParameters} parameters\n     */\n    var _drawStaff = function (staff, context, parameters) {\n        var staffHeight = staff.getTop() + ((staff.getCount() - 1) * staff.getGap());\n//            var staves = Math.floor(context.canvas.clientHeight / staff.height);\n        var staves = 1;\n\n        context.beginPath();\n\n        // Drawing horizontal staff lines\n        for (var i = 0; i < staves; i++) {\n            var offset = staffHeight * i;\n            for (var j = 0; j < staff.getCount(); j++) {\n                context.moveTo(0, (staff.getTop() + offset) + j * staff.getGap());\n                context.lineTo(context.canvas.clientWidth, (staff.getTop() + offset) + j * staff.getGap());\n            }\n        }\n\n        context.stroke();\n    };\n\n    /**\n     * Draw music node\n     *\n     * @private\n     * @method _drawMusicNode\n     * @param {AbstractMusicInputComponent} component\n     * @param {Object} context\n     * @param {PenParameters} parameters\n     */\n    var _drawMusicNode = function (component, context, parameters) {\n        if (component instanceof scope.MusicAccidentalInputComponent) {\n            _drawAccidental(component, context, parameters);\n        } else if (component instanceof scope.MusicArpeggiateInputComponent) {\n            _drawArpeggiate(component, context, parameters);\n        } else if (component instanceof scope.MusicBarInputComponent) {\n            _drawBar(component, context, parameters);\n        } else if (component instanceof scope.MusicBeamInputComponent) {\n            _drawBeam(component, context, parameters);\n        } else if (component instanceof scope.MusicClefInputComponent) {\n            _drawClef(component, context, parameters);\n        } else if (component instanceof scope.MusicDecorationInputComponent) {\n            _drawDecoration(component, context, parameters);\n        } else if (component instanceof scope.MusicDotsInputComponent) {\n            _drawDots(component, context, parameters);\n        } else if (component instanceof scope.MusicHeadInputComponent) {\n            _drawHead(component, context, parameters);\n        } else if (component instanceof scope.MusicLedgerLineInputComponent) {\n            _drawLedgerLine(component, context, parameters);\n        } else if (component instanceof scope.MusicRestInputComponent) {\n            _drawRest(component, context, parameters);\n        } else if (component instanceof scope.MusicStemInputComponent) {\n            _drawStem(component, context, parameters);\n        } else if (component instanceof scope.MusicTieOrSlurInputComponent) {\n            _drawTieOrSlur(component, context, parameters);\n        } else if (component instanceof scope.MusicTimeSignatureInputComponent) {\n            _drawTimeSignature(component, context, parameters);\n        } else {\n            throw new Error('Node not implemented: ' + component.getType());\n        }\n    };\n\n    /**\n     * Draw accidental\n     *\n     * @private\n     * @method _drawAccidental\n     * @param {MusicAccidentalInputComponent} accidental\n     * @param {Object} context The canvas 2d context\n     * @param {PenParameters} parameters Rendering parameters\n     */\n    var _drawAccidental = function (accidental, context, parameters) { // jshint ignore:line\n        throw new Error('not implemented');\n    };\n\n    /**\n     * Draw arpeggiate\n     *\n     * @private\n     * @method _drawArpeggiate\n     * @param {MusicArpeggiateInputComponent} arpeggiate\n     * @param {Object} context The canvas 2d context\n     * @param {PenParameters} parameters Rendering parameters\n     */\n    var _drawArpeggiate = function (arpeggiate, context, parameters) { // jshint ignore:line\n        throw new Error('not implemented');\n    };\n\n    /**\n     * Draw bar\n     *\n     * @private\n     * @method _drawBar\n     * @param {MusicBarInputComponent} bar\n     * @param {Object} context The canvas 2d context\n     * @param {PenParameters} parameters Rendering parameters\n     */\n    var _drawBar = function (bar, context, parameters) { // jshint ignore:line\n        throw new Error('not implemented');\n    };\n\n    /**\n     * Draw beam\n     *\n     * @private\n     * @method _drawBeam\n     * @param {MusicBeamInputComponent} beam\n     * @param {Object} context The canvas 2d context\n     * @param {PenParameters} parameters Rendering parameters\n     */\n    var _drawBeam = function (beam, context, parameters) { // jshint ignore:line\n        throw new Error('not implemented');\n    };\n\n    /**\n     * Draw clef\n     *\n     * @private\n     * @method _drawClef\n     * @param {MusicClefInputComponent} clef\n     * @param {Object} context The canvas 2d context\n     * @param {PenParameters} parameters Rendering parameters\n     */\n    var _drawClef = function (clef, context, parameters) { // jshint ignore:line\n        var src = 'data:image/svg+xml,';\n        switch (clef.getValue().getSymbol()) {\n            case 'F':\n                src = src + '<svg xmlns:svg=\"http://www.w3.org/2000/svg\" xmlns=\"http://www.w3.org/2000/svg\" version=\"1.0\" x=\"0\" y=\"0\" width=\"18\" height=\"20\"><defs/><g transform=\"translate(6.600000e-3,3.125356e-3)\"><g><path d=\"M17.3 3.1 C17.3 3.5 17.1 3.8 16.8 4.1 C16.5 4.4 15.9 4.5 15.5 4.3 C15 4.1 14.7 3.7 14.7 3.2 C14.6 2.8 14.8 2.5 15 2.2 C15.3 1.9 15.7 1.8 16 1.8 C16.4 1.8 16.8 2 17 2.3 C17.2 2.5 17.3 2.8 17.3 3.1 z\"/></g><g><path d=\"M17.3 8.9 C17.3 9.3 17.1 9.7 16.8 9.9 C16.5 10.3 15.9 10.3 15.5 10.2 C15 10 14.7 9.5 14.7 9.1 C14.6 8.7 14.8 8.3 15 8 C15.3 7.8 15.7 7.6 16 7.6 C16.5 7.7 17 8 17.2 8.4 C17.2 8.6 17.3 8.8 17.3 8.9 z\"/></g><g><path d=\"M13 7.2 C13 10 11.8 12.7 9.8 14.7 C7.3 17.2 4 18.8 0.7 19.8 C0.3 20.1 -0.4 19.8 0.3 19.4 C1.6 18.8 3 18.3 4.2 17.5 C7 15.8 9.3 13.1 9.8 9.9 C10.1 8 10.1 5.9 9.6 4 C9.2 2.6 8.2 1.1 6.7 0.9 C5.3 0.7 3.7 1.2 2.7 2.2 C2.5 2.4 2 3.2 2 4 C2.6 3.6 2.6 3.6 3.1 3.4 C4.2 2.9 5.7 3.6 6 4.9 C6.3 6 6.1 7.5 5 8.1 C3.8 8.7 2 8.5 1.4 7.2 C0.3 5.3 0.9 2.6 2.6 1.2 C4.4 -0.3 7.1 -0.3 9.2 0.4 C11.4 1.3 12.7 3.5 12.9 5.8 C13 6.2 13 6.7 13 7.2 z\"/></g></g></svg>';\n                break;\n            case 'C':\n                src = src + '<svg xmlns:svg=\"http://www.w3.org/2000/svg\" xmlns=\"http://www.w3.org/2000/svg\" version=\"1.0\" width=\"18\" height=\"25\"><defs/><g><g transform=\"matrix(1,0,0,1.030698,-309.364,-543.8647)\"><path d=\"M 325.9 546.8 C 325.8 548.7 324.7 550.7 322.8 551.5 C 321.1 552.1 319.1 552.2 317.6 551 C 316.6 550.2 316.2 548.4 317.3 547.5 C 318.3 546.5 320.4 547.4 320.3 548.9 C 320.7 549.9 318.5 550.5 319.7 551.3 C 321 551.6 322.3 550.5 322.6 549.3 C 323.1 547.5 323.1 545.6 322.7 543.8 C 322.4 542.9 321.9 541.5 320.7 541.9 C 319.2 542.2 318.3 543.8 317.9 545.1 C 317.6 543.2 316.4 541.5 315 540.2 C 315 544.1 315 548 315 551.9 L 314.1 551.9 C 314.1 543.9 314.1 535.7 314.1 527.7 L 315 527.7 C 315 531.5 315 535.5 315 539.4 C 316.4 538.1 317.6 536.4 317.8 534.5 C 318.3 535.9 319.3 537.5 321 537.8 C 322.2 537.8 322.5 536.3 322.8 535.4 C 323.1 533.7 323.1 531.8 322.6 530.1 C 322.2 529 320.9 528 319.6 528.3 C 318.6 529 320.6 529.6 320.3 530.6 C 320.5 532 318.8 533 317.6 532.3 C 316.3 531.6 316.4 529.7 317.4 528.8 C 318 528.1 319.3 527.7 320.3 527.7 C 321.2 527.7 321.8 527.7 322.6 528 C 324.6 528.7 325.7 530.7 325.9 532.7 C 326.2 534.9 324.9 537.3 322.8 538.2 C 321.5 538.7 319.9 538.3 318.8 537.3 C 318.7 538.3 318.2 539.2 317.7 539.9 C 318.1 540.6 318.6 541.8 318.8 542.1 C 320.1 540.9 322.5 540.8 323.8 542 C 325.2 543.1 326.1 545 325.9 546.8 z \"/></g><g transform=\"matrix(1,0,0,1.030928,-309.364,-543.9805)\"><path d=\"M 312.2 551.9 L 309.4 551.9 L 309.4 527.7 L 312.2 527.7 L 312.2 551.9 z \"/></g></g></svg>';\n                break;\n            case 'G':\n                src = src + '<svg xmlns:svg=\"http://www.w3.org/2000/svg\" xmlns=\"http://www.w3.org/2000/svg\" version=\"1.0\" width=\"15\" height=\"40\"><defs/><path d=\"m 12 3.4 c 0.3 3.1 -2 5.6 -4.1 7.6 -0.9 0.9 -0.2 0.1 -0.6 0.6 -0.1 -0.5 -0.3 -1.7 -0.3 -2.1 0.1 -2.6 2.3 -6.5 4.2 -7.9 0.3 0.6 0.6 0.6 0.8 1.8 z m 0.7 15.9 c -1.2 -0.9 -2.8 -1.1 -4.3 -0.9 -0.2 -1.2 -0.4 -2.5 -0.6 -3.7 2.4 -2.3 4.9 -4.9 5 -8.4 0.1 -2.2 -0.3 -4.6 -1.7 -6.4 C 9.5 0.1 8.3 2.1 7.4 3.3 c -1.5 2.6 -1.1 5.8 -0.6 8.6 -0.8 0.9 -1.9 1.7 -2.7 2.7 -2.4 2.3 -4.4 5.3 -4 8.7 0.2 3.3 2.6 6.3 5.9 7.1 1.2 0.3 2.6 0.3 3.8 0.1 0.2 2.2 1 4.5 0.1 6.7 -0.7 1.6 -2.8 2.9 -4.3 2.2 -0.6 -0.3 -0.1 -0.1 -0.5 -0.2 1.1 -0.3 2 -1 2.3 -1.5 0.8 -1.4 -0.4 -3.6 -2.2 -3.3 -2.3 0 -3.2 3.1 -1.7 4.6 1.3 1.5 3.8 1.3 5.4 0.3 1.8 -1.2 2 -3.5 1.8 -5.5 -0.1 -0.7 -0.4 -2.6 -0.4 -3.3 0.7 -0.2 0.2 -0.1 1.2 -0.4 2.7 -1 4.4 -4.2 3.6 -7 -0.3 -1.4 -1 -2.9 -2.3 -3.7 z m 0.6 5.7 c 0.2 2 -1.1 4.2 -3.1 4.9 -0.1 -0.8 -0.2 -1 -0.3 -1.4 -0.5 -2.4 -0.7 -4.9 -1.1 -7.3 1.6 -0.2 3.5 0.5 4 2.1 0.2 0.6 0.3 1.2 0.4 1.8 z m -5.1 5.1 c -2.5 0.1 -5 -1.6 -5.6 -4 -0.7 -2.1 -0.5 -4.5 0.8 -6.4 1.1 -1.7 2.6 -3 4 -4.5 0.2 1.1 0.4 2.2 0.5 3.3 -3 0.8 -5 4.6 -3.2 7.3 0.5 0.8 2 2.2 2.8 1.6 -1.1 -0.7 -2 -1.8 -1.8 -3.2 -0.1 -1.3 1.4 -2.9 2.7 -3.1 0.4 2.8 0.9 6 1.4 8.8 -0.5 0.1 -1 0.1 -1.5 0.1 z\"/></svg>';\n                break;\n            default:\n                throw new Error('Unknown music clef symbol');\n        }\n\n        var imageObj = new Image();\n        imageObj.onload = function () {\n            var ratio = clef.getBoundingBox().getHeight() / this.height;\n            clef.getBoundingBox().setWidth(this.width * ratio);\n            context.drawImage(imageObj, clef.getBoundingBox().getX(), clef.getBoundingBox().getY(), clef.getBoundingBox().getWidth(), clef.getBoundingBox().getHeight());\n        };\n        imageObj.src = src;\n    };\n\n    /**\n     * Draw decoration\n     *\n     * @private\n     * @method _drawDecoration\n     * @param {MusicDecorationInputComponent} decoration\n     * @param {Object} context The canvas 2d context\n     * @param {PenParameters} parameters Rendering parameters\n     */\n    var _drawDecoration = function (decoration, context, parameters) { // jshint ignore:line\n        throw new Error('not implemented');\n    };\n\n    /**\n     * Draw dots\n     *\n     * @private\n     * @method _drawDots\n     * @param {MusicDotsInputComponent} dots\n     * @param {Object} context The canvas 2d context\n     * @param {PenParameters} parameters Rendering parameters\n     */\n    var _drawDots = function (dots, context, parameters) { // jshint ignore:line\n        throw new Error('not implemented');\n    };\n\n    /**\n     * Draw head\n     *\n     * @private\n     * @method _drawHead\n     * @param {MusicHeadInputComponent} head\n     * @param {Object} context The canvas 2d context\n     * @param {PenParameters} parameters Rendering parameters\n     */\n    var _drawHead = function (head, context, parameters) { // jshint ignore:line\n        throw new Error('not implemented');\n    };\n\n    /**\n     * Draw ledgerLine\n     *\n     * @private\n     * @method _drawLedgerLine\n     * @param {MusicLedgerLineInputComponent} ledgerLine\n     * @param {Object} context The canvas 2d context\n     * @param {PenParameters} parameters Rendering parameters\n     */\n    var _drawLedgerLine = function (ledgerLine, context, parameters) { // jshint ignore:line\n        throw new Error('not implemented');\n    };\n\n    /**\n     * Draw rest\n     *\n     * @private\n     * @method _drawRest\n     * @param {MusicRestInputComponent} rest\n     * @param {Object} context The canvas 2d context\n     * @param {PenParameters} parameters Rendering parameters\n     */\n    var _drawRest = function (rest, context, parameters) { // jshint ignore:line\n        throw new Error('not implemented');\n    };\n\n    /**\n     * Draw stem\n     *\n     * @private\n     * @method _drawStem\n     * @param {MusicStemInputComponent} stem\n     * @param {Object} context The canvas 2d context\n     * @param {PenParameters} parameters Rendering parameters\n     */\n    var _drawStem = function (stem, context, parameters) { // jshint ignore:line\n        throw new Error('not implemented');\n    };\n\n    /**\n     * Draw tieOrSlur\n     *\n     * @private\n     * @method _drawTieOrSlur\n     * @param {MusicTieOrSlurInputComponent} tieOrSlur\n     * @param {Object} context The canvas 2d context\n     * @param {PenParameters} parameters Rendering parameters\n     */\n    var _drawTieOrSlur = function (tieOrSlur, context, parameters) { // jshint ignore:line\n        throw new Error('not implemented');\n    };\n\n    /**\n     * Draw timeSignature\n     *\n     * @private\n     * @method _drawTimeSignature\n     * @param {MusicTimeSignatureInputComponent} timeSignature\n     * @param {Object} context The canvas 2d context\n     * @param {PenParameters} parameters Rendering parameters\n     */\n    var _drawTimeSignature = function (timeSignature, context, parameters) { // jshint ignore:line\n        throw new Error('not implemented');\n    };\n\n    /**\n     * Return non-scratched out components\n     *\n     * @private\n     * @param components\n     * @param scratchOutResults\n     * @returns {*}\n     */\n    var _removeMusicScratchOut = function (components, scratchOutResults) {\n        if (!scratchOutResults || scratchOutResults.length === 0) {\n            return components;\n        }\n\n        var cloneComponents = components.slice(0);\n        var componentsToRemove = [];\n\n        for (var k in scratchOutResults) {\n            if (scratchOutResults[k].getErasedInputRanges()) {\n                for (var n in scratchOutResults[k].getErasedInputRanges()) {\n                    componentsToRemove.push(scratchOutResults[k].getErasedInputRanges()[n].getComponent());\n                }\n                for (var p in scratchOutResults[k].getInputRanges()) {\n                    componentsToRemove.push(scratchOutResults[k].getInputRanges()[p].getComponent());\n                }\n            }\n        }\n\n        componentsToRemove.sort(function (a, b) {\n            return b - a;\n        });\n\n        for (var z in componentsToRemove) {\n            cloneComponents.splice(componentsToRemove[z], 1);\n        }\n        return cloneComponents;\n    };\n\n    // Export\n    scope.MusicRenderer = MusicRenderer;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * Represent the Analyzer Renderer. It's used to calculate the analyzer ink rendering in HTML5 canvas\n     *\n     * @class AnalyzerRenderer\n     * @extends AbstractRenderer\n     * @param {Object} context\n     * @constructor\n     */\n    function AnalyzerRenderer(context) {\n        scope.AbstractRenderer.call(this, context);\n        this.shapeRenderer = new scope.ShapeRenderer(context);\n    }\n\n    /**\n     * Inheritance property\n     */\n    AnalyzerRenderer.prototype = new scope.AbstractRenderer();\n\n    /**\n     * Constructor property\n     */\n    AnalyzerRenderer.prototype.constructor = AnalyzerRenderer;\n\n    /**\n     * Get shape renderer\n     *\n     * @method getShapeRenderer\n     * @returns {ShapeRenderer}\n     */\n    AnalyzerRenderer.prototype.getShapeRenderer = function () {\n        return this.shapeRenderer;\n    };\n\n    /**\n     * Set shape renderer\n     *\n     * @method setShapeRenderer\n     * @param {ShapeRenderer} shapeRenderer\n     */\n    AnalyzerRenderer.prototype.setShapeRenderer = function (shapeRenderer) {\n        this.shapeRenderer = shapeRenderer;\n    };\n\n    /**\n     * Draw shape recognition result on HTML5 canvas\n     *\n     * @method drawRecognitionResult\n     * @param {AbstractComponent[]} components\n     * @param {AnalyzerDocument} recognitionResult\n     */\n    AnalyzerRenderer.prototype.drawRecognitionResult = function (components, recognitionResult) {\n        this.clear();\n        if (recognitionResult) {\n            this.shapeRenderer.drawShapes(components, recognitionResult.getShapes());\n            _drawTables(components, recognitionResult.getTables(), this.getContext(), this.getParameters());\n            _drawTextLines(components, recognitionResult.getTextLines(), this.getContext(), this.getParameters());\n            //_drawGroups(components, recognitionResult.getGroups(), this.getContext(), this.getParameters()); // TODO: not implemented\n        } else {\n            this.drawComponents(components);\n        }\n    };\n\n    /**\n     * Draw components\n     *\n     * @method drawComponents\n     * @param {AbstractComponent[]} components\n     */\n    AnalyzerRenderer.prototype.drawComponents = function (components) {\n        for (var i in components) {\n            var component = components[i];\n            if (component instanceof scope.AbstractShapePrimitive) {\n                this.shapeRenderer.drawShapePrimitive(component);\n            } else if (component instanceof scope.AbstractComponent) {\n                scope.AbstractRenderer.prototype.drawComponent.call(this, component); // super\n            } else {\n                throw new Error('not implemented');\n            }\n        }\n    };\n\n    /**\n     * Draw table\n     *\n     * @private\n     * @method _drawTables\n     * @param {AbstractComponent[]} components\n     * @param {AnalyzerTable[]} tables\n     * @param {Object} context\n     * @param {PenParameters} parameters\n     */\n    var _drawTables = function (components, tables, context, parameters) {\n        for (var i in tables) {\n            for (var k in tables[i].getLines()) {\n                var data = tables[i].getLines()[k].getData();\n                _drawLine(data.getP1(), data.getP2(), context, parameters);\n            }\n        }\n    };\n\n    /**\n     * Draw the text line\n     *\n     * @private\n     * @method _drawTextLines\n     * @param {AbstractComponent[]} components\n     * @param {AnalyzerTextLine[]} textLines\n     * @param {Object} context\n     * @param {PenParameters} parameters\n     */\n    var _drawTextLines = function (components, textLines, context, parameters) {\n        for (var i in textLines) {\n            var textLine = textLines[i];\n            var data = textLine.getData();\n            if (data) {\n                var text = textLine.getTextDocument().getTextSegment().getSelectedCandidate().getLabel();\n                _drawText(data.getBoundingBox(), text, data.getJustificationType(), data.getTextHeight(), data.getBaselinePos(), context, parameters);\n\n                var underlines = textLine.getUnderlineList();\n                for (var j in underlines) {\n                    _drawUnderline(data.getBoundingBox(), underlines[j], text, data.getTextHeight(), data.getBaselinePos() + data.getTextHeight() / 10, context, parameters);\n                }\n            }\n        }\n    };\n\n    /**\n     * Draw text on analyser\n     *\n     * @private\n     * @method _drawText\n     * @param {Rectangle} boundingBox\n     * @param {String} text\n     * @param {String} justificationType\n     * @param {Number} textHeight\n     * @param {Number} baseline\n     * @param {Object} context\n     * @param {PenParameters} parameters\n     */\n    var _drawText = function (boundingBox, text, justificationType, textHeight, baseline, context, parameters) {\n        context.save();\n        try {\n            context.fillStyle = parameters.getColor();\n            context.strokeStyle = parameters.getColor();\n            context.lineWidth = 0.5 * parameters.getWidth();\n            context.font = parameters.getDecoration() + ' ' + textHeight + 'px' + ' ' + parameters.getFont();\n            context.textAlign = (justificationType === 'CENTER') ? 'center' : 'left';\n\n            context.fillText(text, boundingBox.getX(), baseline);\n\n        } finally {\n            context.restore();\n        }\n    };\n\n    /**\n     * Draw Groups\n     *\n     * @private\n     * @method _drawGroups\n     * @param {AbstractComponent[]} components\n     * @param {AnalyzerGroup[]} groups\n     * @param {Object} context\n     * @param {PenParameters} parameters\n     */\n    var _drawGroups = function (components, groups, context, parameters) { // jshint ignore:line\n        throw new Error('not implemented');\n    };\n\n\n    /**\n     * Draw Underline\n     *\n     * @private\n     * @method _drawUnderline\n     * @param {Rectangle} boundingBox\n     * @param {AnalyzerUnderline} underline\n     * @param {String} text\n     * @param {Number} textHeight\n     * @param {Object} context\n     * @param {PenParameters} parameters\n     */\n    var _drawUnderline = function (boundingBox, underline, text, textHeight, baseline, context, parameters) {\n        var topLeft = boundingBox.getTopLeftPoint();\n        var firstCharacter = underline.getData().getFirstCharacter();\n        var lastCharacter = underline.getData().getLastCharacter();\n\n        context.font = parameters.getDecoration() + ' ' + textHeight + 'px' + ' ' + parameters.getFont();\n\n        var textMetrics = context.measureText(text.substring(0, firstCharacter));\n        var x1 = topLeft.x + textMetrics.width;\n\n        textMetrics = context.measureText(text.substring(firstCharacter, lastCharacter + 1));\n        var x2 = x1 + textMetrics.width;\n        _drawLine(new scope.Point({x: x1, y: baseline}), new scope.Point({x: x2, y: baseline}), context, parameters);\n    };\n\n    /**\n     * Draw a cell\n     *\n     * @private\n     * @method _drawCell\n     * @param {AnalyzerCell} cell\n     * @param {Object} context\n     * @param {PenParameters} parameters\n     */\n    var _drawCell = function (cell, context, parameters) {\n        if (cell.getData()) {\n            var rectangle = cell.getData().getBoundingBox();\n            context.save();\n            try {\n                context.fillStyle = parameters.getRectColor();\n                context.strokeStyle = parameters.getColor();\n                context.lineWidth = 0.5 * parameters.getWidth();\n                context.fillRect(rectangle.getX(), rectangle.getY(), rectangle.getWidth(), rectangle.getHeight());\n            } finally {\n                context.restore();\n            }\n        }\n    };\n\n    /**\n     * Draw a line on context\n     *\n     * @private\n     * @method _drawLine\n     * @param {Point} p1\n     * @param {Point} p2\n     * @param {Object} context\n     * @param {PenParameters} parameters\n     */\n    var _drawLine = function (p1, p2, context, parameters) {\n        context.save();\n        try {\n            context.fillStyle = parameters.getColor();\n            context.strokeStyle = parameters.getColor();\n            context.lineWidth = 0.5 * parameters.getWidth();\n\n            context.beginPath();\n            context.moveTo(p1.getX(), p1.getY());\n            context.lineTo(p2.getX(), p2.getY());\n            context.stroke();\n        } finally {\n            context.restore();\n        }\n    };\n\n    // Export\n    scope.AnalyzerRenderer = AnalyzerRenderer;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * Represent the Image Renderer. It's used to calculate the Image ink rendering in HTML5 canvas\n     *\n     * @class ImageRenderer\n     * @extends AbstractRenderer\n     * @param {Object} context\n     * @constructor\n     */\n    function ImageRenderer(context) {\n        scope.AbstractRenderer.call(this, context);\n    }\n\n    /**\n     * Inheritance property\n     */\n    ImageRenderer.prototype = new scope.AbstractRenderer();\n\n    /**\n     * Constructor property\n     */\n    ImageRenderer.prototype.constructor = ImageRenderer;\n\n\n    /**\n     * Draw components\n     *\n     * @method drawComponents\n     * @param {AbstractComponent[]} components\n     */\n    ImageRenderer.prototype.drawComponents = function (components) {\n        for (var i in components) {\n            var component = components[i];\n            if (component instanceof scope.AbstractComponent) {\n                scope.AbstractRenderer.prototype.drawComponent.call(this, component); // super\n            } else {\n                console.log(components);\n                console.log(typeof component);\n                throw new Error('not implemented');\n            }\n        }\n    };\n\n    // Export\n    scope.ImageRenderer = ImageRenderer;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * The InkGrabber class that render, capture and build strokes\n     *\n     * @class InkGrabber\n     * @extends AbstractRenderer\n     * @param {Object} context\n     * @constructor\n     */\n    function InkGrabber(context) {\n        scope.AbstractRenderer.call(this, context);\n        this.stroke = undefined;\n        this.writing = false;\n    }\n\n    /**\n     * Inheritance property\n     */\n    InkGrabber.prototype = new scope.AbstractRenderer();\n\n    /**\n     * Constructor property\n     */\n    InkGrabber.prototype.constructor = InkGrabber;\n\n    /**\n     * Is Writing a stroke\n     *\n     * @method isWriting\n     * @returns {Boolean}\n     */\n    InkGrabber.prototype.isWriting = function () {\n        return this.writing;\n    };\n\n    /**\n     * Get the last wrote stroke\n     *\n     * @method getStroke\n     * @returns {StrokeComponent}\n     */\n    InkGrabber.prototype.getStroke = function () {\n        return this.stroke;\n    };\n\n    InkGrabber.prototype.startCapture = function (x, y, t) {\n        if (!this.writing) {\n            this.writing = true;\n            this.stroke = new scope.StrokeComponent();\n            this.stroke.setColor(this.penParameters.getColor());\n            this.stroke.setWidth(this.penParameters.getWidth());\n            this.stroke.addPoint(x, y, t);\n            this.clear();\n            this.drawComponent(this.stroke);\n        } else {\n            throw new Error('StrokeComponent capture already running');\n        }\n    };\n\n    InkGrabber.prototype.continueCapture = function (x, y, t) {\n        if (this.writing) {\n            this.stroke.addPoint(x, y, t);\n            this.clear();\n            this.drawComponent(this.stroke);\n        } else {\n            throw new Error('Missing startInkCapture');\n        }\n    };\n\n    InkGrabber.prototype.endCapture = function (x, y, t) {\n        if (this.writing) {\n            this.stroke.addPoint(x, y, t);\n            this.clear();\n            this.drawComponent(this.stroke);\n            this.writing = false;\n        } else {\n            throw new Error('Missing startInkCapture');\n        }\n    };\n\n    // Export\n    scope.InkGrabber = InkGrabber;\n})(MyScript);\n","'use strict';\n'use strict';\n\n(function (scope) {\n    /**\n     * InkPaper\n     *\n     * @class InkPaper\n     * @param {Element} element\n     * @param {Object} [options]\n     * @param {Function} [callback] callback function\n     * @param {Object} callback.data The recognition result\n     * @param {Object} callback.err The err to the callback\n     * @constructor\n     */\n    function InkPaper(element, options, callback) {\n        this._element = element;\n        this._instanceId = undefined;\n        this._timerId = undefined;\n        this._initialized = false;\n        this._lastSentComponentIndex = 0;\n        this._components = [];\n        this._redoComponents = [];\n        this.isStarted = false;\n        this.resultCallback = callback;\n        this.changeCallback = undefined;\n\n\n        // Capture\n        var tempCanvas = _createCanvas(element, 'ms-temp-canvas');\n        this.canvasRatio = _getCanvasRatio(tempCanvas);\n        element.removeChild(tempCanvas);\n        //this.canvasRatio = 1;\n\n        this._captureCanvas = _createCanvas(element, 'ms-capture-canvas');\n\n        this._inkGrabber = new scope.InkGrabber(this._captureCanvas.getContext('2d'));\n\n        // Rendering\n        this._renderingCanvas = _createCanvas(element, 'ms-rendering-canvas');\n\n\n        this._textRenderer = new scope.TextRenderer(this._renderingCanvas.getContext('2d'));\n        this._mathRenderer = new scope.MathRenderer(this._renderingCanvas.getContext('2d'));\n        this._shapeRenderer = new scope.ShapeRenderer(this._renderingCanvas.getContext('2d'));\n        this._musicRenderer = new scope.MusicRenderer(this._renderingCanvas.getContext('2d'));\n        this._analyzerRenderer = new scope.AnalyzerRenderer(this._renderingCanvas.getContext('2d'));\n\n        // Recognition\n        this._textRecognizer = new scope.TextRecognizer();\n        this._mathRecognizer = new scope.MathRecognizer();\n        this._shapeRecognizer = new scope.ShapeRecognizer();\n        this._musicRecognizer = new scope.MusicRecognizer();\n        this._analyzerRecognizer = new scope.AnalyzerRecognizer();\n\n        this._textWSRecognizer = new scope.TextWSRecognizer(this._handleMessage.bind(this));\n        this._mathWSRecognizer = new scope.MathWSRecognizer(this._handleMessage.bind(this));\n\n        this._attachListeners(element);\n\n        this.options = { // Default options\n            type: scope.RecognitionType.TEXT,\n            protocol: scope.Protocol.REST,\n            ssl: true,\n            width: 400,\n            height: 300,\n            timeout: 2000,\n            typeset: false,\n            components: [],\n            textParameters: new scope.TextParameter(),\n            mathParameters: new scope.MathParameter(),\n            shapeParameters: new scope.ShapeParameter(),\n            musicParameters: new scope.MusicParameter(),\n            analyzerParameters: new scope.AnalyzerParameter()\n        };\n\n        if (options) {\n            for (var idx in options) {\n                if (options[idx] !== undefined) {\n                    this.options[idx] = options[idx]; // Override current options\n                }\n            }\n        }\n\n        // Recognition type\n        this.setType(this.options.type);\n\n        this.setHost(this.options.host);\n        this.setSSL(this.options.ssl);\n\n        this.setTextParameters(this.options.textParameters); // jshint ignore:line\n        this.setMathParameters(this.options.mathParameters); // jshint ignore:line\n        this.setShapeParameters(this.options.shapeParameters); // jshint ignore:line\n        this.setMusicParameters(this.options.musicParameters); // jshint ignore:line\n        this.setAnalyzerParameters(this.options.analyzerParameters); // jshint ignore:line\n\n        this.setProtocol(this.options.protocol);\n        this.setTimeout(this.options.timeout);\n        this.setApplicationKey(this.options.applicationKey);\n        this.setHmacKey(this.options.hmacKey);\n\n        this.setPenParameters(this.options.penParameters);\n\n        this.setPrecision(this.options.precision);\n        this.setTypeset(this.options.typeset);\n        this.setComponents(this.options.components);\n\n        this.setWidth(this.options.width);\n        this.setHeight(this.options.height);\n    }\n\n    /**\n     * Set the width\n     *\n     * @method setWidth\n     * @param {Number} width\n     */\n    InkPaper.prototype.setWidth = function (width) {\n        if (width > 0) {\n            this._captureCanvas.width = width * this.canvasRatio;\n            this._captureCanvas.style.width = width + 'px';\n            this._captureCanvas.getContext('2d').scale(this.canvasRatio, this.canvasRatio);\n\n            this._renderingCanvas.width = width * this.canvasRatio;\n            this._renderingCanvas.style.width = width + 'px';\n            this._renderingCanvas.getContext('2d').scale(this.canvasRatio, this.canvasRatio);\n        }\n        this._initRenderingCanvas();\n    };\n\n    /**\n     * Set the height\n     *\n     * @method setHeight\n     * @param {Number} height\n     */\n    InkPaper.prototype.setHeight = function (height) {\n        if (height > 0) {\n            this._captureCanvas.height = height * this.canvasRatio;\n            this._captureCanvas.style.height = height + 'px';\n            this._captureCanvas.getContext('2d').scale(this.canvasRatio, this.canvasRatio);\n\n            this._renderingCanvas.height = height * this.canvasRatio;\n            this._renderingCanvas.style.height = height + 'px';\n\n            this._renderingCanvas.getContext('2d').scale(this.canvasRatio, this.canvasRatio);\n        }\n        this._initRenderingCanvas();\n    };\n\n    /**\n     * Set the network protocol (REST or WebSocket)\n     *\n     * @param {'REST'|'WebSocket'} protocol\n     */\n    InkPaper.prototype.setProtocol = function (protocol) {\n        switch (protocol) {\n            case scope.Protocol.REST:\n                this._selectedRecognizer = this._selectedRESTRecognizer;\n                break;\n            case scope.Protocol.WS:\n                this.setTimeout(-1); // FIXME hack to avoid border issues\n                this._selectedRecognizer = this._selectedWSRecognizer;\n                break;\n            default:\n                throw new Error('Unknown protocol: ' + protocol);\n        }\n        this._instanceId = undefined;\n        this._initialized = false;\n        this._lastSentComponentIndex = 0;\n    };\n\n    /**\n     * Get the network protocol (REST or WebSocket)\n     *\n     * @returns {'REST'|'WebSocket'}\n     */\n    InkPaper.prototype.getProtocol = function () {\n        if (this._selectedRecognizer instanceof scope.AbstractWSRecognizer) {\n            return scope.Protocol.WS;\n        } else {\n            return scope.Protocol.REST;\n        }\n    };\n\n    /**\n     * Set recognition type\n     *\n     * @method setType\n     * @param {'TEXT'|'MATH'|'SHAPE'|'MUSIC'|'ANALYZER'} type\n     */\n    InkPaper.prototype.setType = function (type) {\n        switch (type) {\n            case scope.RecognitionType.TEXT:\n                this._selectedRenderer = this._textRenderer;\n                this._selectedRESTRecognizer = this._textRecognizer;\n                this._selectedWSRecognizer = this._textWSRecognizer;\n                break;\n            case scope.RecognitionType.MATH:\n                this._selectedRenderer = this._mathRenderer;\n                this._selectedRESTRecognizer = this._mathRecognizer;\n                this._selectedWSRecognizer = this._mathWSRecognizer;\n                break;\n            case scope.RecognitionType.SHAPE:\n                this._selectedRenderer = this._shapeRenderer;\n                this._selectedRESTRecognizer = this._shapeRecognizer;\n                break;\n            case scope.RecognitionType.MUSIC:\n                this._selectedRenderer = this._musicRenderer;\n                this._selectedRESTRecognizer = this._musicRecognizer;\n                break;\n            case scope.RecognitionType.ANALYZER:\n                this._selectedRenderer = this._analyzerRenderer;\n                this._selectedRESTRecognizer = this._analyzerRecognizer;\n                break;\n            default:\n                throw new Error('Unknown type: ' + type);\n        }\n        this._instanceId = undefined;\n        this._initialized = false;\n        this._lastSentComponentIndex = 0;\n    };\n\n    /**\n     * Get recognition type\n     *\n     * @method getType\n     * @returns {'TEXT'|'MATH'|'SHAPE'|'MUSIC'|'ANALYZER'} type\n     */\n    InkPaper.prototype.getType = function () {\n        if (this._selectedRenderer instanceof scope.TextRenderer) {\n            return scope.RecognitionType.TEXT;\n        }\n        if (this._selectedRenderer instanceof scope.MathRenderer) {\n            return scope.RecognitionType.MATH;\n        }\n        if (this._selectedRenderer instanceof scope.ShapeRenderer) {\n            return scope.RecognitionType.SHAPE;\n        }\n        if (this._selectedRenderer instanceof scope.MusicRenderer) {\n            return scope.RecognitionType.MUSIC;\n        }\n        if (this._selectedRenderer instanceof scope.AnalyzerRenderer) {\n            return scope.RecognitionType.ANALYZER;\n        }\n        throw new Error('Unknown type');\n    };\n\n    /**\n     * Get the recognition timeout\n     *\n     * @method getTimeout\n     * @returns {Number}\n     */\n    InkPaper.prototype.getTimeout = function () {\n        return this.timeout;\n    };\n\n    /**\n     * Set the recognition timeout\n     *\n     * @method setTimeout\n     * @param {Number} timeout\n     */\n    InkPaper.prototype.setTimeout = function (timeout) {\n        this.timeout = timeout;\n    };\n\n    /**\n     * Set the recognition precision\n     *\n     * @method setPrecision\n     * @param {Number} precision\n     */\n    InkPaper.prototype.setPrecision = function (precision) {\n        this._textRecognizer.setPrecision(precision);\n        this._textWSRecognizer.setPrecision(precision);\n        this._mathRecognizer.setPrecision(precision);\n        this._mathWSRecognizer.setPrecision(precision);\n        this._shapeRecognizer.setPrecision(precision);\n        this._musicRecognizer.setPrecision(precision);\n        this._analyzerRecognizer.setPrecision(precision);\n    };\n\n    /**\n     * Get the default components\n     *\n     * @method getComponents\n     * @return {Array} components\n     */\n    InkPaper.prototype.getComponents = function () {\n        return this.options.components;\n    };\n\n    /**\n     * Set the default components\n     *\n     * @method setComponents\n     * @param {Array} components\n     */\n    InkPaper.prototype.setComponents = function (components) {\n        this.options.components = components;\n        this._initRenderingCanvas();\n    };\n\n\n    /**\n     * Get the application key\n     *\n     * @method getApplicationKey\n     * @returns {String}\n     */\n    InkPaper.prototype.getApplicationKey = function () {\n        return this.applicationKey;\n    };\n\n    /**\n     * Set the application key\n     *\n     * @method setApplicationKey\n     * @param {String} applicationKey\n     */\n    InkPaper.prototype.setApplicationKey = function (applicationKey) {\n        this.applicationKey = applicationKey;\n    };\n\n    /**\n     * Get the HMAC key\n     *\n     * @method getHmacKey\n     * @returns {String}\n     */\n    InkPaper.prototype.getHmacKey = function () {\n        return this.hmacKey;\n    };\n\n    /**\n     * Set the HMAC key\n     *\n     * @method setHmacKey\n     * @param {String} hmacKey\n     */\n    InkPaper.prototype.setHmacKey = function (hmacKey) {\n        this.hmacKey = hmacKey;\n    };\n\n    /**\n     * Set text recognition parameters\n     *\n     * @method setTextParameters\n     * @param {TextParameter} textParameters\n     */\n    InkPaper.prototype.setTextParameters = function (textParameters) {\n        if (textParameters) {\n            if (this._selectedRecognizer instanceof scope.AbstractWSRecognizer) {\n                this.isStarted = false;\n                this._selectedRecognizer.resetWSRecognition();\n            }\n            for (var i in textParameters) {\n                if (textParameters[i] !== undefined) {\n                    this._textRecognizer.getParameters()[i] = textParameters[i]; // Override options\n                    this._textWSRecognizer.getParameters()[i] = textParameters[i]; // Override options\n                    this._analyzerRecognizer.getParameters().getTextParameters()[i] = textParameters[i]; // Override options\n                }\n            }\n        }\n    };\n\n    /**\n     * Get text recognition parameters\n     *\n     * @method getTextParameters\n     * @returns {TextParameter} textParameters\n     */\n    InkPaper.prototype.getTextParameters = function () {\n        return this._textRecognizer.getParameters();\n    };\n\n    /**\n     * Set math recognition parameters\n     *\n     * @method setMathParameters\n     * @param {MathParameter} mathParameters\n     */\n    InkPaper.prototype.setMathParameters = function (mathParameters) {\n        if (mathParameters) {\n            if (this._selectedRecognizer instanceof scope.AbstractWSRecognizer) {\n                this.isStarted = false;\n                this._selectedRecognizer.resetWSRecognition();\n            }\n            for (var i in mathParameters) {\n                if (mathParameters[i] !== undefined) {\n                    this._mathRecognizer.getParameters()[i] = mathParameters[i]; // Override options\n                    this._mathWSRecognizer.getParameters()[i] = mathParameters[i]; // Override options\n                }\n            }\n        }\n    };\n\n    /**\n     * Get math recognition parameters\n     *\n     * @method getMathParameters\n     * @returns {MathParameter} mathParameters\n     */\n    InkPaper.prototype.getMathParameters = function () {\n        return this._mathRecognizer.getParameters();\n    };\n\n    /**\n     * Set shape recognition parameters\n     *\n     * @method setShapeParameters\n     * @param {ShapeParameter} shapeParameters\n     */\n    InkPaper.prototype.setShapeParameters = function (shapeParameters) {\n        if (shapeParameters) {\n            if (this._selectedRecognizer instanceof scope.AbstractWSRecognizer) {\n                this.isStarted = false;\n                this._selectedRecognizer.resetWSRecognition();\n            }\n            for (var i in shapeParameters) {\n                if (shapeParameters[i] !== undefined) {\n                    this._shapeRecognizer.getParameters()[i] = shapeParameters[i]; // Override options\n                }\n            }\n        }\n    };\n\n    /**\n     * Get shape recognition parameters\n     *\n     * @method getShapeParameters\n     * @returns {ShapeParameter} shapeParameters\n     */\n    InkPaper.prototype.getShapeParameters = function () {\n        return this._shapeRecognizer.getParameters();\n    };\n\n    /**\n     * Set music recognition parameters\n     *\n     * @method setMusicParameters\n     * @param {MusicParameter} musicParameters\n     */\n    InkPaper.prototype.setMusicParameters = function (musicParameters) {\n        if (musicParameters) {\n            if (this._selectedRecognizer instanceof scope.AbstractWSRecognizer) {\n                this.isStarted = false;\n                this._selectedRecognizer.resetWSRecognition();\n            }\n            for (var i in musicParameters) {\n                if (musicParameters[i] !== undefined) {\n                    this._musicRecognizer.getParameters()[i] = musicParameters[i]; // Override options\n                }\n            }\n            this._initRenderingCanvas();\n        }\n    };\n\n    /**\n     * Get music recognition parameters\n     *\n     * @method getMusicParameters\n     * @returns {MusicParameter} musicParameters\n     */\n    InkPaper.prototype.getMusicParameters = function () {\n        return this._musicRecognizer.getParameters();\n    };\n\n    /**\n     * Set analyzer recognition parameters\n     *\n     * @method setAnalyzerParameters\n     * @param {AnalyzerParameter} analyzerParameters\n     */\n    InkPaper.prototype.setAnalyzerParameters = function (analyzerParameters) {\n        if (analyzerParameters) {\n            if (this._selectedRecognizer instanceof scope.AbstractWSRecognizer) {\n                this.isStarted = false;\n                this._selectedRecognizer.resetWSRecognition();\n            }\n            for (var i in analyzerParameters) {\n                if (analyzerParameters[i] !== undefined) {\n                    this._analyzerRecognizer.getParameters()[i] = analyzerParameters[i]; // Override options\n                }\n            }\n        }\n    };\n\n    /**\n     * Get analyzer recognition parameters\n     *\n     * @method getAnalyzerParameters\n     * @returns {AnalyzerParameter} analyzerParameters\n     */\n    InkPaper.prototype.getAnalyzerParameters = function () {\n        return this._analyzerRecognizer.getParameters();\n    };\n\n    /**\n     * Set pen parameters\n     *\n     * @method setPenParameters\n     * @param {PenParameters} penParameters\n     */\n    InkPaper.prototype.setPenParameters = function (penParameters) {\n        if (penParameters) {\n            for (var i in penParameters) {\n                if (penParameters[i] !== undefined) {\n                    this._selectedRenderer.getParameters()[i] = penParameters[i]; // Override options\n                }\n            }\n            var params = this._selectedRenderer.getParameters();\n            this._inkGrabber.setParameters(params); // Override options\n            this._textRenderer.setParameters(params); // Override options\n            this._mathRenderer.setParameters(params); // Override options\n            this._shapeRenderer.setParameters(params); // Override options\n            this._musicRenderer.setParameters(params); // Override options\n            this._analyzerRenderer.setParameters(params); // Override options\n        }\n    };\n\n    /**\n     * Get pen parameters\n     *\n     * @method getPenParameters\n     * @returns {PenParameters} penParameters\n     */\n    InkPaper.prototype.getPenParameters = function () {\n        return this._selectedRenderer.getParameters();\n    };\n\n    /**\n     * Enable / disable typeset\n     *\n     * @method setTypeset\n     * @param {Boolean} typeset\n     */\n    InkPaper.prototype.setTypeset = function (typeset) {\n        this._textRenderer.setTypeset(typeset);\n        this._mathRenderer.setTypeset(typeset);\n        this._shapeRenderer.setTypeset(typeset);\n        this._musicRenderer.setTypeset(typeset);\n        this._analyzerRenderer.setTypeset(typeset);\n    };\n\n    /**\n     * Get available languages\n     *\n     * @method getAvailableLanguages\n     * @param {String} [inputMode] input mode\n     */\n    InkPaper.prototype.getAvailableLanguages = function (inputMode) {\n        this._selectedRESTRecognizer.getAvailableLanguageList(\n            this.getApplicationKey(),\n            inputMode ? inputMode : this._textRecognizer.getParameters().getInputMode()\n        ).then(\n            function (data) {\n                this._onResult(data);\n            }.bind(this),\n            function (error) {\n                this._onResult(undefined, error);\n            }.bind(this)\n        );\n    };\n\n    /**\n     * Get the renderer\n     *\n     * @method getRenderer\n     * @returns {AbstractRenderer}\n     */\n    InkPaper.prototype.getRenderer = function () {\n        return this._selectedRenderer;\n    };\n\n    /**\n     * Get the ink capturer\n     *\n     * @method getInkGrabber\n     * @returns {InkGrabber}\n     */\n    InkPaper.prototype.getInkGrabber = function () {\n        return this._inkGrabber;\n    };\n\n    /**\n     * Get the recognizer\n     *\n     * @method getRecognizer\n     * @returns {AbstractRecognizer}\n     */\n    InkPaper.prototype.getRecognizer = function () {\n        return this._selectedRecognizer;\n    };\n\n    /**\n     * Set the change callback\n     *\n     * @method setChangeCallback\n     * @param {Function} callback callback function\n     * @param {Object} callback.data The inkPaper state\n     */\n    InkPaper.prototype.setChangeCallback = function (changeCallback) {\n        this.changeCallback = changeCallback;\n    };\n\n    /**\n     * Set the recognition result callback\n     *\n     * @method setResultCallback\n     * @param {Function} callback callback function\n     * @param {Object} callback.data The recognition result\n     */\n    InkPaper.prototype.setResultCallback = function (callback) {\n        this.resultCallback = callback;\n    };\n\n    /**\n     * Recognize\n     *\n     * @method recognize\n     * @returns {Promise}\n     */\n    InkPaper.prototype.recognize = function () {\n        var input = this.getComponents().concat(this._components);\n        if (this._selectedRecognizer instanceof scope.AbstractWSRecognizer) {\n            if (this._initialized) {\n                var lastInput = input.slice(this._lastSentComponentIndex);\n\n                if (lastInput.length > 0) {\n                    this._lastSentComponentIndex = input.length;\n                    if (!this.isStarted) {\n                        this.isStarted = true;\n                        this._selectedRecognizer.startWSRecognition(lastInput);\n                    } else {\n                        this._selectedRecognizer.continueWSRecognition(lastInput, this._instanceId);\n                    }\n                } else {\n                    this._renderResult();\n                }\n            }\n        } else {\n            if (this._selectedRecognizer instanceof scope.ShapeRecognizer) {\n                this._instanceId = undefined;\n            }\n\n            if (input.length > 0) {\n                if (!this.isStarted) {\n                    this._startRESTRecognition(input);\n                } else {\n                    this._continueRESTRecognition(input, this._instanceId);\n                }\n            } else {\n                this._renderResult();\n            }\n        }\n    };\n\n    InkPaper.prototype._startRESTRecognition = function (components) {\n\n        this._instanceId = undefined;\n        this._selectedRecognizer.doSimpleRecognition(\n            this.getApplicationKey(),\n            this._instanceId,\n            components,\n            this.getHmacKey()\n        ).then(\n            function (data) {\n                if (!this.isStarted) {\n                    this.isStarted = true;\n                    this._lastSentComponentIndex = components.length;\n                    this._instanceId = data.getInstanceId();\n                    this._renderResult(data);\n                }\n            }.bind(this),\n            function (error) {\n                this._onResult(undefined, error);\n            }.bind(this)\n        );\n    };\n\n    InkPaper.prototype._continueRESTRecognition = function (components, instanceId) {\n\n        this._selectedRecognizer.doSimpleRecognition(\n            this.getApplicationKey(),\n            instanceId,\n            components,\n            this.getHmacKey()\n        ).then(\n            function (data) {\n                this._lastSentComponentIndex = this._lastSentComponentIndex + components.length;\n                this._renderResult(data);\n            }.bind(this),\n            function (error) {\n                this._onResult(undefined, error);\n            }.bind(this)\n        );\n    };\n\n    InkPaper.prototype._clearRESTRecognition = function (instanceId) {\n\n        if (this._selectedRecognizer instanceof scope.ShapeRecognizer) {\n            this.isStarted = false;\n            this._lastSentComponentIndex = 0;\n            this._selectedRecognizer.clearShapeRecognitionSession(\n                this.getApplicationKey(),\n                instanceId\n            ).then(\n                function (data) {\n                    this._instanceId = undefined;\n                    this._onResult(data);\n                }.bind(this),\n                function (error) {\n                    this._onResult(undefined, error);\n                }.bind(this)\n            );\n        } else {\n            this._onResult();\n        }\n    };\n\n    /**\n     * Return true if you can undo\n     *\n     * @method canUndo\n     * @returns {Boolean}\n     */\n    InkPaper.prototype.canUndo = function () {\n        return this._components.length > 0;\n    };\n\n    /**\n     * Undo\n     *\n     * @method undo\n     */\n    InkPaper.prototype.undo = function () {\n        if (this.canUndo()) {\n            //Remove the scratched state for Math strokes\n            this._components.forEach(function(stroke){\n                stroke.scratchedStroke = false;\n            });\n            //Remove the latsModel used for Shape\n            this.updatedModel = undefined;\n\n            this._redoComponents.push(this._components.pop());\n\n            this._clearRESTRecognition(this._instanceId);\n\n            this._initRenderingCanvas();\n            this._onChange();\n\n            this.isStarted = false;\n            if (this._selectedRecognizer instanceof scope.AbstractWSRecognizer) {\n                this._selectedRecognizer.resetWSRecognition();\n            } else {\n                clearTimeout(this._timerId);\n                if (this.getTimeout() > -1) {\n                    this._timerId = setTimeout(this.recognize.bind(this), this.getTimeout());\n                } else {\n                    this._onResult();\n                }\n            }\n        }\n    };\n\n    /**\n     * Return true if you can redo\n     *\n     * @method canRedo\n     * @returns {Boolean}\n     */\n    InkPaper.prototype.canRedo = function () {\n        return this._redoComponents.length > 0;\n    };\n\n    /**\n     * Redo\n     *\n     * @method redo\n     */\n    InkPaper.prototype.redo = function () {\n        if (this.canRedo()) {\n            this._components.push(this._redoComponents.pop());\n\n            this._clearRESTRecognition(this._instanceId);\n\n            this._initRenderingCanvas();\n            this._onChange();\n\n            if (this._selectedRecognizer instanceof scope.AbstractWSRecognizer) {\n                this.recognize();\n            } else {\n                clearTimeout(this._timerId);\n                this.isStarted = false;\n                if (this.getTimeout() > -1) {\n                    this._timerId = setTimeout(this.recognize.bind(this), this.getTimeout());\n                } else {\n                    this._onResult();\n                }\n            }\n        }\n    };\n\n    /**\n     * Clear the ink paper\n     *\n     * @method clear\n     */\n    InkPaper.prototype.clear = function () {\n        this._components = [];\n        this._redoComponents = [];\n\n        this._clearRESTRecognition(this._instanceId);\n\n        this._initRenderingCanvas();\n        this._onChange();\n\n        if (this._selectedRecognizer instanceof scope.AbstractWSRecognizer) {\n            this.isStarted = false;\n            this._selectedRecognizer.resetWSRecognition();\n        } else {\n            clearTimeout(this._timerId);\n            if (this.getTimeout() > -1) {\n                this._timerId = setTimeout(this.recognize.bind(this), this.getTimeout());\n            } else {\n                this._onResult();\n            }\n        }\n    };\n\n    InkPaper.event = {\n        'addDomListener': function (element, useCapture, myfunction) {\n            element.addEventListener(useCapture, myfunction);\n        }\n    };\n\n    /**\n     *\n     * @private\n     * @method _down\n     * @param {Number} x X coordinate\n     * @param {Number} y Y coordinate\n     * @param {Date} [t] timeStamp\n     */\n    InkPaper.prototype._down = function (x, y, t) {\n        clearTimeout(this._timerId);\n        var sizeChanged = false;\n        if (this._captureCanvas.clientHeight * this.canvasRatio !== this._captureCanvas.height) {\n            this._captureCanvas.height = this._captureCanvas.clientHeight * this.canvasRatio;\n            this._renderingCanvas.height = this._renderingCanvas.clientHeight * this.canvasRatio;\n            sizeChanged = true;\n        }\n\n        if (this._captureCanvas.clientWidth * this.canvasRatio !== this._captureCanvas.width) {\n            this._captureCanvas.width = this._captureCanvas.clientWidth * this.canvasRatio;\n            this._renderingCanvas.width = this._renderingCanvas.clientWidth * this.canvasRatio;\n            sizeChanged = true;\n        }\n\n        //Safari trash the canvas content when heigth or width are modified.\n        if (sizeChanged) {\n\n            this._captureCanvas.getContext('2d').scale(this.canvasRatio, this.canvasRatio);\n            this._renderingCanvas.getContext('2d').scale(this.canvasRatio, this.canvasRatio);\n            this._initRenderingCanvas();\n        }\n\n        if (this.canRedo()) {\n            this._redoComponents = [];\n            this._onChange();\n        }\n\n        this._inkGrabber.startCapture(x, y, t);\n\n\n    };\n\n    /**\n     *\n     * @private\n     * @method _move\n     * @param {Number} x X coordinate\n     * @param {Number} y Y coordinate\n     * @param {Date} [t] timeStamp\n     */\n    InkPaper.prototype._move = function (x, y, t) {\n        this._inkGrabber.continueCapture(x, y, t);\n    };\n\n    /**\n     *\n     * @private\n     * @method _move\n     * @param {Number} x X coordinate\n     * @param {Number} y Y coordinate\n     * @param {Date} [t] timeStamp\n     */\n    InkPaper.prototype._up = function (x, y, t) {\n        this._inkGrabber.endCapture(x, y, t);\n\n        var stroke = this._inkGrabber.getStroke();\n\n        this._inkGrabber.clear();\n        this._selectedRenderer.drawComponent(stroke);\n\n        this._components.push(stroke);\n        this._onChange();\n\n        if (this._selectedRecognizer instanceof scope.AbstractWSRecognizer) {\n            if (!this._selectedRecognizer.isOpen() && !this._selectedRecognizer.isConnecting()) {\n                this._selectedRecognizer.open();\n            } else {\n                this.recognize();\n            }\n        } else {\n            clearTimeout(this._timerId);\n            if (this.getTimeout() > -1) {\n                this._timerId = setTimeout(this.recognize.bind(this), this.getTimeout());\n            }\n        }\n    };\n\n    InkPaper.prototype._onResult = function (data, err) {\n        if (this.resultCallback) {\n            this.resultCallback(data, err);\n        }\n        if (err) {\n            this._element.dispatchEvent(new CustomEvent('error', {detail: err}));\n        } else {\n            this._element.dispatchEvent(new CustomEvent('success', {detail: data}));\n        }\n    };\n\n    InkPaper.prototype._onChange = function () {\n        var data = {\n            canUndo: this.canUndo(),\n            undoLength: this._components.length,\n            canRedo: this.canRedo(),\n            redoLength: this._redoComponents.length\n        };\n\n        if (this.changeCallback) {\n            this.changeCallback(data)\n        }\n        this._element.dispatchEvent(new CustomEvent('changed', {detail: data}));\n    };\n\n    InkPaper.prototype._renderResult = function (data) {\n        this.updatedModel = this._selectedRenderer.drawRecognitionResult(this.getComponents().concat(this._components), data? data.getDocument(): undefined);\n        if (this._selectedRecognizer instanceof scope.MusicRecognizer) {\n            if (this._selectedRecognizer.getParameters().getStaff() instanceof scope.MusicStaff) {\n                this._selectedRenderer.drawStaff(this._selectedRecognizer.getParameters().getStaff());\n            }\n        }\n        this._onResult(data);\n        return data;\n    };\n\n    /**\n     * Set recognition service url\n     *\n     * @param {String} host\n     */\n    InkPaper.prototype.setHost = function (host) {\n        this._textRecognizer.setHost(host);\n        this._textWSRecognizer.setHost(host);\n        this._mathRecognizer.setHost(host);\n        this._mathWSRecognizer.setHost(host);\n        this._shapeRecognizer.setHost(host);\n        this._musicRecognizer.setHost(host);\n        this._analyzerRecognizer.setHost(host);\n    };\n\n    /**\n     * @private\n     */\n    InkPaper.prototype.setSSL = function (ssl) {\n        this._textRecognizer.setSSL(ssl);\n        this._textWSRecognizer.setSSL(ssl);\n        this._mathRecognizer.setSSL(ssl);\n        this._mathWSRecognizer.setSSL(ssl);\n        this._shapeRecognizer.setSSL(ssl);\n        this._musicRecognizer.setSSL(ssl);\n        this._analyzerRecognizer.setSSL(ssl);\n    };\n\n    /**\n     * Tool to attach touch events\n     *\n     * @private\n     * @param {Element} element\n     */\n    InkPaper.prototype._attachListeners = function (element) {\n        var self = this;\n        var pointerId;\n\n        //Desactivation of contextmenu to prevent safari to fire pointerdown only once\n        element.addEventListener(\"contextmenu\", function (e) {\n                                     e.preventDefault();\n                                     e.stopPropagation();\n                                     return false;\n                                 }\n        );\n\n        element.addEventListener('pointerdown', function (e) {\n            if (!pointerId) {\n                pointerId = e.pointerId;\n                e.preventDefault();pointerId\n                var coord = _getCoordinates(e, element);\n                self._down(coord.x, coord.y, coord.t);\n            }\n        }, false);\n\n        element.addEventListener('pointermove', function (e) {\n            if (pointerId === e.pointerId) {\n                e.preventDefault();\n\n                var coord = _getCoordinates(e, element);\n                self._move(coord.x, coord.y, coord.t);\n            }\n        }, false);\n\n        element.addEventListener('pointerup', function (e) {\n            if (pointerId === e.pointerId) {\n                e.preventDefault();\n\n                var coord = _getCoordinates(e, element);\n                self._up(coord.x, coord.y, coord.t);\n\n                pointerId = undefined;\n            }\n        }, false);\n\n        element.addEventListener('pointerleave', function (e) {\n            if (pointerId === e.pointerId) {\n                e.preventDefault();\n\n                var point = self._inkGrabber.getStroke().getPointByIndex(self._inkGrabber.getStroke().getLastIndexPoint());\n                self._up(point.x, point.y, point.t);\n                pointerId = undefined;\n            }\n        }, false);\n\n        element.addEventListener('pointerout', function (e) {\n            if (pointerId === e.pointerId) {\n                e.preventDefault();\n\n                var point = self._inkGrabber.getStroke().getPointByIndex(self._inkGrabber.getStroke().getLastIndexPoint());\n                self._up(point.x, point.y, point.t);\n                pointerId = undefined;\n            }\n        }, false);\n    };\n\n    InkPaper.prototype._initRenderingCanvas = function () {\n        this._selectedRenderer.clear();\n\n        if (this._selectedRecognizer instanceof scope.MusicRecognizer) {\n            if (this._selectedRecognizer.getParameters().getStaff() instanceof scope.MusicStaff) {\n                this._selectedRenderer.drawStaff(this._selectedRecognizer.getParameters().getStaff());\n            }\n        }\n        if(this._selectedRecognizer instanceof scope.ShapeRecognizer && this.updatedModel){\n            this._selectedRenderer.drawRecognitionResult(this.updatedModel.components, this.updatedModel.document);\n        } else {\n            this._selectedRenderer.drawComponents(this.getComponents().concat(this._components));\n        }\n    };\n\n    /**\n     *\n     * @param message\n     * @param error\n     * @returns {boolean} false no immediate replay needed, true when the call need to be replay ASAP\n     * @private\n     */\n    InkPaper.prototype._handleMessage = function (message, error) {\n        var replayNeeded = false;\n        if (error) {\n            replayNeeded = true;\n            this._instanceId = undefined;\n            this.isStarted = false;\n            this._lastSentComponentIndex = 0;\n            this._onResult(undefined, error);\n        }\n\n        if (message) {\n            switch (message.type) {\n                case 'open':\n                    this._selectedWSRecognizer.initWSRecognition(this.getApplicationKey());\n                    break;\n                case 'hmacChallenge':\n                    this._selectedWSRecognizer.takeUpHmacChallenge(this.getApplicationKey(), message.getChallenge(), this.getHmacKey());\n                    break;\n                case 'init':\n                    this.isStarted = false;\n                    this._initialized = true;\n                    this._instanceId = undefined;\n                    this._lastSentComponentIndex = 0;\n                    this.recognize();\n                    break;\n                case 'reset':\n                    this.isStarted = false;\n                    this._instanceId = undefined;\n                    this._lastSentComponentIndex = 0;\n                    this.recognize();\n                    break;\n                case 'close':\n                    this._initialized = false;\n                    this._instanceId = undefined;\n                    this._lastSentComponentIndex = 0;\n                    break;\n                default:\n                    this.isStarted = true;\n                    if (!this._instanceId) {\n                        this._instanceId = message.getInstanceId();\n                    }\n                    this._renderResult(message);\n                    break;\n            }\n        }\n        return replayNeeded;\n    };\n\n    /**\n     * Return the stats allowing to monitor what ink size is send to the server.\n     * @returns Stats objects format {strokesCount : 0, pointsCount : 0, byteSize : 0, humanSize : 0, humanUnit : 'BYTE'} humanUnit could have the values BYTE, BYTES, KiB, MiB\n     */\n    InkPaper.prototype.getStats = function () {\n        var stats = {strokesCount: 0, pointsCount: 0, byteSize: 0, humanSize: 0, humanUnit: 'BYTE'};\n        if (this._components) {\n            stats.strokesCount = this._components.length;\n            var pointsCount = 0;\n            for (var strokeNb = 0; strokeNb < this._components.length; strokeNb++) {\n                pointsCount = pointsCount + this._components[strokeNb].x.length;\n            }\n            stats.strokesCount = this._components.length;\n            stats.pointsCount = pointsCount;\n            //We start with 270 as it is the size in bytes. Make a real computation implies to recode a doRecogntion\n            var byteSize = 270;\n            byteSize = JSON.stringify(this._components).length;\n            stats.byteSize = byteSize;\n            if (byteSize < 270) {\n                stats.humanUnit = 'BYTE';\n                stats.byteSize = 0;\n                stats.humanSize = 0;\n            } else if (byteSize < 2048) {\n                stats.humanUnit = 'BYTES';\n                stats.humanSize = byteSize;\n            } else if (byteSize < 1024 * 1024) {\n                stats.humanUnit = 'KiB';\n                stats.humanSize = (byteSize / 1024).toFixed(2);\n            } else {\n                stats.humanUnit = 'MiB';\n                stats.humanSize = (byteSize / 1024 / 1024).toFixed(2);\n            }\n        }\n        return stats;\n    };\n\n    /**\n     *\n     * @param marginX the horizontal margin to apply (by default 10)\n     * @param marginY the vertical margin to apply (by default 10)\n     * @returns {ImageData} Build an ImageData object with content shrink to border of strokes.\n     * @private\n     */\n    InkPaper.prototype.getInkAsImageData = function (marginX, marginY) {\n        //Remove the scratched strokes\n        var componentCopy = [];\n        this._components.forEach(function(stroke) {\n                                     if (stroke.scratchedStroke !== true) {\n                                         componentCopy.push(stroke);\n                                     }\n                                 }\n        );\n\n        if (!marginX) {\n            marginX = 10;\n        }\n        if (!marginY) {\n            marginY = 10;\n        }\n\n        if (componentCopy && componentCopy.length > 0) {\n            var updatedStrokes;\n            var strokesCount = componentCopy.length;\n            //Initializing min and max\n            var minX = componentCopy[0].x[0];\n            var maxX = componentCopy[0].x[0];\n            var minY = componentCopy[0].y[0];\n            var maxY = componentCopy[0].y[0];\n\n            // Computing the min and max for x and y\n            for (var strokeNb = 0; strokeNb < componentCopy.length; strokeNb++) {\n                var pointCount = componentCopy[strokeNb].x.length;\n                for (var pointNb = 0; pointNb < pointCount; pointNb++) {\n                    var currentX = componentCopy[strokeNb].x[pointNb];\n                    var currentY = componentCopy[strokeNb].y[pointNb];\n                    if (currentX < minX) {\n                        minX = currentX;\n                    }\n                    if (currentX > maxX) {\n                        maxX = currentX;\n                    }\n                    if (currentY < minY) {\n                        minY = currentY;\n                    }\n                    if (currentY > maxY) {\n                        maxY = currentY;\n                    }\n                }\n            }\n            var nonDisplayCanvas = document.createElement('canvas');\n            nonDisplayCanvas.width = (maxX ) + (2 * marginX);\n            nonDisplayCanvas.height = (maxY ) + (2 * marginY)\n\n            var ctx = nonDisplayCanvas.getContext(\"2d\");\n\n            var imageRendered = new scope.ImageRenderer(ctx);\n            imageRendered.drawComponents(componentCopy, ctx);\n\n            // https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/getImageData\n            return ctx.getImageData(minX - marginX, minY - marginY, (maxX - minX ) + (2 * marginX), (maxY - minY ) + (2 * marginY));\n        }\n    };\n\n    /**\n     *\n     * @param marginX the horizontal margin to apply (by default 10)\n     * @param marginY the vertical margin to apply (by default 10)\n     * @returns {String} Build an String containg dataUrl with content shrink to border of strokes.\n     * @private\n     */\n    InkPaper.prototype.getInkAsPng = function (marginX, marginY) {\n        var imageRenderingCanvas = document.createElement('canvas');\n        imageRenderingCanvas.style.display = 'none';\n\n        var imageDataToRender = this.getInkAsImageData();\n        imageRenderingCanvas.width = imageDataToRender.width;\n        imageRenderingCanvas.style.width = imageDataToRender.width + 'px';\n        imageRenderingCanvas.height = imageDataToRender.height;\n        imageRenderingCanvas.style.height = imageDataToRender.height + 'px';\n        var ctx = imageRenderingCanvas.getContext('2d');\n        ctx.putImageData(imageDataToRender, 0, 0);\n        return imageRenderingCanvas.toDataURL(\"image/png\");\n    };\n\n    /**\n     * Tool to create canvas\n     *\n     * @private\n     * @param {Element} parent\n     * @param {String} id\n     * @returns {Element}\n     */\n    function _createCanvas(parent, id) {\n        var count = document.querySelectorAll('canvas[id^=' + id + ']').length;\n        var canvas = document.createElement('canvas');\n        canvas.id = id + '-' + count;\n        parent.appendChild(canvas);\n        return canvas;\n    }\n\n    /**\n     * Tool to get canvas ratio (retina display)\n     *\n     * @private\n     * @param {Element} canvas\n     * @returns {Number}\n     */\n    function _getCanvasRatio(canvas) {\n        if (canvas) {\n            var context = canvas.getContext('2d'),\n                devicePixelRatio = window.devicePixelRatio || 1,\n                backingStoreRatio = context.webkitBackingStorePixelRatio ||\n                    context.mozBackingStorePixelRatio ||\n                    context.msBackingStorePixelRatio ||\n                    context.oBackingStorePixelRatio ||\n                    context.backingStorePixelRatio || 1;\n            return devicePixelRatio / backingStoreRatio;\n        }\n        return 1;\n    }\n\n\n    /**\n     * Tool to get proper coordinates\n     *\n     * @private\n     * @param {Event} e\n     * @param {Element} element\n     * @returns {Object}\n     */\n    function _getCoordinates(e, container) {\n        if (e.changedTouches) e = e.changedTouches[0];\n        var rect = container.getBoundingClientRect();\n        return {\n            x: e.clientX - rect.left - container.clientLeft,\n            y: e.clientY - rect.top - container.clientTop,\n            t: e.timeStamp\n        };\n    }\n\n    // Export\n    scope.InkPaper = InkPaper;\n})(MyScript);\n"],"sourceRoot":"/source/"}